(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module2, copyDefault, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module2, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
  };

  // node_modules/dommatrix/dist/dommatrix.js
  var require_dommatrix = __commonJS({
    "node_modules/dommatrix/dist/dommatrix.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.CSSMatrix = factory());
      })(exports2, function() {
        "use strict";
        function fromArray(array) {
          var m = new CSSMatrix();
          var a = Array.from(array);
          if (!a.every(function(n) {
            return !Number.isNaN(n);
          })) {
            throw TypeError('CSSMatrix: "' + array + '" must only have numbers.');
          }
          if (a.length === 16) {
            var m11 = a[0];
            var m12 = a[1];
            var m13 = a[2];
            var m14 = a[3];
            var m21 = a[4];
            var m22 = a[5];
            var m23 = a[6];
            var m24 = a[7];
            var m31 = a[8];
            var m32 = a[9];
            var m33 = a[10];
            var m34 = a[11];
            var m41 = a[12];
            var m42 = a[13];
            var m43 = a[14];
            var m44 = a[15];
            m.m11 = m11;
            m.a = m11;
            m.m21 = m21;
            m.c = m21;
            m.m31 = m31;
            m.m41 = m41;
            m.e = m41;
            m.m12 = m12;
            m.b = m12;
            m.m22 = m22;
            m.d = m22;
            m.m32 = m32;
            m.m42 = m42;
            m.f = m42;
            m.m13 = m13;
            m.m23 = m23;
            m.m33 = m33;
            m.m43 = m43;
            m.m14 = m14;
            m.m24 = m24;
            m.m34 = m34;
            m.m44 = m44;
          } else if (a.length === 6) {
            var M11 = a[0];
            var M12 = a[1];
            var M21 = a[2];
            var M22 = a[3];
            var M41 = a[4];
            var M42 = a[5];
            m.m11 = M11;
            m.a = M11;
            m.m12 = M12;
            m.b = M12;
            m.m21 = M21;
            m.c = M21;
            m.m22 = M22;
            m.d = M22;
            m.m41 = M41;
            m.e = M41;
            m.m42 = M42;
            m.f = M42;
          } else {
            throw new TypeError("CSSMatrix: expecting an Array of 6/16 values.");
          }
          return m;
        }
        function fromMatrix(m) {
          var keys = Object.keys(new CSSMatrix());
          if (typeof m === "object" && keys.every(function(k) {
            return k in m;
          })) {
            return fromArray([
              m.m11,
              m.m12,
              m.m13,
              m.m14,
              m.m21,
              m.m22,
              m.m23,
              m.m24,
              m.m31,
              m.m32,
              m.m33,
              m.m34,
              m.m41,
              m.m42,
              m.m43,
              m.m44
            ]);
          }
          throw TypeError('CSSMatrix: "' + JSON.stringify(m) + '" is not a DOMMatrix / CSSMatrix / JSON compatible object.');
        }
        function fromString(source) {
          if (typeof source !== "string") {
            throw TypeError('CSSMatrix: "' + source + '" is not a string.');
          }
          var str = String(source).replace(/\s/g, "");
          var m = new CSSMatrix();
          var invalidStringError = 'CSSMatrix: invalid transform string "' + source + '"';
          str.split(")").filter(function(f) {
            return f;
          }).forEach(function(tf) {
            var ref = tf.split("(");
            var prop = ref[0];
            var value = ref[1];
            if (!value) {
              throw TypeError(invalidStringError);
            }
            var components = value.split(",").map(function(n) {
              return n.includes("rad") ? parseFloat(n) * (180 / Math.PI) : parseFloat(n);
            });
            var x = components[0];
            var y = components[1];
            var z = components[2];
            var a = components[3];
            var xyz = [x, y, z];
            var xyza = [x, y, z, a];
            if (prop === "perspective" && x && [y, z].every(function(n) {
              return n === void 0;
            })) {
              m.m34 = -1 / x;
            } else if (prop.includes("matrix") && [6, 16].includes(components.length) && components.every(function(n) {
              return !Number.isNaN(+n);
            })) {
              var values = components.map(function(n) {
                return Math.abs(n) < 1e-6 ? 0 : n;
              });
              m = m.multiply(fromArray(values));
            } else if (prop === "translate3d" && xyz.every(function(n) {
              return !Number.isNaN(+n);
            })) {
              m = m.translate(x, y, z);
            } else if (prop === "translate" && x && z === void 0) {
              m = m.translate(x, y || 0, 0);
            } else if (prop === "rotate3d" && xyza.every(function(n) {
              return !Number.isNaN(+n);
            }) && a) {
              m = m.rotateAxisAngle(x, y, z, a);
            } else if (prop === "rotate" && x && [y, z].every(function(n) {
              return n === void 0;
            })) {
              m = m.rotate(0, 0, x);
            } else if (prop === "scale3d" && xyz.every(function(n) {
              return !Number.isNaN(+n);
            }) && xyz.some(function(n) {
              return n !== 1;
            })) {
              m = m.scale(x, y, z);
            } else if (prop === "scale" && !Number.isNaN(x) && x !== 1 && z === void 0) {
              var nosy = Number.isNaN(+y);
              var sy = nosy ? x : y;
              m = m.scale(x, sy, 1);
            } else if (prop === "skew" && (x || !Number.isNaN(x) && y) && z === void 0) {
              m = m.skew(x, y || 0);
            } else if (/[XYZ]/.test(prop) && x && [y, z].every(function(n) {
              return n === void 0;
            }) && ["translate", "rotate", "scale", "skew"].some(function(p) {
              return prop.includes(p);
            })) {
              if (["skewX", "skewY"].includes(prop)) {
                m = m[prop](x);
              } else {
                var fn = prop.replace(/[XYZ]/, "");
                var axis = prop.replace(fn, "");
                var idx = ["X", "Y", "Z"].indexOf(axis);
                var def = fn === "scale" ? 1 : 0;
                var axeValues = [
                  idx === 0 ? x : def,
                  idx === 1 ? x : def,
                  idx === 2 ? x : def
                ];
                m = m[fn].apply(m, axeValues);
              }
            } else {
              throw TypeError(invalidStringError);
            }
          });
          return m;
        }
        function toArray(m, is2D) {
          if (is2D) {
            return [m.a, m.b, m.c, m.d, m.e, m.f];
          }
          return [
            m.m11,
            m.m12,
            m.m13,
            m.m14,
            m.m21,
            m.m22,
            m.m23,
            m.m24,
            m.m31,
            m.m32,
            m.m33,
            m.m34,
            m.m41,
            m.m42,
            m.m43,
            m.m44
          ];
        }
        function Translate(x, y, z) {
          var m = new CSSMatrix();
          m.m41 = x;
          m.e = x;
          m.m42 = y;
          m.f = y;
          m.m43 = z;
          return m;
        }
        function Rotate(rx, ry, rz) {
          var m = new CSSMatrix();
          var degToRad = Math.PI / 180;
          var radX = rx * degToRad;
          var radY = ry * degToRad;
          var radZ = rz * degToRad;
          var cosx = Math.cos(radX);
          var sinx = -Math.sin(radX);
          var cosy = Math.cos(radY);
          var siny = -Math.sin(radY);
          var cosz = Math.cos(radZ);
          var sinz = -Math.sin(radZ);
          var m11 = cosy * cosz;
          var m12 = -cosy * sinz;
          m.m11 = m11;
          m.a = m11;
          m.m12 = m12;
          m.b = m12;
          m.m13 = siny;
          var m21 = sinx * siny * cosz + cosx * sinz;
          m.m21 = m21;
          m.c = m21;
          var m22 = cosx * cosz - sinx * siny * sinz;
          m.m22 = m22;
          m.d = m22;
          m.m23 = -sinx * cosy;
          m.m31 = sinx * sinz - cosx * siny * cosz;
          m.m32 = sinx * cosz + cosx * siny * sinz;
          m.m33 = cosx * cosy;
          return m;
        }
        function RotateAxisAngle(x, y, z, alpha) {
          var m = new CSSMatrix();
          var length = Math.sqrt(x * x + y * y + z * z);
          if (length === 0) {
            return m;
          }
          var X = x / length;
          var Y = y / length;
          var Z = z / length;
          var angle = alpha * (Math.PI / 360);
          var sinA = Math.sin(angle);
          var cosA = Math.cos(angle);
          var sinA2 = sinA * sinA;
          var x2 = X * X;
          var y2 = Y * Y;
          var z2 = Z * Z;
          var m11 = 1 - 2 * (y2 + z2) * sinA2;
          m.m11 = m11;
          m.a = m11;
          var m12 = 2 * (X * Y * sinA2 + Z * sinA * cosA);
          m.m12 = m12;
          m.b = m12;
          m.m13 = 2 * (X * Z * sinA2 - Y * sinA * cosA);
          var m21 = 2 * (Y * X * sinA2 - Z * sinA * cosA);
          m.m21 = m21;
          m.c = m21;
          var m22 = 1 - 2 * (z2 + x2) * sinA2;
          m.m22 = m22;
          m.d = m22;
          m.m23 = 2 * (Y * Z * sinA2 + X * sinA * cosA);
          m.m31 = 2 * (Z * X * sinA2 + Y * sinA * cosA);
          m.m32 = 2 * (Z * Y * sinA2 - X * sinA * cosA);
          m.m33 = 1 - 2 * (x2 + y2) * sinA2;
          return m;
        }
        function Scale(x, y, z) {
          var m = new CSSMatrix();
          m.m11 = x;
          m.a = x;
          m.m22 = y;
          m.d = y;
          m.m33 = z;
          return m;
        }
        function Skew(angleX, angleY) {
          var m = new CSSMatrix();
          if (angleX) {
            var radX = angleX * Math.PI / 180;
            var tX = Math.tan(radX);
            m.m21 = tX;
            m.c = tX;
          }
          if (angleY) {
            var radY = angleY * Math.PI / 180;
            var tY = Math.tan(radY);
            m.m12 = tY;
            m.b = tY;
          }
          return m;
        }
        function SkewX(angle) {
          return Skew(angle, 0);
        }
        function SkewY(angle) {
          return Skew(0, angle);
        }
        function Multiply(m1, m2) {
          var m11 = m2.m11 * m1.m11 + m2.m12 * m1.m21 + m2.m13 * m1.m31 + m2.m14 * m1.m41;
          var m12 = m2.m11 * m1.m12 + m2.m12 * m1.m22 + m2.m13 * m1.m32 + m2.m14 * m1.m42;
          var m13 = m2.m11 * m1.m13 + m2.m12 * m1.m23 + m2.m13 * m1.m33 + m2.m14 * m1.m43;
          var m14 = m2.m11 * m1.m14 + m2.m12 * m1.m24 + m2.m13 * m1.m34 + m2.m14 * m1.m44;
          var m21 = m2.m21 * m1.m11 + m2.m22 * m1.m21 + m2.m23 * m1.m31 + m2.m24 * m1.m41;
          var m22 = m2.m21 * m1.m12 + m2.m22 * m1.m22 + m2.m23 * m1.m32 + m2.m24 * m1.m42;
          var m23 = m2.m21 * m1.m13 + m2.m22 * m1.m23 + m2.m23 * m1.m33 + m2.m24 * m1.m43;
          var m24 = m2.m21 * m1.m14 + m2.m22 * m1.m24 + m2.m23 * m1.m34 + m2.m24 * m1.m44;
          var m31 = m2.m31 * m1.m11 + m2.m32 * m1.m21 + m2.m33 * m1.m31 + m2.m34 * m1.m41;
          var m32 = m2.m31 * m1.m12 + m2.m32 * m1.m22 + m2.m33 * m1.m32 + m2.m34 * m1.m42;
          var m33 = m2.m31 * m1.m13 + m2.m32 * m1.m23 + m2.m33 * m1.m33 + m2.m34 * m1.m43;
          var m34 = m2.m31 * m1.m14 + m2.m32 * m1.m24 + m2.m33 * m1.m34 + m2.m34 * m1.m44;
          var m41 = m2.m41 * m1.m11 + m2.m42 * m1.m21 + m2.m43 * m1.m31 + m2.m44 * m1.m41;
          var m42 = m2.m41 * m1.m12 + m2.m42 * m1.m22 + m2.m43 * m1.m32 + m2.m44 * m1.m42;
          var m43 = m2.m41 * m1.m13 + m2.m42 * m1.m23 + m2.m43 * m1.m33 + m2.m44 * m1.m43;
          var m44 = m2.m41 * m1.m14 + m2.m42 * m1.m24 + m2.m43 * m1.m34 + m2.m44 * m1.m44;
          return fromArray([
            m11,
            m12,
            m13,
            m14,
            m21,
            m22,
            m23,
            m24,
            m31,
            m32,
            m33,
            m34,
            m41,
            m42,
            m43,
            m44
          ]);
        }
        var CSSMatrix = function CSSMatrix2() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var m = this;
          m.a = 1;
          m.b = 0;
          m.c = 0;
          m.d = 1;
          m.e = 0;
          m.f = 0;
          m.m11 = 1;
          m.m12 = 0;
          m.m13 = 0;
          m.m14 = 0;
          m.m21 = 0;
          m.m22 = 1;
          m.m23 = 0;
          m.m24 = 0;
          m.m31 = 0;
          m.m32 = 0;
          m.m33 = 1;
          m.m34 = 0;
          m.m41 = 0;
          m.m42 = 0;
          m.m43 = 0;
          m.m44 = 1;
          if (args.length) {
            var ARGS = [16, 6].some(function(l) {
              return l === args.length;
            }) ? args : args[0];
            return m.setMatrixValue(ARGS);
          }
          return m;
        };
        var prototypeAccessors = { isIdentity: { configurable: true }, is2D: { configurable: true } };
        prototypeAccessors.isIdentity.get = function() {
          var m = this;
          return m.m11 === 1 && m.m12 === 0 && m.m13 === 0 && m.m14 === 0 && m.m21 === 0 && m.m22 === 1 && m.m23 === 0 && m.m24 === 0 && m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m41 === 0 && m.m42 === 0 && m.m43 === 0 && m.m44 === 1;
        };
        prototypeAccessors.is2D.get = function() {
          var m = this;
          return m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m43 === 0 && m.m44 === 1;
        };
        CSSMatrix.prototype.setMatrixValue = function setMatrixValue(source) {
          var m = this;
          if (typeof source === "string" && source.length && source !== "none") {
            return fromString(source);
          }
          if ([Array, Float64Array, Float32Array].some(function(a) {
            return source instanceof a;
          })) {
            return fromArray(source);
          }
          if ([CSSMatrix, DOMMatrix, Object].some(function(a) {
            return source instanceof a;
          })) {
            return fromMatrix(source);
          }
          return m;
        };
        CSSMatrix.prototype.toFloat32Array = function toFloat32Array(is2D) {
          return Float32Array.from(toArray(this, is2D));
        };
        CSSMatrix.prototype.toFloat64Array = function toFloat64Array(is2D) {
          return Float64Array.from(toArray(this, is2D));
        };
        CSSMatrix.prototype.toString = function toString() {
          var m = this;
          var is2D = m.is2D;
          var values = m.toFloat64Array(is2D).join(", ");
          var type = is2D ? "matrix" : "matrix3d";
          return type + "(" + values + ")";
        };
        CSSMatrix.prototype.toJSON = function toJSON() {
          var m = this;
          var is2D = m.is2D;
          var isIdentity = m.isIdentity;
          return Object.assign({}, m, { is2D, isIdentity });
        };
        CSSMatrix.prototype.multiply = function multiply(m2) {
          return Multiply(this, m2);
        };
        CSSMatrix.prototype.translate = function translate(x, y, z) {
          var X = x;
          var Y = y;
          var Z = z;
          if (Y === void 0) {
            Y = 0;
          }
          if (Z === void 0) {
            Z = 0;
          }
          return Multiply(this, Translate(X, Y, Z));
        };
        CSSMatrix.prototype.scale = function scale(x, y, z) {
          var X = x;
          var Y = y;
          var Z = z;
          if (Y === void 0) {
            Y = x;
          }
          if (Z === void 0) {
            Z = 1;
          }
          return Multiply(this, Scale(X, Y, Z));
        };
        CSSMatrix.prototype.rotate = function rotate(rx, ry, rz) {
          var RX = rx;
          var RY = ry || 0;
          var RZ = rz || 0;
          if (typeof rx === "number" && ry === void 0 && rz === void 0) {
            RZ = RX;
            RX = 0;
            RY = 0;
          }
          return Multiply(this, Rotate(RX, RY, RZ));
        };
        CSSMatrix.prototype.rotateAxisAngle = function rotateAxisAngle(x, y, z, angle) {
          if ([x, y, z, angle].some(function(n) {
            return Number.isNaN(+n);
          })) {
            throw new TypeError("CSSMatrix: expecting 4 values");
          }
          return Multiply(this, RotateAxisAngle(x, y, z, angle));
        };
        CSSMatrix.prototype.skewX = function skewX(angle) {
          return Multiply(this, SkewX(angle));
        };
        CSSMatrix.prototype.skewY = function skewY(angle) {
          return Multiply(this, SkewY(angle));
        };
        CSSMatrix.prototype.skew = function skew(angleX, angleY) {
          return Multiply(this, Skew(angleX, angleY));
        };
        CSSMatrix.prototype.transformPoint = function transformPoint(t) {
          var m = this;
          var x = m.m11 * t.x + m.m21 * t.y + m.m31 * t.z + m.m41 * t.w;
          var y = m.m12 * t.x + m.m22 * t.y + m.m32 * t.z + m.m42 * t.w;
          var z = m.m13 * t.x + m.m23 * t.y + m.m33 * t.z + m.m43 * t.w;
          var w = m.m14 * t.x + m.m24 * t.y + m.m34 * t.z + m.m44 * t.w;
          return t instanceof DOMPoint ? new DOMPoint(x, y, z, w) : {
            x,
            y,
            z,
            w
          };
        };
        Object.defineProperties(CSSMatrix.prototype, prototypeAccessors);
        Object.assign(CSSMatrix, {
          Translate,
          Rotate,
          RotateAxisAngle,
          Scale,
          SkewX,
          SkewY,
          Skew,
          Multiply,
          fromArray,
          fromMatrix,
          fromString,
          toArray
        });
        var version2 = "1.0.3";
        var Version = version2;
        Object.assign(CSSMatrix, { Version });
        return CSSMatrix;
      });
    }
  });

  // node_modules/web-streams-polyfill/dist/ponyfill.js
  var require_ponyfill = __commonJS({
    "node_modules/web-streams-polyfill/dist/ponyfill.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
      })(exports2, function(exports3) {
        "use strict";
        var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
          return "Symbol(" + description + ")";
        };
        function noop() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof global !== "undefined") {
            return global;
          }
          return void 0;
        }
        var globals = getGlobals();
        function typeIsObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        var rethrowAssertionErrorRejection = noop;
        var originalPromise = Promise;
        var originalPromiseThen = Promise.prototype.then;
        var originalPromiseResolve = Promise.resolve.bind(originalPromise);
        var originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        var queueMicrotask = function() {
          var globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          var resolvedPromise = promiseResolvedWith(void 0);
          return function(fn) {
            return PerformPromiseThen(resolvedPromise, fn);
          };
        }();
        function reflectCall(F, V, args) {
          if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F, V, args);
        }
        function promiseCall(F, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        var QUEUE_MAX_ARRAY_SIZE = 16384;
        var SimpleQueue = function() {
          function SimpleQueue2() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          Object.defineProperty(SimpleQueue2.prototype, "length", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          SimpleQueue2.prototype.push = function(element) {
            var oldBack = this._back;
            var newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          };
          SimpleQueue2.prototype.shift = function() {
            var oldFront = this._front;
            var newFront = oldFront;
            var oldCursor = this._cursor;
            var newCursor = oldCursor + 1;
            var elements = oldFront._elements;
            var element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          };
          SimpleQueue2.prototype.forEach = function(callback) {
            var i = this._cursor;
            var node = this._front;
            var elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          };
          SimpleQueue2.prototype.peek = function() {
            var front = this._front;
            var cursor = this._cursor;
            return front._elements[cursor];
          };
          return SimpleQueue2;
        }();
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          var stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise(function(resolve, reject) {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        var PullSteps = SymbolPolyfill("[[PullSteps]]");
        var NumberIsFinite = Number.isFinite || function(x) {
          return typeof x === "number" && isFinite(x);
        };
        var MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x) {
          return typeof x === "object" || typeof x === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(context + " is not an object.");
          }
        }
        function assertFunction(x, context) {
          if (typeof x !== "function") {
            throw new TypeError(context + " is not a function.");
          }
        }
        function isObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        function assertObject(x, context) {
          if (!isObject(x)) {
            throw new TypeError(context + " is not an object.");
          }
        }
        function assertRequiredArgument(x, position, context) {
          if (x === void 0) {
            throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
          }
        }
        function assertRequiredField(x, field, context) {
          if (x === void 0) {
            throw new TypeError(field + " is required in '" + context + "'.");
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x) {
          return x === 0 ? 0 : x;
        }
        function integerPart(x) {
          return censorNegativeZero(MathTrunc(x));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          var lowerBound = 0;
          var upperBound = Number.MAX_SAFE_INTEGER;
          var x = Number(value);
          x = censorNegativeZero(x);
          if (!NumberIsFinite(x)) {
            throw new TypeError(context + " is not a finite number");
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
          }
          if (!NumberIsFinite(x) || x === 0) {
            return 0;
          }
          return x;
        }
        function assertReadableStream(x, context) {
          if (!IsReadableStream(x)) {
            throw new TypeError(context + " is not a ReadableStream.");
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          var reader = stream._reader;
          var readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          var reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        var ReadableStreamDefaultReader = function() {
          function ReadableStreamDefaultReader2(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
            get: function() {
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          };
          ReadableStreamDefaultReader2.prototype.read = function() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            var readRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: false });
              },
              _closeSteps: function() {
                return resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          };
          ReadableStreamDefaultReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          };
          return ReadableStreamDefaultReader2;
        }();
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          var stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
        }
        var _a;
        var AsyncIteratorPrototype;
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function() {
            return this;
          }, _a);
          Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
        }
        var ReadableStreamAsyncIteratorImpl = function() {
          function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
            var _this = this;
            var nextSteps = function() {
              return _this._nextSteps();
            };
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          };
          ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
            var _this = this;
            var returnSteps = function() {
              return _this._returnSteps(value);
            };
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          };
          ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
            var _this = this;
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            var readRequest = {
              _chunkSteps: function(chunk) {
                _this._ongoingPromise = void 0;
                queueMicrotask(function() {
                  return resolvePromise({ value: chunk, done: false });
                });
              },
              _closeSteps: function() {
                _this._ongoingPromise = void 0;
                _this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: function(reason) {
                _this._ongoingPromise = void 0;
                _this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          };
          ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              var result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, function() {
                return { value, done: true };
              });
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          };
          return ReadableStreamAsyncIteratorImpl2;
        }();
        var ReadableStreamAsyncIteratorPrototype = {
          next: function() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return: function(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          var reader = AcquireReadableStreamDefaultReader(stream);
          var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a2) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
        }
        var NumberIsNaN = Number.isNaN || function(x) {
          return x !== x;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          var length = end - begin;
          var slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          var pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          var pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        var ReadableStreamBYOBRequest = function() {
          function ReadableStreamBYOBRequest2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
            get: function() {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("view");
              }
              return this._view;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          };
          ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          };
          return ReadableStreamBYOBRequest2;
        }();
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        var ReadableByteStreamController = function() {
          function ReadableByteStreamController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
            get: function() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("byobRequest");
              }
              return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
            get: function() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("desiredSize");
              }
              return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableByteStreamController2.prototype.close = function() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
            }
            ReadableByteStreamControllerClose(this);
          };
          ReadableByteStreamController2.prototype.enqueue = function(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError("chunk's buffer must have non-zero byteLength");
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          };
          ReadableByteStreamController2.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          };
          ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          };
          ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              var entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              var buffer = void 0;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              var pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          };
          return ReadableByteStreamController2;
        }();
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
            return false;
          }
          return x instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, function(e) {
            ReadableByteStreamControllerError(controller, e);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          var done = false;
          if (stream._state === "closed") {
            done = true;
          }
          var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          var bytesFilled = pullIntoDescriptor.bytesFilled;
          var elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          var elementSize = pullIntoDescriptor.elementSize;
          var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          var totalBytesToCopyRemaining = maxBytesToCopy;
          var ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          var queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            var headOfQueue = queue.peek();
            var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            var pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          var stream = controller._controlledReadableByteStream;
          var elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          var ctor = view.constructor;
          var buffer = TransferArrayBuffer(view.buffer);
          var pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              readIntoRequest._errorSteps(e);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          var stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          var state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          var descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          var stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          var stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              throw e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          var stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          var buffer = chunk.buffer;
          var byteOffset = chunk.byteOffset;
          var byteLength = chunk.byteLength;
          var transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e) {
          var stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            var firstDescriptor = controller._pendingPullIntos.peek();
            var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          var state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          var state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          var state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          var viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          var startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), function() {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, function(r) {
            ReadableByteStreamControllerError(controller, r);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          var controller = Object.create(ReadableByteStreamController.prototype);
          var startAlgorithm = function() {
            return void 0;
          };
          var pullAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          var cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = function() {
              return underlyingByteSource.start(controller);
            };
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = function() {
              return underlyingByteSource.pull(controller);
            };
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = function(reason) {
              return underlyingByteSource.cancel(reason);
            };
          }
          var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          var reader = stream._reader;
          var readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          var reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        var ReadableStreamBYOBReader = function() {
          function ReadableStreamBYOBReader2(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
            get: function() {
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          };
          ReadableStreamBYOBReader2.prototype.read = function(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            var readIntoRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: false });
              },
              _closeSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: true });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          };
          ReadableStreamBYOBReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          };
          return ReadableStreamBYOBReader2;
        }();
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          var stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          var highWaterMark = strategy.highWaterMark;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          var size = strategy.size;
          if (!size) {
            return function() {
              return 1;
            };
          }
          return size;
        }
        function convertQueuingStrategy(init, context) {
          assertDictionary(init, context);
          var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
          var size = init === null || init === void 0 ? void 0 : init.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return function(chunk) {
            return convertUnrestrictedDouble(fn(chunk));
          };
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          var abort = original === null || original === void 0 ? void 0 : original.abort;
          var close = original === null || original === void 0 ? void 0 : original.close;
          var start = original === null || original === void 0 ? void 0 : original.start;
          var type = original === null || original === void 0 ? void 0 : original.type;
          var write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(reason) {
            return promiseCall(fn, original, [reason]);
          };
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return function() {
            return promiseCall(fn, original, []);
          };
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return reflectCall(fn, original, [controller]);
          };
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(chunk, controller) {
            return promiseCall(fn, original, [chunk, controller]);
          };
        }
        function assertWritableStream(x, context) {
          if (!IsWritableStream(x)) {
            throw new TypeError(context + " is not a WritableStream.");
          }
        }
        function isAbortSignal(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a2) {
            return false;
          }
        }
        var supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        var WritableStream = function() {
          function WritableStream2(rawUnderlyingSink, rawStrategy) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = {};
            }
            if (rawStrategy === void 0) {
              rawStrategy = {};
            }
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            var type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            var highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          Object.defineProperty(WritableStream2.prototype, "locked", {
            get: function() {
              if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2("locked");
              }
              return IsWritableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
          });
          WritableStream2.prototype.abort = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          };
          WritableStream2.prototype.close = function() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          };
          WritableStream2.prototype.getWriter = function() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          };
          return WritableStream2;
        }();
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          if (highWaterMark === void 0) {
            highWaterMark = 1;
          }
          if (sizeAlgorithm === void 0) {
            sizeAlgorithm = function() {
              return 1;
            };
          }
          var stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          var controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
            return false;
          }
          return x instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a2;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
          var state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          var wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          var promise = newPromise(function(resolve, reject) {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          var state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
          }
          var promise = newPromise(function(resolve, reject) {
            var closeRequest = {
              _resolve: resolve,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          var writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          var promise = newPromise(function(resolve, reject) {
            var writeRequest = {
              _resolve: resolve,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error) {
          var state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          var controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          var writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          var storedError = stream._storedError;
          stream._writeRequests.forEach(function(writeRequest) {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          var abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, function() {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, function(reason) {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error) {
          stream._inFlightWriteRequest._reject(error);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          var state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          var writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error) {
          stream._inFlightCloseRequest._reject(error);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          var writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          var writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        var WritableStreamDefaultWriter = function() {
          function WritableStreamDefaultWriter2(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            var state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              var storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException("desiredSize");
              }
              if (this._ownerWritableStream === void 0) {
                throw defaultWriterLockException("desiredSize");
              }
              return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
              }
              return this._readyPromise;
            },
            enumerable: false,
            configurable: true
          });
          WritableStreamDefaultWriter2.prototype.abort = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          };
          WritableStreamDefaultWriter2.prototype.close = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            var stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          };
          WritableStreamDefaultWriter2.prototype.releaseLock = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            var stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          };
          WritableStreamDefaultWriter2.prototype.write = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          };
          return WritableStreamDefaultWriter2;
        }();
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          var stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          var stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          var stream = writer._ownerWritableStream;
          var state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          var stream = writer._ownerWritableStream;
          var state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          var stream = writer._ownerWritableStream;
          var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          var stream = writer._ownerWritableStream;
          var controller = stream._writableStreamController;
          var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          var state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          var promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        var closeSentinel = {};
        var WritableStreamDefaultController = function() {
          function WritableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(WritableStreamDefaultController2.prototype, "abortReason", {
            get: function() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("abortReason");
              }
              return this._abortReason;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultController2.prototype, "signal", {
            get: function() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("signal");
              }
              if (this._abortController === void 0) {
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              }
              return this._abortController.signal;
            },
            enumerable: false,
            configurable: true
          });
          WritableStreamDefaultController2.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            var state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          };
          WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
            var result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          };
          WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
            ResetQueue(this);
          };
          return WritableStreamDefaultController2;
        }();
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          var startResult = startAlgorithm();
          var startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, function() {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, function(r) {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          var controller = Object.create(WritableStreamDefaultController.prototype);
          var startAlgorithm = function() {
            return void 0;
          };
          var writeAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          var closeAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          var abortAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          if (underlyingSink.start !== void 0) {
            startAlgorithm = function() {
              return underlyingSink.start(controller);
            };
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = function(chunk) {
              return underlyingSink.write(chunk, controller);
            };
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = function() {
              return underlyingSink.close();
            };
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = function(reason) {
              return underlyingSink.abort(reason);
            };
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          var stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          var stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          var state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          var value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          var stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          var sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, function() {
            WritableStreamFinishInFlightClose(stream);
          }, function(reason) {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          var stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          var sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, function() {
            WritableStreamFinishInFlightWrite(stream);
            var state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, function(reason) {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error) {
          var stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise(function(resolve, reject) {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise(function(resolve, reject) {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        var NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a2) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          var ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          var reader = AcquireReadableStreamDefaultReader(source);
          var writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          var shuttingDown = false;
          var currentWrite = promiseResolvedWith(void 0);
          return newPromise(function(resolve, reject) {
            var abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = function() {
                var error = new DOMException$1("Aborted", "AbortError");
                var actions = [];
                if (!preventAbort) {
                  actions.push(function() {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(function() {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(function() {
                  return Promise.all(actions.map(function(action) {
                    return action();
                  }));
                }, true, error);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise(function(resolveLoop, rejectLoop) {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, function() {
                return newPromise(function(resolveRead, rejectRead) {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: function(chunk) {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                      resolveRead(false);
                    },
                    _closeSteps: function() {
                      return resolveRead(true);
                    },
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
              if (!preventAbort) {
                shutdownWithAction(function() {
                  return WritableStreamAbort(dest, storedError);
                }, true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
              if (!preventCancel) {
                shutdownWithAction(function() {
                  return ReadableStreamCancel(source, storedError);
                }, true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, function() {
              if (!preventClose) {
                shutdownWithAction(function() {
                  return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
                });
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(function() {
                  return ReadableStreamCancel(source, destClosed_1);
                }, true, destClosed_1);
              } else {
                shutdown(true, destClosed_1);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              var oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, function() {
                return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
              });
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), function() {
                  return finalize(originalIsError, originalError);
                }, function(newError) {
                  return finalize(true, newError);
                });
              }
            }
            function shutdown(isError, error) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), function() {
                  return finalize(isError, error);
                });
              } else {
                finalize(isError, error);
              }
            }
            function finalize(isError, error) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error);
              } else {
                resolve(void 0);
              }
            }
          });
        }
        var ReadableStreamDefaultController = function() {
          function ReadableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
            get: function() {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("desiredSize");
              }
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamDefaultController2.prototype.close = function() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          };
          ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          };
          ReadableStreamDefaultController2.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          };
          ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          };
          ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              var chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          };
          return ReadableStreamDefaultController2;
        }();
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, function(e) {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          var stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          var stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          var stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            var chunkSize = void 0;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e) {
          var stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          var state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          var state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          var startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), function() {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, function(r) {
            ReadableStreamDefaultControllerError(controller, r);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          var controller = Object.create(ReadableStreamDefaultController.prototype);
          var startAlgorithm = function() {
            return void 0;
          };
          var pullAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          var cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          if (underlyingSource.start !== void 0) {
            startAlgorithm = function() {
              return underlyingSource.start(controller);
            };
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = function() {
              return underlyingSource.pull(controller);
            };
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = function(reason) {
              return underlyingSource.cancel(reason);
            };
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          var reader = AcquireReadableStreamDefaultReader(stream);
          var reading = false;
          var readAgain = false;
          var canceled1 = false;
          var canceled2 = false;
          var reason1;
          var reason2;
          var branch1;
          var branch2;
          var resolveCancelPromise;
          var cancelPromise = newPromise(function(resolve) {
            resolveCancelPromise = resolve;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            var readRequest = {
              _chunkSteps: function(chunk) {
                queueMicrotask(function() {
                  readAgain = false;
                  var chunk1 = chunk;
                  var chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: function() {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: function() {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, function(r) {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          var reader = AcquireReadableStreamDefaultReader(stream);
          var reading = false;
          var readAgainForBranch1 = false;
          var readAgainForBranch2 = false;
          var canceled1 = false;
          var canceled2 = false;
          var reason1;
          var reason2;
          var branch1;
          var branch2;
          var resolveCancelPromise;
          var cancelPromise = newPromise(function(resolve) {
            resolveCancelPromise = resolve;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, function(r) {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r);
              ReadableByteStreamControllerError(branch2._readableStreamController, r);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            var readRequest = {
              _chunkSteps: function(chunk) {
                queueMicrotask(function() {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  var chunk1 = chunk;
                  var chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: function() {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: function() {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            var byobBranch = forBranch2 ? branch2 : branch1;
            var otherBranch = forBranch2 ? branch1 : branch2;
            var readIntoRequest = {
              _chunkSteps: function(chunk) {
                queueMicrotask(function() {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  var byobCanceled = forBranch2 ? canceled2 : canceled1;
                  var otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    var clonedChunk = void 0;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: function(chunk) {
                reading = false;
                var byobCanceled = forBranch2 ? canceled2 : canceled1;
                var otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: function() {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          var original = source;
          var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          var cancel = original === null || original === void 0 ? void 0 : original.cancel;
          var pull = original === null || original === void 0 ? void 0 : original.pull;
          var start = original === null || original === void 0 ? void 0 : original.start;
          var type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(reason) {
            return promiseCall(fn, original, [reason]);
          };
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return promiseCall(fn, original, [controller]);
          };
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return reflectCall(fn, original, [controller]);
          };
        }
        function convertReadableStreamType(type, context) {
          type = "" + type;
          if (type !== "bytes") {
            throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
          }
          return type;
        }
        function convertReaderOptions(options, context) {
          assertDictionary(options, context);
          var mode = options === null || options === void 0 ? void 0 : options.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = "" + mode;
          if (mode !== "byob") {
            throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
          }
          return mode;
        }
        function convertIteratorOptions(options, context) {
          assertDictionary(options, context);
          var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options, context) {
          assertDictionary(options, context);
          var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
          var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
          var signal = options === null || options === void 0 ? void 0 : options.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, context + " has member 'signal' that");
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal(signal)) {
            throw new TypeError(context + " is not an AbortSignal.");
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, context + " has member 'readable' that");
          var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable, "writable", "ReadableWritablePair");
          assertWritableStream(writable, context + " has member 'writable' that");
          return { readable, writable };
        }
        var ReadableStream2 = function() {
          function ReadableStream3(rawUnderlyingSource, rawStrategy) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = {};
            }
            if (rawStrategy === void 0) {
              rawStrategy = {};
            }
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              var highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              var highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          Object.defineProperty(ReadableStream3.prototype, "locked", {
            get: function() {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("locked");
              }
              return IsReadableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableStream3.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          };
          ReadableStream3.prototype.getReader = function(rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = void 0;
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            var options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          };
          ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            var transform = convertReadableWritablePair(rawTransform, "First parameter");
            var options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          };
          ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            }
            var options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          };
          ReadableStream3.prototype.tee = function() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          };
          ReadableStream3.prototype.values = function(rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = void 0;
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            var options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          };
          return ReadableStream3;
        }();
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          if (highWaterMark === void 0) {
            highWaterMark = 1;
          }
          if (sizeAlgorithm === void 0) {
            sizeAlgorithm = function() {
              return 1;
            };
          }
          var stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          var controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          var stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          var controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
            return false;
          }
          return x instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          var reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach(function(readIntoRequest) {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          var reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function(readRequest) {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e) {
          stream._state = "errored";
          stream._storedError = e;
          var reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function(readRequest) {
              readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach(function(readIntoRequest) {
              readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
        }
        function convertQueuingStrategyInit(init, context) {
          assertDictionary(init, context);
          var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        var byteLengthSizeFunction = function(chunk) {
          return chunk.byteLength;
        };
        try {
          Object.defineProperty(byteLengthSizeFunction, "name", {
            value: "size",
            configurable: true
          });
        } catch (_a2) {
        }
        var ByteLengthQueuingStrategy = function() {
          function ByteLengthQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
            get: function() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("highWaterMark");
              }
              return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
            get: function() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("size");
              }
              return byteLengthSizeFunction;
            },
            enumerable: false,
            configurable: true
          });
          return ByteLengthQueuingStrategy2;
        }();
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
        }
        function IsByteLengthQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof ByteLengthQueuingStrategy;
        }
        var countSizeFunction = function() {
          return 1;
        };
        try {
          Object.defineProperty(countSizeFunction, "name", {
            value: "size",
            configurable: true
          });
        } catch (_a2) {
        }
        var CountQueuingStrategy = function() {
          function CountQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
            get: function() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("highWaterMark");
              }
              return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
            get: function() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("size");
              }
              return countSizeFunction;
            },
            enumerable: false,
            configurable: true
          });
          return CountQueuingStrategy2;
        }();
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
        }
        function IsCountQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          var flush = original === null || original === void 0 ? void 0 : original.flush;
          var readableType = original === null || original === void 0 ? void 0 : original.readableType;
          var start = original === null || original === void 0 ? void 0 : original.start;
          var transform = original === null || original === void 0 ? void 0 : original.transform;
          var writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return promiseCall(fn, original, [controller]);
          };
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return reflectCall(fn, original, [controller]);
          };
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(chunk, controller) {
            return promiseCall(fn, original, [chunk, controller]);
          };
        }
        var TransformStream = function() {
          function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            if (rawTransformer === void 0) {
              rawTransformer = {};
            }
            if (rawWritableStrategy === void 0) {
              rawWritableStrategy = {};
            }
            if (rawReadableStrategy === void 0) {
              rawReadableStrategy = {};
            }
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            var transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            var startPromise_resolve;
            var startPromise = newPromise(function(resolve) {
              startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          Object.defineProperty(TransformStream2.prototype, "readable", {
            get: function() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("readable");
              }
              return this._readable;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(TransformStream2.prototype, "writable", {
            get: function() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("writable");
              }
              return this._writable;
            },
            enumerable: false,
            configurable: true
          });
          return TransformStream2;
        }();
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
            return false;
          }
          return x instanceof TransformStream;
        }
        function TransformStreamError(stream, e) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise(function(resolve) {
            stream._backpressureChangePromise_resolve = resolve;
          });
          stream._backpressure = backpressure;
        }
        var TransformStreamDefaultController = function() {
          function TransformStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
            get: function() {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("desiredSize");
              }
              var readableController = this._controlledTransformStream._readable._readableStreamController;
              return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: false,
            configurable: true
          });
          TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          };
          TransformStreamDefaultController2.prototype.error = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          };
          TransformStreamDefaultController2.prototype.terminate = function() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          };
          return TransformStreamDefaultController2;
        }();
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
            return false;
          }
          return x instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          var controller = Object.create(TransformStreamDefaultController.prototype);
          var transformAlgorithm = function(chunk) {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          var flushAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
          if (transformer.transform !== void 0) {
            transformAlgorithm = function(chunk) {
              return transformer.transform(chunk, controller);
            };
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = function() {
              return transformer.flush(controller);
            };
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          var stream = controller._controlledTransformStream;
          var readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
          }
          var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e) {
          TransformStreamError(controller._controlledTransformStream, e);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          var transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, function(r) {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          var stream = controller._controlledTransformStream;
          var readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          var error = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          var controller = stream._transformStreamController;
          if (stream._backpressure) {
            var backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, function() {
              var writable = stream._writable;
              var state = writable._state;
              if (state === "erroring") {
                throw writable._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          var readable = stream._readable;
          var controller = stream._transformStreamController;
          var flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, function() {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, function(r) {
            TransformStreamError(stream, r);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
        }
        function streamBrandCheckException(name) {
          return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
        }
        exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports3.CountQueuingStrategy = CountQueuingStrategy;
        exports3.ReadableByteStreamController = ReadableByteStreamController;
        exports3.ReadableStream = ReadableStream2;
        exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports3.TransformStream = TransformStream;
        exports3.TransformStreamDefaultController = TransformStreamDefaultController;
        exports3.WritableStream = WritableStream;
        exports3.WritableStreamDefaultController = WritableStreamDefaultController;
        exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // (disabled):canvas
  var require_canvas = __commonJS({
    "(disabled):canvas"() {
    }
  });

  // (disabled):zlib
  var require_zlib = __commonJS({
    "(disabled):zlib"() {
    }
  });

  // (disabled):http
  var require_http = __commonJS({
    "(disabled):http"() {
    }
  });

  // (disabled):https
  var require_https = __commonJS({
    "(disabled):https"() {
    }
  });

  // (disabled):url
  var require_url = __commonJS({
    "(disabled):url"() {
    }
  });

  // node_modules/pdfjs-dist/legacy/build/pdf.js
  var require_pdf = __commonJS({
    "node_modules/pdfjs-dist/legacy/build/pdf.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define("pdfjs-dist/build/pdf", [], factory);
        else if (typeof exports === "object")
          exports["pdfjs-dist/build/pdf"] = factory();
        else
          root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
      })(exports, () => {
        return (() => {
          var __webpack_modules__ = [
            ,
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.UNSUPPORTED_FEATURES = exports2.TextRenderingMode = exports2.StreamType = exports2.RenderingIntentFlag = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.arrayByteLength = arrayByteLength;
              exports2.arraysToBytes = arraysToBytes;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createPromiseCapability = createPromiseCapability;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.escapeString = escapeString;
              exports2.getModificationDate = getModificationDate;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer;
              exports2.isArrayEqual = isArrayEqual;
              exports2.isAscii = isAscii;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF16BEString = stringToUTF16BEString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              __w_pdfjs_require__2(2);
              function _toConsumableArray2(arr) {
                return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
              }
              function _nonIterableSpread2() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArray2(iter) {
                if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                  return Array.from(iter);
              }
              function _arrayWithoutHoles2(arr) {
                if (Array.isArray(arr))
                  return _arrayLikeToArray2(arr);
              }
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e2) {
                      throw _e2;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e3) {
                  didErr = true;
                  err = _e3;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              var RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              var AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              var PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              var TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              var ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              var AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              var AnnotationStateModelType = {
                MARKED: "Marked",
                REVIEW: "Review"
              };
              exports2.AnnotationStateModelType = AnnotationStateModelType;
              var AnnotationMarkedState = {
                MARKED: "Marked",
                UNMARKED: "Unmarked"
              };
              exports2.AnnotationMarkedState = AnnotationMarkedState;
              var AnnotationReviewState = {
                ACCEPTED: "Accepted",
                REJECTED: "Rejected",
                CANCELLED: "Cancelled",
                COMPLETED: "Completed",
                NONE: "None"
              };
              exports2.AnnotationReviewState = AnnotationReviewState;
              var AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              var AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              var AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              var AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              var AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              var DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              var PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              var StreamType = {
                UNKNOWN: "UNKNOWN",
                FLATE: "FLATE",
                LZW: "LZW",
                DCT: "DCT",
                JPX: "JPX",
                JBIG: "JBIG",
                A85: "A85",
                AHX: "AHX",
                CCF: "CCF",
                RLX: "RLX"
              };
              exports2.StreamType = StreamType;
              var FontType = {
                UNKNOWN: "UNKNOWN",
                TYPE1: "TYPE1",
                TYPE1STANDARD: "TYPE1STANDARD",
                TYPE1C: "TYPE1C",
                CIDFONTTYPE0: "CIDFONTTYPE0",
                CIDFONTTYPE0C: "CIDFONTTYPE0C",
                TRUETYPE: "TRUETYPE",
                CIDFONTTYPE2: "CIDFONTTYPE2",
                TYPE3: "TYPE3",
                OPENTYPE: "OPENTYPE",
                TYPE0: "TYPE0",
                MMTYPE1: "MMTYPE1"
              };
              exports2.FontType = FontType;
              var VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              var CMapCompressionType = {
                NONE: 0,
                BINARY: 1,
                STREAM: 2
              };
              exports2.CMapCompressionType = CMapCompressionType;
              var OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              var UNSUPPORTED_FEATURES = {
                unknown: "unknown",
                forms: "forms",
                javaScript: "javaScript",
                signatures: "signatures",
                smask: "smask",
                shadingPattern: "shadingPattern",
                font: "font",
                errorTilingPattern: "errorTilingPattern",
                errorExtGState: "errorExtGState",
                errorXObject: "errorXObject",
                errorFontLoadType3: "errorFontLoadType3",
                errorFontState: "errorFontState",
                errorFontMissing: "errorFontMissing",
                errorFontTranslate: "errorFontTranslate",
                errorColorSpace: "errorColorSpace",
                errorOperatorList: "errorOperatorList",
                errorFontToUnicode: "errorFontToUnicode",
                errorFontLoadNative: "errorFontLoadNative",
                errorFontBuildPath: "errorFontBuildPath",
                errorFontGetPath: "errorFontGetPath",
                errorMarkedContent: "errorMarkedContent",
                errorContentSubStream: "errorContentSubStream"
              };
              exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
              var PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              var verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel() {
                return verbosity;
              }
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log("Info: ".concat(msg));
                }
              }
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log("Warning: ".concat(msg));
                }
              }
              function unreachable(msg) {
                throw new Error(msg);
              }
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              function _isValidProtocol(url) {
                if (!url) {
                  return false;
                }
                switch (url.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl(url) {
                var baseUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (!url) {
                  return null;
                }
                try {
                  if (options && typeof url === "string") {
                    if (options.addDefaultProtocol && url.startsWith("www.")) {
                      var dots = url.match(/\./g);
                      if (dots && dots.length >= 2) {
                        url = "http://".concat(url);
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url = stringToUTF8String(url);
                      } catch (ex) {
                      }
                    }
                  }
                  var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch (ex) {
                }
                return null;
              }
              function shadow(obj, prop, value) {
                Object.defineProperty(obj, prop, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: false
                });
                return value;
              }
              var BaseException = function BaseExceptionClosure() {
                function BaseException2(message, name) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message;
                  this.name = name;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              var PasswordException = /* @__PURE__ */ function(_BaseException) {
                _inherits(PasswordException2, _BaseException);
                var _super = _createSuper(PasswordException2);
                function PasswordException2(msg, code) {
                  var _this;
                  _classCallCheck2(this, PasswordException2);
                  _this = _super.call(this, msg, "PasswordException");
                  _this.code = code;
                  return _this;
                }
                return _createClass2(PasswordException2);
              }(BaseException);
              exports2.PasswordException = PasswordException;
              var UnknownErrorException = /* @__PURE__ */ function(_BaseException2) {
                _inherits(UnknownErrorException2, _BaseException2);
                var _super2 = _createSuper(UnknownErrorException2);
                function UnknownErrorException2(msg, details) {
                  var _this2;
                  _classCallCheck2(this, UnknownErrorException2);
                  _this2 = _super2.call(this, msg, "UnknownErrorException");
                  _this2.details = details;
                  return _this2;
                }
                return _createClass2(UnknownErrorException2);
              }(BaseException);
              exports2.UnknownErrorException = UnknownErrorException;
              var InvalidPDFException = /* @__PURE__ */ function(_BaseException3) {
                _inherits(InvalidPDFException2, _BaseException3);
                var _super3 = _createSuper(InvalidPDFException2);
                function InvalidPDFException2(msg) {
                  _classCallCheck2(this, InvalidPDFException2);
                  return _super3.call(this, msg, "InvalidPDFException");
                }
                return _createClass2(InvalidPDFException2);
              }(BaseException);
              exports2.InvalidPDFException = InvalidPDFException;
              var MissingPDFException = /* @__PURE__ */ function(_BaseException4) {
                _inherits(MissingPDFException2, _BaseException4);
                var _super4 = _createSuper(MissingPDFException2);
                function MissingPDFException2(msg) {
                  _classCallCheck2(this, MissingPDFException2);
                  return _super4.call(this, msg, "MissingPDFException");
                }
                return _createClass2(MissingPDFException2);
              }(BaseException);
              exports2.MissingPDFException = MissingPDFException;
              var UnexpectedResponseException = /* @__PURE__ */ function(_BaseException5) {
                _inherits(UnexpectedResponseException2, _BaseException5);
                var _super5 = _createSuper(UnexpectedResponseException2);
                function UnexpectedResponseException2(msg, status) {
                  var _this3;
                  _classCallCheck2(this, UnexpectedResponseException2);
                  _this3 = _super5.call(this, msg, "UnexpectedResponseException");
                  _this3.status = status;
                  return _this3;
                }
                return _createClass2(UnexpectedResponseException2);
              }(BaseException);
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              var FormatError = /* @__PURE__ */ function(_BaseException6) {
                _inherits(FormatError2, _BaseException6);
                var _super6 = _createSuper(FormatError2);
                function FormatError2(msg) {
                  _classCallCheck2(this, FormatError2);
                  return _super6.call(this, msg, "FormatError");
                }
                return _createClass2(FormatError2);
              }(BaseException);
              exports2.FormatError = FormatError;
              var AbortException = /* @__PURE__ */ function(_BaseException7) {
                _inherits(AbortException2, _BaseException7);
                var _super7 = _createSuper(AbortException2);
                function AbortException2(msg) {
                  _classCallCheck2(this, AbortException2);
                  return _super7.call(this, msg, "AbortException");
                }
                return _createClass2(AbortException2);
              }(BaseException);
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (_typeof2(bytes) !== "object" || bytes === null || bytes.length === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                var length = bytes.length;
                var MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                var strBuf = [];
                for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                  var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                  var chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes(str) {
                if (typeof str !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                var length = str.length;
                var bytes = new Uint8Array(length);
                for (var i = 0; i < length; ++i) {
                  bytes[i] = str.charCodeAt(i) & 255;
                }
                return bytes;
              }
              function arrayByteLength(arr) {
                if (arr.length !== void 0) {
                  return arr.length;
                }
                if (arr.byteLength !== void 0) {
                  return arr.byteLength;
                }
                unreachable("Invalid argument for arrayByteLength");
              }
              function arraysToBytes(arr) {
                var length = arr.length;
                if (length === 1 && arr[0] instanceof Uint8Array) {
                  return arr[0];
                }
                var resultLength = 0;
                for (var i = 0; i < length; i++) {
                  resultLength += arrayByteLength(arr[i]);
                }
                var pos = 0;
                var data = new Uint8Array(resultLength);
                for (var _i = 0; _i < length; _i++) {
                  var item = arr[_i];
                  if (!(item instanceof Uint8Array)) {
                    if (typeof item === "string") {
                      item = stringToBytes(item);
                    } else {
                      item = new Uint8Array(item);
                    }
                  }
                  var itemLength = item.byteLength;
                  data.set(item, pos);
                  pos += itemLength;
                }
                return data;
              }
              function string32(value) {
                return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
              }
              function objectSize(obj) {
                return Object.keys(obj).length;
              }
              function objectFromMap(map) {
                var obj = /* @__PURE__ */ Object.create(null);
                var _iterator = _createForOfIteratorHelper2(map), _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var _step$value = _slicedToArray2(_step.value, 2), key = _step$value[0], value = _step$value[1];
                    obj[key] = value;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                return obj;
              }
              function isLittleEndian() {
                var buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                var view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch (e) {
                  return false;
                }
              }
              var FeatureTest = /* @__PURE__ */ function() {
                function FeatureTest2() {
                  _classCallCheck2(this, FeatureTest2);
                }
                _createClass2(FeatureTest2, null, [{
                  key: "isLittleEndian",
                  get: function get2() {
                    return shadow(this, "isLittleEndian", isLittleEndian());
                  }
                }, {
                  key: "isEvalSupported",
                  get: function get2() {
                    return shadow(this, "isEvalSupported", isEvalSupported());
                  }
                }, {
                  key: "isOffscreenCanvasSupported",
                  get: function get2() {
                    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                  }
                }]);
                return FeatureTest2;
              }();
              exports2.FeatureTest = FeatureTest;
              var hexNumbers = _toConsumableArray2(Array(256).keys()).map(function(n) {
                return n.toString(16).padStart(2, "0");
              });
              var Util = /* @__PURE__ */ function() {
                function Util2() {
                  _classCallCheck2(this, Util2);
                }
                _createClass2(Util2, null, [{
                  key: "makeHexColor",
                  value: function makeHexColor(r, g, b) {
                    return "#".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);
                  }
                }, {
                  key: "scaleMinMax",
                  value: function scaleMinMax(transform, minMax) {
                    var temp;
                    if (transform[0]) {
                      if (transform[0] < 0) {
                        temp = minMax[0];
                        minMax[0] = minMax[1];
                        minMax[1] = temp;
                      }
                      minMax[0] *= transform[0];
                      minMax[1] *= transform[0];
                      if (transform[3] < 0) {
                        temp = minMax[2];
                        minMax[2] = minMax[3];
                        minMax[3] = temp;
                      }
                      minMax[2] *= transform[3];
                      minMax[3] *= transform[3];
                    } else {
                      temp = minMax[0];
                      minMax[0] = minMax[2];
                      minMax[2] = temp;
                      temp = minMax[1];
                      minMax[1] = minMax[3];
                      minMax[3] = temp;
                      if (transform[1] < 0) {
                        temp = minMax[2];
                        minMax[2] = minMax[3];
                        minMax[3] = temp;
                      }
                      minMax[2] *= transform[1];
                      minMax[3] *= transform[1];
                      if (transform[2] < 0) {
                        temp = minMax[0];
                        minMax[0] = minMax[1];
                        minMax[1] = temp;
                      }
                      minMax[0] *= transform[2];
                      minMax[1] *= transform[2];
                    }
                    minMax[0] += transform[4];
                    minMax[1] += transform[4];
                    minMax[2] += transform[5];
                    minMax[3] += transform[5];
                  }
                }, {
                  key: "transform",
                  value: function transform(m1, m2) {
                    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                  }
                }, {
                  key: "applyTransform",
                  value: function applyTransform(p, m) {
                    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                    return [xt, yt];
                  }
                }, {
                  key: "applyInverseTransform",
                  value: function applyInverseTransform(p, m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                    return [xt, yt];
                  }
                }, {
                  key: "getAxialAlignedBoundingBox",
                  value: function getAxialAlignedBoundingBox(r, m) {
                    var p1 = Util2.applyTransform(r, m);
                    var p2 = Util2.applyTransform(r.slice(2, 4), m);
                    var p3 = Util2.applyTransform([r[0], r[3]], m);
                    var p4 = Util2.applyTransform([r[2], r[1]], m);
                    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                  }
                }, {
                  key: "inverseTransform",
                  value: function inverseTransform(m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                  }
                }, {
                  key: "apply3dTransform",
                  value: function apply3dTransform(m, v) {
                    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                  }
                }, {
                  key: "singularValueDecompose2dScale",
                  value: function singularValueDecompose2dScale(m) {
                    var transpose = [m[0], m[2], m[1], m[3]];
                    var a = m[0] * transpose[0] + m[1] * transpose[2];
                    var b = m[0] * transpose[1] + m[1] * transpose[3];
                    var c = m[2] * transpose[0] + m[3] * transpose[2];
                    var d = m[2] * transpose[1] + m[3] * transpose[3];
                    var first = (a + d) / 2;
                    var second = Math.sqrt(Math.pow(a + d, 2) - 4 * (a * d - c * b)) / 2;
                    var sx = first + second || 1;
                    var sy = first - second || 1;
                    return [Math.sqrt(sx), Math.sqrt(sy)];
                  }
                }, {
                  key: "normalizeRect",
                  value: function normalizeRect(rect) {
                    var r = rect.slice(0);
                    if (rect[0] > rect[2]) {
                      r[0] = rect[2];
                      r[2] = rect[0];
                    }
                    if (rect[1] > rect[3]) {
                      r[1] = rect[3];
                      r[3] = rect[1];
                    }
                    return r;
                  }
                }, {
                  key: "intersect",
                  value: function intersect(rect1, rect2) {
                    var xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                    var xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                    if (xLow > xHigh) {
                      return null;
                    }
                    var yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                    var yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                    if (yLow > yHigh) {
                      return null;
                    }
                    return [xLow, yLow, xHigh, yHigh];
                  }
                }, {
                  key: "bezierBoundingBox",
                  value: function bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                    var tvalues = [], bounds = [[], []];
                    var a, b, c, t, t1, t2, b2ac, sqrtb2ac;
                    for (var i = 0; i < 2; ++i) {
                      if (i === 0) {
                        b = 6 * x0 - 12 * x1 + 6 * x2;
                        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                        c = 3 * x1 - 3 * x0;
                      } else {
                        b = 6 * y0 - 12 * y1 + 6 * y2;
                        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                        c = 3 * y1 - 3 * y0;
                      }
                      if (Math.abs(a) < 1e-12) {
                        if (Math.abs(b) < 1e-12) {
                          continue;
                        }
                        t = -c / b;
                        if (0 < t && t < 1) {
                          tvalues.push(t);
                        }
                        continue;
                      }
                      b2ac = b * b - 4 * c * a;
                      sqrtb2ac = Math.sqrt(b2ac);
                      if (b2ac < 0) {
                        continue;
                      }
                      t1 = (-b + sqrtb2ac) / (2 * a);
                      if (0 < t1 && t1 < 1) {
                        tvalues.push(t1);
                      }
                      t2 = (-b - sqrtb2ac) / (2 * a);
                      if (0 < t2 && t2 < 1) {
                        tvalues.push(t2);
                      }
                    }
                    var j = tvalues.length, mt;
                    var jlen = j;
                    while (j--) {
                      t = tvalues[j];
                      mt = 1 - t;
                      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                    }
                    bounds[0][jlen] = x0;
                    bounds[1][jlen] = y0;
                    bounds[0][jlen + 1] = x3;
                    bounds[1][jlen + 1] = y3;
                    bounds[0].length = bounds[1].length = jlen + 2;
                    return [Math.min.apply(Math, _toConsumableArray2(bounds[0])), Math.min.apply(Math, _toConsumableArray2(bounds[1])), Math.max.apply(Math, _toConsumableArray2(bounds[0])), Math.max.apply(Math, _toConsumableArray2(bounds[1]))];
                  }
                }]);
                return Util2;
              }();
              exports2.Util = Util;
              var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str) {
                if (str[0] >= "\xEF") {
                  var encoding;
                  if (str[0] === "\xFE" && str[1] === "\xFF") {
                    encoding = "utf-16be";
                  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
                    encoding = "utf-16le";
                  } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      var decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      var buffer = stringToBytes(str);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn('stringToPDFString: "'.concat(ex, '".'));
                    }
                  }
                }
                var strBuf = [];
                for (var i = 0, ii = str.length; i < ii; i++) {
                  var code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
                return strBuf.join("");
              }
              function escapeString(str) {
                return str.replace(/([()\\\n\r])/g, function(match) {
                  if (match === "\n") {
                    return "\\n";
                  } else if (match === "\r") {
                    return "\\r";
                  }
                  return "\\".concat(match);
                });
              }
              function isAscii(str) {
                return /^[\x00-\x7F]*$/.test(str);
              }
              function stringToUTF16BEString(str) {
                var buf = ["\xFE\xFF"];
                for (var i = 0, ii = str.length; i < ii; i++) {
                  var _char = str.charCodeAt(i);
                  buf.push(String.fromCharCode(_char >> 8 & 255), String.fromCharCode(_char & 255));
                }
                return buf.join("");
              }
              function stringToUTF8String(str) {
                return decodeURIComponent(escape(str));
              }
              function utf8StringToString(str) {
                return unescape(encodeURIComponent(str));
              }
              function isArrayBuffer(v) {
                return _typeof2(v) === "object" && v !== null && v.byteLength !== void 0;
              }
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (var i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate() {
                var date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Date();
                var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              function createPromiseCapability() {
                var capability = /* @__PURE__ */ Object.create(null);
                var isSettled = false;
                Object.defineProperty(capability, "settled", {
                  get: function get2() {
                    return isSettled;
                  }
                });
                capability.promise = new Promise(function(resolve, reject) {
                  capability.resolve = function(data) {
                    isSettled = true;
                    resolve(data);
                  };
                  capability.reject = function(reason) {
                    isSettled = true;
                    reject(reason);
                  };
                });
                return capability;
              }
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var _is_node2 = __w_pdfjs_require__2(3);
              if (!globalThis._pdfjsCompatibilityChecked) {
                globalThis._pdfjsCompatibilityChecked = true;
                (function checkNodeBtoa() {
                  if (globalThis.btoa || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.btoa = function(chars) {
                    return Buffer.from(chars, "binary").toString("base64");
                  };
                })();
                (function checkNodeAtob() {
                  if (globalThis.atob || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.atob = function(input) {
                    return Buffer.from(input, "base64").toString("binary");
                  };
                })();
                (function checkDOMMatrix() {
                  if (globalThis.DOMMatrix || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.DOMMatrix = require_dommatrix();
                })();
                (function checkPromise() {
                  if (globalThis.Promise.allSettled) {
                    return;
                  }
                  globalThis.Promise = __w_pdfjs_require__2(4);
                })();
                (function checkReadableStream() {
                  if (globalThis.ReadableStream || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.ReadableStream = require_ponyfill().ReadableStream;
                })();
                (function checkStructuredClone() {
                  if (globalThis.structuredClone) {
                    return;
                  }
                  __w_pdfjs_require__2(137);
                })();
              }
            },
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.isNodeJS = void 0;
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof2(process)) === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(5);
              __w_pdfjs_require__2(91);
              __w_pdfjs_require__2(97);
              __w_pdfjs_require__2(99);
              __w_pdfjs_require__2(131);
              __w_pdfjs_require__2(132);
              __w_pdfjs_require__2(133);
              __w_pdfjs_require__2(134);
              var path = __w_pdfjs_require__2(136);
              module2.exports = path.Promise;
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(6);
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var global2 = __w_pdfjs_require__2(8);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var getPrototypeOf = __w_pdfjs_require__2(69);
              var setPrototypeOf = __w_pdfjs_require__2(71);
              var copyConstructorProperties = __w_pdfjs_require__2(57);
              var create = __w_pdfjs_require__2(73);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              var clearErrorStack = __w_pdfjs_require__2(77);
              var installErrorCause = __w_pdfjs_require__2(78);
              var iterate = __w_pdfjs_require__2(79);
              var normalizeStringArgument = __w_pdfjs_require__2(88);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var ERROR_STACK_INSTALLABLE = __w_pdfjs_require__2(90);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var Error2 = global2.Error;
              var push = [].push;
              var $AggregateError = function AggregateError(errors, message) {
                var options = arguments.length > 2 ? arguments[2] : void 0;
                var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
                var that;
                if (setPrototypeOf) {
                  that = setPrototypeOf(new Error2(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
                } else {
                  that = isInstance ? this : create(AggregateErrorPrototype);
                  createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
                }
                if (message !== void 0)
                  createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
                if (ERROR_STACK_INSTALLABLE)
                  createNonEnumerableProperty(that, "stack", clearErrorStack(that.stack, 1));
                installErrorCause(that, options);
                var errorsArray = [];
                iterate(errors, push, { that: errorsArray });
                createNonEnumerableProperty(that, "errors", errorsArray);
                return that;
              };
              if (setPrototypeOf)
                setPrototypeOf($AggregateError, Error2);
              else
                copyConstructorProperties($AggregateError, Error2, { name: true });
              var AggregateErrorPrototype = $AggregateError.prototype = create(Error2.prototype, {
                constructor: createPropertyDescriptor(1, $AggregateError),
                message: createPropertyDescriptor(1, ""),
                name: createPropertyDescriptor(1, "AggregateError")
              });
              $({ global: true }, { AggregateError: $AggregateError });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var getOwnPropertyDescriptor = __w_pdfjs_require__2(9).f;
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var redefine = __w_pdfjs_require__2(50);
              var setGlobal = __w_pdfjs_require__2(40);
              var copyConstructorProperties = __w_pdfjs_require__2(57);
              var isForced = __w_pdfjs_require__2(68);
              module2.exports = function(options, source) {
                var TARGET = options.target;
                var GLOBAL = options.global;
                var STATIC = options.stat;
                var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                if (GLOBAL) {
                  target = global2;
                } else if (STATIC) {
                  target = global2[TARGET] || setGlobal(TARGET, {});
                } else {
                  target = (global2[TARGET] || {}).prototype;
                }
                if (target)
                  for (key in source) {
                    sourceProperty = source[key];
                    if (options.noTargetGet) {
                      descriptor = getOwnPropertyDescriptor(target, key);
                      targetProperty = descriptor && descriptor.value;
                    } else
                      targetProperty = target[key];
                    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                    if (!FORCED && targetProperty !== void 0) {
                      if (typeof sourceProperty == typeof targetProperty)
                        continue;
                      copyConstructorProperties(sourceProperty, targetProperty);
                    }
                    if (options.sham || targetProperty && targetProperty.sham) {
                      createNonEnumerableProperty(sourceProperty, "sham", true);
                    }
                    redefine(target, key, sourceProperty, options);
                  }
              };
            },
            (module2) => {
              var check = function(it) {
                return it && it.Math == Math && it;
              };
              module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
                return this;
              }() || Function("return this")();
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var call = __w_pdfjs_require__2(12);
              var propertyIsEnumerableModule = __w_pdfjs_require__2(14);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var toPropertyKey = __w_pdfjs_require__2(21);
              var hasOwn = __w_pdfjs_require__2(41);
              var IE8_DOM_DEFINE = __w_pdfjs_require__2(44);
              var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                O = toIndexedObject(O);
                P = toPropertyKey(P);
                if (IE8_DOM_DEFINE)
                  try {
                    return $getOwnPropertyDescriptor(O, P);
                  } catch (error) {
                  }
                if (hasOwn(O, P))
                  return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                return Object.defineProperty({}, 1, {
                  get: function() {
                    return 7;
                  }
                })[1] != 7;
              });
            },
            (module2) => {
              module2.exports = function(exec) {
                try {
                  return !!exec();
                } catch (error) {
                  return true;
                }
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_BIND = __w_pdfjs_require__2(13);
              var call = Function.prototype.call;
              module2.exports = NATIVE_BIND ? call.bind(call) : function() {
                return call.apply(call, arguments);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                var test = function() {
                }.bind();
                return typeof test != "function" || test.hasOwnProperty("prototype");
              });
            },
            (__unused_webpack_module2, exports2) => {
              "use strict";
              var $propertyIsEnumerable = {}.propertyIsEnumerable;
              var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
              exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                var descriptor = getOwnPropertyDescriptor(this, V);
                return !!descriptor && descriptor.enumerable;
              } : $propertyIsEnumerable;
            },
            (module2) => {
              module2.exports = function(bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value
                };
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IndexedObject = __w_pdfjs_require__2(17);
              var requireObjectCoercible = __w_pdfjs_require__2(20);
              module2.exports = function(it) {
                return IndexedObject(requireObjectCoercible(it));
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var uncurryThis = __w_pdfjs_require__2(18);
              var fails = __w_pdfjs_require__2(11);
              var classof = __w_pdfjs_require__2(19);
              var Object2 = global2.Object;
              var split = uncurryThis("".split);
              module2.exports = fails(function() {
                return !Object2("z").propertyIsEnumerable(0);
              }) ? function(it) {
                return classof(it) == "String" ? split(it, "") : Object2(it);
              } : Object2;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_BIND = __w_pdfjs_require__2(13);
              var FunctionPrototype = Function.prototype;
              var bind = FunctionPrototype.bind;
              var call = FunctionPrototype.call;
              var uncurryThis = NATIVE_BIND && bind.bind(call, call);
              module2.exports = NATIVE_BIND ? function(fn) {
                return fn && uncurryThis(fn);
              } : function(fn) {
                return fn && function() {
                  return call.apply(fn, arguments);
                };
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var toString = uncurryThis({}.toString);
              var stringSlice = uncurryThis("".slice);
              module2.exports = function(it) {
                return stringSlice(toString(it), 8, -1);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var TypeError2 = global2.TypeError;
              module2.exports = function(it) {
                if (it == void 0)
                  throw TypeError2("Can't call method on " + it);
                return it;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toPrimitive = __w_pdfjs_require__2(22);
              var isSymbol = __w_pdfjs_require__2(25);
              module2.exports = function(argument) {
                var key = toPrimitive(argument, "string");
                return isSymbol(key) ? key : key + "";
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var call = __w_pdfjs_require__2(12);
              var isObject = __w_pdfjs_require__2(23);
              var isSymbol = __w_pdfjs_require__2(25);
              var getMethod = __w_pdfjs_require__2(32);
              var ordinaryToPrimitive = __w_pdfjs_require__2(35);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var TypeError2 = global2.TypeError;
              var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
              module2.exports = function(input, pref) {
                if (!isObject(input) || isSymbol(input))
                  return input;
                var exoticToPrim = getMethod(input, TO_PRIMITIVE);
                var result;
                if (exoticToPrim) {
                  if (pref === void 0)
                    pref = "default";
                  result = call(exoticToPrim, input, pref);
                  if (!isObject(result) || isSymbol(result))
                    return result;
                  throw TypeError2("Can't convert object to primitive value");
                }
                if (pref === void 0)
                  pref = "number";
                return ordinaryToPrimitive(input, pref);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(24);
              module2.exports = function(it) {
                return typeof it == "object" ? it !== null : isCallable(it);
              };
            },
            (module2) => {
              module2.exports = function(argument) {
                return typeof argument == "function";
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var getBuiltIn = __w_pdfjs_require__2(26);
              var isCallable = __w_pdfjs_require__2(24);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(28);
              var Object2 = global2.Object;
              module2.exports = USE_SYMBOL_AS_UID ? function(it) {
                return typeof it == "symbol";
              } : function(it) {
                var $Symbol = getBuiltIn("Symbol");
                return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object2(it));
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var aFunction = function(argument) {
                return isCallable(argument) ? argument : void 0;
              };
              module2.exports = function(namespace, method) {
                return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              module2.exports = uncurryThis({}.isPrototypeOf);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_SYMBOL = __w_pdfjs_require__2(29);
              module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var V8_VERSION = __w_pdfjs_require__2(30);
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                var symbol = Symbol();
                return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var userAgent = __w_pdfjs_require__2(31);
              var process2 = global2.process;
              var Deno2 = global2.Deno;
              var versions = process2 && process2.versions || Deno2 && Deno2.version;
              var v8 = versions && versions.v8;
              var match, version2;
              if (v8) {
                match = v8.split(".");
                version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
              }
              if (!version2 && userAgent) {
                match = userAgent.match(/Edge\/(\d+)/);
                if (!match || match[1] >= 74) {
                  match = userAgent.match(/Chrome\/(\d+)/);
                  if (match)
                    version2 = +match[1];
                }
              }
              module2.exports = version2;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              module2.exports = getBuiltIn("navigator", "userAgent") || "";
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var aCallable = __w_pdfjs_require__2(33);
              module2.exports = function(V, P) {
                var func = V[P];
                return func == null ? void 0 : aCallable(func);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var tryToString = __w_pdfjs_require__2(34);
              var TypeError2 = global2.TypeError;
              module2.exports = function(argument) {
                if (isCallable(argument))
                  return argument;
                throw TypeError2(tryToString(argument) + " is not a function");
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var String2 = global2.String;
              module2.exports = function(argument) {
                try {
                  return String2(argument);
                } catch (error) {
                  return "Object";
                }
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var call = __w_pdfjs_require__2(12);
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var TypeError2 = global2.TypeError;
              module2.exports = function(input, pref) {
                var fn, val;
                if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                  return val;
                if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
                  return val;
                if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                  return val;
                throw TypeError2("Can't convert object to primitive value");
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var shared = __w_pdfjs_require__2(37);
              var hasOwn = __w_pdfjs_require__2(41);
              var uid = __w_pdfjs_require__2(43);
              var NATIVE_SYMBOL = __w_pdfjs_require__2(29);
              var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(28);
              var WellKnownSymbolsStore = shared("wks");
              var Symbol2 = global2.Symbol;
              var symbolFor = Symbol2 && Symbol2["for"];
              var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
              module2.exports = function(name) {
                if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                  var description = "Symbol." + name;
                  if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
                    WellKnownSymbolsStore[name] = Symbol2[name];
                  } else if (USE_SYMBOL_AS_UID && symbolFor) {
                    WellKnownSymbolsStore[name] = symbolFor(description);
                  } else {
                    WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
                  }
                }
                return WellKnownSymbolsStore[name];
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_PURE = __w_pdfjs_require__2(38);
              var store = __w_pdfjs_require__2(39);
              (module2.exports = function(key, value) {
                return store[key] || (store[key] = value !== void 0 ? value : {});
              })("versions", []).push({
                version: "3.22.3",
                mode: IS_PURE ? "pure" : "global",
                copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
                license: "https://github.com/zloirock/core-js/blob/v3.22.3/LICENSE",
                source: "https://github.com/zloirock/core-js"
              });
            },
            (module2) => {
              module2.exports = false;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var setGlobal = __w_pdfjs_require__2(40);
              var SHARED = "__core-js_shared__";
              var store = global2[SHARED] || setGlobal(SHARED, {});
              module2.exports = store;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var defineProperty = Object.defineProperty;
              module2.exports = function(key, value) {
                try {
                  defineProperty(global2, key, {
                    value,
                    configurable: true,
                    writable: true
                  });
                } catch (error) {
                  global2[key] = value;
                }
                return value;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var toObject = __w_pdfjs_require__2(42);
              var hasOwnProperty = uncurryThis({}.hasOwnProperty);
              module2.exports = Object.hasOwn || function hasOwn(it, key) {
                return hasOwnProperty(toObject(it), key);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var requireObjectCoercible = __w_pdfjs_require__2(20);
              var Object2 = global2.Object;
              module2.exports = function(argument) {
                return Object2(requireObjectCoercible(argument));
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var id = 0;
              var postfix = Math.random();
              var toString = uncurryThis(1 .toString);
              module2.exports = function(key) {
                return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var fails = __w_pdfjs_require__2(11);
              var createElement = __w_pdfjs_require__2(45);
              module2.exports = !DESCRIPTORS && !fails(function() {
                return Object.defineProperty(createElement("div"), "a", {
                  get: function() {
                    return 7;
                  }
                }).a != 7;
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isObject = __w_pdfjs_require__2(23);
              var document2 = global2.document;
              var EXISTS = isObject(document2) && isObject(document2.createElement);
              module2.exports = function(it) {
                return EXISTS ? document2.createElement(it) : {};
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              module2.exports = DESCRIPTORS ? function(object, key, value) {
                return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
              } : function(object, key, value) {
                object[key] = value;
                return object;
              };
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var IE8_DOM_DEFINE = __w_pdfjs_require__2(44);
              var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__2(48);
              var anObject = __w_pdfjs_require__2(49);
              var toPropertyKey = __w_pdfjs_require__2(21);
              var TypeError2 = global2.TypeError;
              var $defineProperty = Object.defineProperty;
              var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var ENUMERABLE = "enumerable";
              var CONFIGURABLE = "configurable";
              var WRITABLE = "writable";
              exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                  var current = $getOwnPropertyDescriptor(O, P);
                  if (current && current[WRITABLE]) {
                    O[P] = Attributes.value;
                    Attributes = {
                      configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                      enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                      writable: false
                    };
                  }
                }
                return $defineProperty(O, P, Attributes);
              } : $defineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (IE8_DOM_DEFINE)
                  try {
                    return $defineProperty(O, P, Attributes);
                  } catch (error) {
                  }
                if ("get" in Attributes || "set" in Attributes)
                  throw TypeError2("Accessors not supported");
                if ("value" in Attributes)
                  O[P] = Attributes.value;
                return O;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var fails = __w_pdfjs_require__2(11);
              module2.exports = DESCRIPTORS && fails(function() {
                return Object.defineProperty(function() {
                }, "prototype", {
                  value: 42,
                  writable: false
                }).prototype != 42;
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isObject = __w_pdfjs_require__2(23);
              var String2 = global2.String;
              var TypeError2 = global2.TypeError;
              module2.exports = function(argument) {
                if (isObject(argument))
                  return argument;
                throw TypeError2(String2(argument) + " is not an object");
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var hasOwn = __w_pdfjs_require__2(41);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var setGlobal = __w_pdfjs_require__2(40);
              var inspectSource = __w_pdfjs_require__2(51);
              var InternalStateModule = __w_pdfjs_require__2(52);
              var CONFIGURABLE_FUNCTION_NAME = __w_pdfjs_require__2(56).CONFIGURABLE;
              var getInternalState = InternalStateModule.get;
              var enforceInternalState = InternalStateModule.enforce;
              var TEMPLATE = String(String).split("String");
              (module2.exports = function(O, key, value, options) {
                var unsafe = options ? !!options.unsafe : false;
                var simple = options ? !!options.enumerable : false;
                var noTargetGet = options ? !!options.noTargetGet : false;
                var name = options && options.name !== void 0 ? options.name : key;
                var state;
                if (isCallable(value)) {
                  if (String(name).slice(0, 7) === "Symbol(") {
                    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
                  }
                  if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                    createNonEnumerableProperty(value, "name", name);
                  }
                  state = enforceInternalState(value);
                  if (!state.source) {
                    state.source = TEMPLATE.join(typeof name == "string" ? name : "");
                  }
                }
                if (O === global2) {
                  if (simple)
                    O[key] = value;
                  else
                    setGlobal(key, value);
                  return;
                } else if (!unsafe) {
                  delete O[key];
                } else if (!noTargetGet && O[key]) {
                  simple = true;
                }
                if (simple)
                  O[key] = value;
                else
                  createNonEnumerableProperty(O, key, value);
              })(Function.prototype, "toString", function toString() {
                return isCallable(this) && getInternalState(this).source || inspectSource(this);
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var isCallable = __w_pdfjs_require__2(24);
              var store = __w_pdfjs_require__2(39);
              var functionToString = uncurryThis(Function.toString);
              if (!isCallable(store.inspectSource)) {
                store.inspectSource = function(it) {
                  return functionToString(it);
                };
              }
              module2.exports = store.inspectSource;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_WEAK_MAP = __w_pdfjs_require__2(53);
              var global2 = __w_pdfjs_require__2(8);
              var uncurryThis = __w_pdfjs_require__2(18);
              var isObject = __w_pdfjs_require__2(23);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var hasOwn = __w_pdfjs_require__2(41);
              var shared = __w_pdfjs_require__2(39);
              var sharedKey = __w_pdfjs_require__2(54);
              var hiddenKeys = __w_pdfjs_require__2(55);
              var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
              var TypeError2 = global2.TypeError;
              var WeakMap2 = global2.WeakMap;
              var set, get2, has;
              var enforce = function(it) {
                return has(it) ? get2(it) : set(it, {});
              };
              var getterFor = function(TYPE) {
                return function(it) {
                  var state;
                  if (!isObject(it) || (state = get2(it)).type !== TYPE) {
                    throw TypeError2("Incompatible receiver, " + TYPE + " required");
                  }
                  return state;
                };
              };
              if (NATIVE_WEAK_MAP || shared.state) {
                var store = shared.state || (shared.state = new WeakMap2());
                var wmget = uncurryThis(store.get);
                var wmhas = uncurryThis(store.has);
                var wmset = uncurryThis(store.set);
                set = function(it, metadata) {
                  if (wmhas(store, it))
                    throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  wmset(store, it, metadata);
                  return metadata;
                };
                get2 = function(it) {
                  return wmget(store, it) || {};
                };
                has = function(it) {
                  return wmhas(store, it);
                };
              } else {
                var STATE = sharedKey("state");
                hiddenKeys[STATE] = true;
                set = function(it, metadata) {
                  if (hasOwn(it, STATE))
                    throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  createNonEnumerableProperty(it, STATE, metadata);
                  return metadata;
                };
                get2 = function(it) {
                  return hasOwn(it, STATE) ? it[STATE] : {};
                };
                has = function(it) {
                  return hasOwn(it, STATE);
                };
              }
              module2.exports = {
                set,
                get: get2,
                has,
                enforce,
                getterFor
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var inspectSource = __w_pdfjs_require__2(51);
              var WeakMap2 = global2.WeakMap;
              module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var shared = __w_pdfjs_require__2(37);
              var uid = __w_pdfjs_require__2(43);
              var keys = shared("keys");
              module2.exports = function(key) {
                return keys[key] || (keys[key] = uid(key));
              };
            },
            (module2) => {
              module2.exports = {};
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var hasOwn = __w_pdfjs_require__2(41);
              var FunctionPrototype = Function.prototype;
              var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
              var EXISTS = hasOwn(FunctionPrototype, "name");
              var PROPER = EXISTS && function something() {
              }.name === "something";
              var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
              module2.exports = {
                EXISTS,
                PROPER,
                CONFIGURABLE
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var hasOwn = __w_pdfjs_require__2(41);
              var ownKeys = __w_pdfjs_require__2(58);
              var getOwnPropertyDescriptorModule = __w_pdfjs_require__2(9);
              var definePropertyModule = __w_pdfjs_require__2(47);
              module2.exports = function(target, source, exceptions) {
                var keys = ownKeys(source);
                var defineProperty = definePropertyModule.f;
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                  }
                }
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              var uncurryThis = __w_pdfjs_require__2(18);
              var getOwnPropertyNamesModule = __w_pdfjs_require__2(59);
              var getOwnPropertySymbolsModule = __w_pdfjs_require__2(67);
              var anObject = __w_pdfjs_require__2(49);
              var concat = uncurryThis([].concat);
              module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
                var keys = getOwnPropertyNamesModule.f(anObject(it));
                var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
              };
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var internalObjectKeys = __w_pdfjs_require__2(60);
              var enumBugKeys = __w_pdfjs_require__2(66);
              var hiddenKeys = enumBugKeys.concat("length", "prototype");
              exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                return internalObjectKeys(O, hiddenKeys);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var hasOwn = __w_pdfjs_require__2(41);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var indexOf = __w_pdfjs_require__2(61).indexOf;
              var hiddenKeys = __w_pdfjs_require__2(55);
              var push = uncurryThis([].push);
              module2.exports = function(object, names) {
                var O = toIndexedObject(object);
                var i = 0;
                var result = [];
                var key;
                for (key in O)
                  !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
                while (names.length > i)
                  if (hasOwn(O, key = names[i++])) {
                    ~indexOf(result, key) || push(result, key);
                  }
                return result;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIndexedObject = __w_pdfjs_require__2(16);
              var toAbsoluteIndex = __w_pdfjs_require__2(62);
              var lengthOfArrayLike = __w_pdfjs_require__2(64);
              var createMethod = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                  var O = toIndexedObject($this);
                  var length = lengthOfArrayLike(O);
                  var index = toAbsoluteIndex(fromIndex, length);
                  var value;
                  if (IS_INCLUDES && el != el)
                    while (length > index) {
                      value = O[index++];
                      if (value != value)
                        return true;
                    }
                  else
                    for (; length > index; index++) {
                      if ((IS_INCLUDES || index in O) && O[index] === el)
                        return IS_INCLUDES || index || 0;
                    }
                  return !IS_INCLUDES && -1;
                };
              };
              module2.exports = {
                includes: createMethod(true),
                indexOf: createMethod(false)
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIntegerOrInfinity = __w_pdfjs_require__2(63);
              var max = Math.max;
              var min = Math.min;
              module2.exports = function(index, length) {
                var integer = toIntegerOrInfinity(index);
                return integer < 0 ? max(integer + length, 0) : min(integer, length);
              };
            },
            (module2) => {
              var ceil = Math.ceil;
              var floor = Math.floor;
              module2.exports = function(argument) {
                var number = +argument;
                return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toLength = __w_pdfjs_require__2(65);
              module2.exports = function(obj) {
                return toLength(obj.length);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIntegerOrInfinity = __w_pdfjs_require__2(63);
              var min = Math.min;
              module2.exports = function(argument) {
                return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
              };
            },
            (module2) => {
              module2.exports = [
                "constructor",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "toLocaleString",
                "toString",
                "valueOf"
              ];
            },
            (__unused_webpack_module2, exports2) => {
              exports2.f = Object.getOwnPropertySymbols;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(24);
              var replacement = /#|\.prototype\./;
              var isForced = function(feature, detection) {
                var value = data[normalize(feature)];
                return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
              };
              var normalize = isForced.normalize = function(string) {
                return String(string).replace(replacement, ".").toLowerCase();
              };
              var data = isForced.data = {};
              var NATIVE = isForced.NATIVE = "N";
              var POLYFILL = isForced.POLYFILL = "P";
              module2.exports = isForced;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var hasOwn = __w_pdfjs_require__2(41);
              var isCallable = __w_pdfjs_require__2(24);
              var toObject = __w_pdfjs_require__2(42);
              var sharedKey = __w_pdfjs_require__2(54);
              var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__2(70);
              var IE_PROTO = sharedKey("IE_PROTO");
              var Object2 = global2.Object;
              var ObjectPrototype = Object2.prototype;
              module2.exports = CORRECT_PROTOTYPE_GETTER ? Object2.getPrototypeOf : function(O) {
                var object = toObject(O);
                if (hasOwn(object, IE_PROTO))
                  return object[IE_PROTO];
                var constructor = object.constructor;
                if (isCallable(constructor) && object instanceof constructor) {
                  return constructor.prototype;
                }
                return object instanceof Object2 ? ObjectPrototype : null;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                function F() {
                }
                F.prototype.constructor = null;
                return Object.getPrototypeOf(new F()) !== F.prototype;
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var anObject = __w_pdfjs_require__2(49);
              var aPossiblePrototype = __w_pdfjs_require__2(72);
              module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var CORRECT_SETTER = false;
                var test = {};
                var setter;
                try {
                  setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
                  setter(test, []);
                  CORRECT_SETTER = test instanceof Array;
                } catch (error) {
                }
                return function setPrototypeOf(O, proto) {
                  anObject(O);
                  aPossiblePrototype(proto);
                  if (CORRECT_SETTER)
                    setter(O, proto);
                  else
                    O.__proto__ = proto;
                  return O;
                };
              }() : void 0);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var String2 = global2.String;
              var TypeError2 = global2.TypeError;
              module2.exports = function(argument) {
                if (typeof argument == "object" || isCallable(argument))
                  return argument;
                throw TypeError2("Can't set " + String2(argument) + " as a prototype");
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var anObject = __w_pdfjs_require__2(49);
              var definePropertiesModule = __w_pdfjs_require__2(74);
              var enumBugKeys = __w_pdfjs_require__2(66);
              var hiddenKeys = __w_pdfjs_require__2(55);
              var html = __w_pdfjs_require__2(76);
              var documentCreateElement = __w_pdfjs_require__2(45);
              var sharedKey = __w_pdfjs_require__2(54);
              var GT = ">";
              var LT = "<";
              var PROTOTYPE = "prototype";
              var SCRIPT = "script";
              var IE_PROTO = sharedKey("IE_PROTO");
              var EmptyConstructor = function() {
              };
              var scriptTag = function(content) {
                return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
              };
              var NullProtoObjectViaActiveX = function(activeXDocument2) {
                activeXDocument2.write(scriptTag(""));
                activeXDocument2.close();
                var temp = activeXDocument2.parentWindow.Object;
                activeXDocument2 = null;
                return temp;
              };
              var NullProtoObjectViaIFrame = function() {
                var iframe = documentCreateElement("iframe");
                var JS = "java" + SCRIPT + ":";
                var iframeDocument;
                iframe.style.display = "none";
                html.appendChild(iframe);
                iframe.src = String(JS);
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(scriptTag("document.F=Object"));
                iframeDocument.close();
                return iframeDocument.F;
              };
              var activeXDocument;
              var NullProtoObject = function() {
                try {
                  activeXDocument = new ActiveXObject("htmlfile");
                } catch (error) {
                }
                NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
                var length = enumBugKeys.length;
                while (length--)
                  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                return NullProtoObject();
              };
              hiddenKeys[IE_PROTO] = true;
              module2.exports = Object.create || function create(O, Properties) {
                var result;
                if (O !== null) {
                  EmptyConstructor[PROTOTYPE] = anObject(O);
                  result = new EmptyConstructor();
                  EmptyConstructor[PROTOTYPE] = null;
                  result[IE_PROTO] = O;
                } else
                  result = NullProtoObject();
                return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
              };
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__2(48);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var anObject = __w_pdfjs_require__2(49);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var objectKeys = __w_pdfjs_require__2(75);
              exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
                anObject(O);
                var props = toIndexedObject(Properties);
                var keys = objectKeys(Properties);
                var length = keys.length;
                var index = 0;
                var key;
                while (length > index)
                  definePropertyModule.f(O, key = keys[index++], props[key]);
                return O;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var internalObjectKeys = __w_pdfjs_require__2(60);
              var enumBugKeys = __w_pdfjs_require__2(66);
              module2.exports = Object.keys || function keys(O) {
                return internalObjectKeys(O, enumBugKeys);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              module2.exports = getBuiltIn("document", "documentElement");
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var $Error = Error;
              var replace = uncurryThis("".replace);
              var TEST = function(arg) {
                return String($Error(arg).stack);
              }("zxcasd");
              var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
              var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
              module2.exports = function(stack, dropEntries) {
                if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
                  while (dropEntries--)
                    stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
                }
                return stack;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isObject = __w_pdfjs_require__2(23);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              module2.exports = function(O, options) {
                if (isObject(options) && "cause" in options) {
                  createNonEnumerableProperty(O, "cause", options.cause);
                }
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var bind = __w_pdfjs_require__2(80);
              var call = __w_pdfjs_require__2(12);
              var anObject = __w_pdfjs_require__2(49);
              var tryToString = __w_pdfjs_require__2(34);
              var isArrayIteratorMethod = __w_pdfjs_require__2(81);
              var lengthOfArrayLike = __w_pdfjs_require__2(64);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var getIterator = __w_pdfjs_require__2(83);
              var getIteratorMethod = __w_pdfjs_require__2(84);
              var iteratorClose = __w_pdfjs_require__2(87);
              var TypeError2 = global2.TypeError;
              var Result = function(stopped, result) {
                this.stopped = stopped;
                this.result = result;
              };
              var ResultPrototype = Result.prototype;
              module2.exports = function(iterable, unboundFunction, options) {
                var that = options && options.that;
                var AS_ENTRIES = !!(options && options.AS_ENTRIES);
                var IS_ITERATOR = !!(options && options.IS_ITERATOR);
                var INTERRUPTED = !!(options && options.INTERRUPTED);
                var fn = bind(unboundFunction, that);
                var iterator, iterFn, index, length, result, next, step;
                var stop = function(condition) {
                  if (iterator)
                    iteratorClose(iterator, "normal", condition);
                  return new Result(true, condition);
                };
                var callFn = function(value) {
                  if (AS_ENTRIES) {
                    anObject(value);
                    return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
                  }
                  return INTERRUPTED ? fn(value, stop) : fn(value);
                };
                if (IS_ITERATOR) {
                  iterator = iterable;
                } else {
                  iterFn = getIteratorMethod(iterable);
                  if (!iterFn)
                    throw TypeError2(tryToString(iterable) + " is not iterable");
                  if (isArrayIteratorMethod(iterFn)) {
                    for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
                      result = callFn(iterable[index]);
                      if (result && isPrototypeOf(ResultPrototype, result))
                        return result;
                    }
                    return new Result(false);
                  }
                  iterator = getIterator(iterable, iterFn);
                }
                next = iterator.next;
                while (!(step = call(next, iterator)).done) {
                  try {
                    result = callFn(step.value);
                  } catch (error) {
                    iteratorClose(iterator, "throw", error);
                  }
                  if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
                    return result;
                }
                return new Result(false);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var aCallable = __w_pdfjs_require__2(33);
              var NATIVE_BIND = __w_pdfjs_require__2(13);
              var bind = uncurryThis(uncurryThis.bind);
              module2.exports = function(fn, that) {
                aCallable(fn);
                return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
                  return fn.apply(that, arguments);
                };
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var Iterators = __w_pdfjs_require__2(82);
              var ITERATOR = wellKnownSymbol("iterator");
              var ArrayPrototype = Array.prototype;
              module2.exports = function(it) {
                return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
              };
            },
            (module2) => {
              module2.exports = {};
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var call = __w_pdfjs_require__2(12);
              var aCallable = __w_pdfjs_require__2(33);
              var anObject = __w_pdfjs_require__2(49);
              var tryToString = __w_pdfjs_require__2(34);
              var getIteratorMethod = __w_pdfjs_require__2(84);
              var TypeError2 = global2.TypeError;
              module2.exports = function(argument, usingIterator) {
                var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
                if (aCallable(iteratorMethod))
                  return anObject(call(iteratorMethod, argument));
                throw TypeError2(tryToString(argument) + " is not iterable");
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(85);
              var getMethod = __w_pdfjs_require__2(32);
              var Iterators = __w_pdfjs_require__2(82);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var ITERATOR = wellKnownSymbol("iterator");
              module2.exports = function(it) {
                if (it != void 0)
                  return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(86);
              var isCallable = __w_pdfjs_require__2(24);
              var classofRaw = __w_pdfjs_require__2(19);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var Object2 = global2.Object;
              var CORRECT_ARGUMENTS = classofRaw(function() {
                return arguments;
              }()) == "Arguments";
              var tryGet = function(it, key) {
                try {
                  return it[key];
                } catch (error) {
                }
              };
              module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                var O, tag, result;
                return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object2(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var test = {};
              test[TO_STRING_TAG] = "z";
              module2.exports = String(test) === "[object z]";
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(12);
              var anObject = __w_pdfjs_require__2(49);
              var getMethod = __w_pdfjs_require__2(32);
              module2.exports = function(iterator, kind, value) {
                var innerResult, innerError;
                anObject(iterator);
                try {
                  innerResult = getMethod(iterator, "return");
                  if (!innerResult) {
                    if (kind === "throw")
                      throw value;
                    return value;
                  }
                  innerResult = call(innerResult, iterator);
                } catch (error) {
                  innerError = true;
                  innerResult = error;
                }
                if (kind === "throw")
                  throw value;
                if (innerError)
                  throw innerResult;
                anObject(innerResult);
                return value;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toString = __w_pdfjs_require__2(89);
              module2.exports = function(argument, $default) {
                return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var classof = __w_pdfjs_require__2(85);
              var String2 = global2.String;
              module2.exports = function(argument) {
                if (classof(argument) === "Symbol")
                  throw TypeError("Cannot convert a Symbol value to a string");
                return String2(argument);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              module2.exports = !fails(function() {
                var error = Error("a");
                if (!("stack" in error))
                  return true;
                Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
                return error.stack !== 7;
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var toIndexedObject = __w_pdfjs_require__2(16);
              var addToUnscopables = __w_pdfjs_require__2(92);
              var Iterators = __w_pdfjs_require__2(82);
              var InternalStateModule = __w_pdfjs_require__2(52);
              var defineProperty = __w_pdfjs_require__2(47).f;
              var defineIterator = __w_pdfjs_require__2(93);
              var IS_PURE = __w_pdfjs_require__2(38);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var ARRAY_ITERATOR = "Array Iterator";
              var setInternalState = InternalStateModule.set;
              var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
              module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
                setInternalState(this, {
                  type: ARRAY_ITERATOR,
                  target: toIndexedObject(iterated),
                  index: 0,
                  kind
                });
              }, function() {
                var state = getInternalState(this);
                var target = state.target;
                var kind = state.kind;
                var index = state.index++;
                if (!target || index >= target.length) {
                  state.target = void 0;
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (kind == "keys")
                  return {
                    value: index,
                    done: false
                  };
                if (kind == "values")
                  return {
                    value: target[index],
                    done: false
                  };
                return {
                  value: [
                    index,
                    target[index]
                  ],
                  done: false
                };
              }, "values");
              var values = Iterators.Arguments = Iterators.Array;
              addToUnscopables("keys");
              addToUnscopables("values");
              addToUnscopables("entries");
              if (!IS_PURE && DESCRIPTORS && values.name !== "values")
                try {
                  defineProperty(values, "name", { value: "values" });
                } catch (error) {
                }
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var create = __w_pdfjs_require__2(73);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var UNSCOPABLES = wellKnownSymbol("unscopables");
              var ArrayPrototype = Array.prototype;
              if (ArrayPrototype[UNSCOPABLES] == void 0) {
                definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                  configurable: true,
                  value: create(null)
                });
              }
              module2.exports = function(key) {
                ArrayPrototype[UNSCOPABLES][key] = true;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var call = __w_pdfjs_require__2(12);
              var IS_PURE = __w_pdfjs_require__2(38);
              var FunctionName = __w_pdfjs_require__2(56);
              var isCallable = __w_pdfjs_require__2(24);
              var createIteratorConstructor = __w_pdfjs_require__2(94);
              var getPrototypeOf = __w_pdfjs_require__2(69);
              var setPrototypeOf = __w_pdfjs_require__2(71);
              var setToStringTag = __w_pdfjs_require__2(96);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var redefine = __w_pdfjs_require__2(50);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var Iterators = __w_pdfjs_require__2(82);
              var IteratorsCore = __w_pdfjs_require__2(95);
              var PROPER_FUNCTION_NAME = FunctionName.PROPER;
              var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
              var IteratorPrototype = IteratorsCore.IteratorPrototype;
              var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
              var ITERATOR = wellKnownSymbol("iterator");
              var KEYS = "keys";
              var VALUES = "values";
              var ENTRIES = "entries";
              var returnThis = function() {
                return this;
              };
              module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                createIteratorConstructor(IteratorConstructor, NAME, next);
                var getIterationMethod = function(KIND) {
                  if (KIND === DEFAULT && defaultIterator)
                    return defaultIterator;
                  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                    return IterablePrototype[KIND];
                  switch (KIND) {
                    case KEYS:
                      return function keys() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case VALUES:
                      return function values() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case ENTRIES:
                      return function entries() {
                        return new IteratorConstructor(this, KIND);
                      };
                  }
                  return function() {
                    return new IteratorConstructor(this);
                  };
                };
                var TO_STRING_TAG = NAME + " Iterator";
                var INCORRECT_VALUES_NAME = false;
                var IterablePrototype = Iterable.prototype;
                var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                var CurrentIteratorPrototype, methods, KEY;
                if (anyNativeIterator) {
                  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                  if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                    if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                      if (setPrototypeOf) {
                        setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                      } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                        redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
                      }
                    }
                    setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                    if (IS_PURE)
                      Iterators[TO_STRING_TAG] = returnThis;
                  }
                }
                if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                  if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
                    createNonEnumerableProperty(IterablePrototype, "name", VALUES);
                  } else {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator = function values() {
                      return call(nativeIterator, this);
                    };
                  }
                }
                if (DEFAULT) {
                  methods = {
                    values: getIterationMethod(VALUES),
                    keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                    entries: getIterationMethod(ENTRIES)
                  };
                  if (FORCED)
                    for (KEY in methods) {
                      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                        redefine(IterablePrototype, KEY, methods[KEY]);
                      }
                    }
                  else
                    $({
                      target: NAME,
                      proto: true,
                      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                    }, methods);
                }
                if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                  redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
                }
                Iterators[NAME] = defaultIterator;
                return methods;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var IteratorPrototype = __w_pdfjs_require__2(95).IteratorPrototype;
              var create = __w_pdfjs_require__2(73);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              var setToStringTag = __w_pdfjs_require__2(96);
              var Iterators = __w_pdfjs_require__2(82);
              var returnThis = function() {
                return this;
              };
              module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
                var TO_STRING_TAG = NAME + " Iterator";
                IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                Iterators[TO_STRING_TAG] = returnThis;
                return IteratorConstructor;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var fails = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(24);
              var create = __w_pdfjs_require__2(73);
              var getPrototypeOf = __w_pdfjs_require__2(69);
              var redefine = __w_pdfjs_require__2(50);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var IS_PURE = __w_pdfjs_require__2(38);
              var ITERATOR = wellKnownSymbol("iterator");
              var BUGGY_SAFARI_ITERATORS = false;
              var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
              if ([].keys) {
                arrayIterator = [].keys();
                if (!("next" in arrayIterator))
                  BUGGY_SAFARI_ITERATORS = true;
                else {
                  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                    IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                }
              }
              var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
                var test = {};
                return IteratorPrototype[ITERATOR].call(test) !== test;
              });
              if (NEW_ITERATOR_PROTOTYPE)
                IteratorPrototype = {};
              else if (IS_PURE)
                IteratorPrototype = create(IteratorPrototype);
              if (!isCallable(IteratorPrototype[ITERATOR])) {
                redefine(IteratorPrototype, ITERATOR, function() {
                  return this;
                });
              }
              module2.exports = {
                IteratorPrototype,
                BUGGY_SAFARI_ITERATORS
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var defineProperty = __w_pdfjs_require__2(47).f;
              var hasOwn = __w_pdfjs_require__2(41);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              module2.exports = function(target, TAG, STATIC) {
                if (target && !STATIC)
                  target = target.prototype;
                if (target && !hasOwn(target, TO_STRING_TAG)) {
                  defineProperty(target, TO_STRING_TAG, {
                    configurable: true,
                    value: TAG
                  });
                }
              };
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(86);
              var redefine = __w_pdfjs_require__2(50);
              var toString = __w_pdfjs_require__2(98);
              if (!TO_STRING_TAG_SUPPORT) {
                redefine(Object.prototype, "toString", toString, { unsafe: true });
              }
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(86);
              var classof = __w_pdfjs_require__2(85);
              module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
                return "[object " + classof(this) + "]";
              };
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(100);
              __w_pdfjs_require__2(123);
              __w_pdfjs_require__2(126);
              __w_pdfjs_require__2(127);
              __w_pdfjs_require__2(128);
              __w_pdfjs_require__2(129);
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var IS_PURE = __w_pdfjs_require__2(38);
              var IS_NODE = __w_pdfjs_require__2(101);
              var global2 = __w_pdfjs_require__2(8);
              var call = __w_pdfjs_require__2(12);
              var redefine = __w_pdfjs_require__2(50);
              var redefineAll = __w_pdfjs_require__2(102);
              var setPrototypeOf = __w_pdfjs_require__2(71);
              var setToStringTag = __w_pdfjs_require__2(96);
              var setSpecies = __w_pdfjs_require__2(103);
              var aCallable = __w_pdfjs_require__2(33);
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var anInstance = __w_pdfjs_require__2(104);
              var speciesConstructor = __w_pdfjs_require__2(105);
              var task = __w_pdfjs_require__2(108).set;
              var microtask = __w_pdfjs_require__2(113);
              var hostReportErrors = __w_pdfjs_require__2(116);
              var perform = __w_pdfjs_require__2(117);
              var Queue = __w_pdfjs_require__2(118);
              var InternalStateModule = __w_pdfjs_require__2(52);
              var NativePromiseConstructor = __w_pdfjs_require__2(119);
              var PromiseConstructorDetection = __w_pdfjs_require__2(120);
              var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
              var PROMISE = "Promise";
              var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
              var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
              var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
              var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
              var setInternalState = InternalStateModule.set;
              var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
              var PromiseConstructor = NativePromiseConstructor;
              var PromisePrototype = NativePromisePrototype;
              var TypeError2 = global2.TypeError;
              var document2 = global2.document;
              var process2 = global2.process;
              var newPromiseCapability = newPromiseCapabilityModule.f;
              var newGenericPromiseCapability = newPromiseCapability;
              var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
              var UNHANDLED_REJECTION = "unhandledrejection";
              var REJECTION_HANDLED = "rejectionhandled";
              var PENDING = 0;
              var FULFILLED = 1;
              var REJECTED = 2;
              var HANDLED = 1;
              var UNHANDLED = 2;
              var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
              var isThenable = function(it) {
                var then;
                return isObject(it) && isCallable(then = it.then) ? then : false;
              };
              var callReaction = function(reaction, state) {
                var value = state.value;
                var ok = state.state == FULFILLED;
                var handler = ok ? reaction.ok : reaction.fail;
                var resolve = reaction.resolve;
                var reject = reaction.reject;
                var domain = reaction.domain;
                var result, then, exited;
                try {
                  if (handler) {
                    if (!ok) {
                      if (state.rejection === UNHANDLED)
                        onHandleUnhandled(state);
                      state.rejection = HANDLED;
                    }
                    if (handler === true)
                      result = value;
                    else {
                      if (domain)
                        domain.enter();
                      result = handler(value);
                      if (domain) {
                        domain.exit();
                        exited = true;
                      }
                    }
                    if (result === reaction.promise) {
                      reject(TypeError2("Promise-chain cycle"));
                    } else if (then = isThenable(result)) {
                      call(then, result, resolve, reject);
                    } else
                      resolve(result);
                  } else
                    reject(value);
                } catch (error) {
                  if (domain && !exited)
                    domain.exit();
                  reject(error);
                }
              };
              var notify = function(state, isReject) {
                if (state.notified)
                  return;
                state.notified = true;
                microtask(function() {
                  var reactions = state.reactions;
                  var reaction;
                  while (reaction = reactions.get()) {
                    callReaction(reaction, state);
                  }
                  state.notified = false;
                  if (isReject && !state.rejection)
                    onUnhandled(state);
                });
              };
              var dispatchEvent = function(name, promise, reason) {
                var event, handler;
                if (DISPATCH_EVENT) {
                  event = document2.createEvent("Event");
                  event.promise = promise;
                  event.reason = reason;
                  event.initEvent(name, false, true);
                  global2.dispatchEvent(event);
                } else
                  event = {
                    promise,
                    reason
                  };
                if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global2["on" + name]))
                  handler(event);
                else if (name === UNHANDLED_REJECTION)
                  hostReportErrors("Unhandled promise rejection", reason);
              };
              var onUnhandled = function(state) {
                call(task, global2, function() {
                  var promise = state.facade;
                  var value = state.value;
                  var IS_UNHANDLED = isUnhandled(state);
                  var result;
                  if (IS_UNHANDLED) {
                    result = perform(function() {
                      if (IS_NODE) {
                        process2.emit("unhandledRejection", value, promise);
                      } else
                        dispatchEvent(UNHANDLED_REJECTION, promise, value);
                    });
                    state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
                    if (result.error)
                      throw result.value;
                  }
                });
              };
              var isUnhandled = function(state) {
                return state.rejection !== HANDLED && !state.parent;
              };
              var onHandleUnhandled = function(state) {
                call(task, global2, function() {
                  var promise = state.facade;
                  if (IS_NODE) {
                    process2.emit("rejectionHandled", promise);
                  } else
                    dispatchEvent(REJECTION_HANDLED, promise, state.value);
                });
              };
              var bind = function(fn, state, unwrap) {
                return function(value) {
                  fn(state, value, unwrap);
                };
              };
              var internalReject = function(state, value, unwrap) {
                if (state.done)
                  return;
                state.done = true;
                if (unwrap)
                  state = unwrap;
                state.value = value;
                state.state = REJECTED;
                notify(state, true);
              };
              var internalResolve = function(state, value, unwrap) {
                if (state.done)
                  return;
                state.done = true;
                if (unwrap)
                  state = unwrap;
                try {
                  if (state.facade === value)
                    throw TypeError2("Promise can't be resolved itself");
                  var then = isThenable(value);
                  if (then) {
                    microtask(function() {
                      var wrapper = { done: false };
                      try {
                        call(then, value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
                      } catch (error) {
                        internalReject(wrapper, error, state);
                      }
                    });
                  } else {
                    state.value = value;
                    state.state = FULFILLED;
                    notify(state, false);
                  }
                } catch (error) {
                  internalReject({ done: false }, error, state);
                }
              };
              if (FORCED_PROMISE_CONSTRUCTOR) {
                PromiseConstructor = function Promise2(executor) {
                  anInstance(this, PromisePrototype);
                  aCallable(executor);
                  call(Internal, this);
                  var state = getInternalPromiseState(this);
                  try {
                    executor(bind(internalResolve, state), bind(internalReject, state));
                  } catch (error) {
                    internalReject(state, error);
                  }
                };
                PromisePrototype = PromiseConstructor.prototype;
                Internal = function Promise2(executor) {
                  setInternalState(this, {
                    type: PROMISE,
                    done: false,
                    notified: false,
                    parent: false,
                    reactions: new Queue(),
                    rejection: false,
                    state: PENDING,
                    value: void 0
                  });
                };
                Internal.prototype = redefineAll(PromisePrototype, {
                  then: function then(onFulfilled, onRejected) {
                    var state = getInternalPromiseState(this);
                    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
                    state.parent = true;
                    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
                    reaction.fail = isCallable(onRejected) && onRejected;
                    reaction.domain = IS_NODE ? process2.domain : void 0;
                    if (state.state == PENDING)
                      state.reactions.add(reaction);
                    else
                      microtask(function() {
                        callReaction(reaction, state);
                      });
                    return reaction.promise;
                  }
                });
                OwnPromiseCapability = function() {
                  var promise = new Internal();
                  var state = getInternalPromiseState(promise);
                  this.promise = promise;
                  this.resolve = bind(internalResolve, state);
                  this.reject = bind(internalReject, state);
                };
                newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
                  return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
                };
                if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
                  nativeThen = NativePromisePrototype.then;
                  if (!NATIVE_PROMISE_SUBCLASSING) {
                    redefine(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
                      var that = this;
                      return new PromiseConstructor(function(resolve, reject) {
                        call(nativeThen, that, resolve, reject);
                      }).then(onFulfilled, onRejected);
                    }, { unsafe: true });
                  }
                  try {
                    delete NativePromisePrototype.constructor;
                  } catch (error) {
                  }
                  if (setPrototypeOf) {
                    setPrototypeOf(NativePromisePrototype, PromisePrototype);
                  }
                }
              }
              $({
                global: true,
                wrap: true,
                forced: FORCED_PROMISE_CONSTRUCTOR
              }, { Promise: PromiseConstructor });
              setToStringTag(PromiseConstructor, PROMISE, false, true);
              setSpecies(PROMISE);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(19);
              var global2 = __w_pdfjs_require__2(8);
              module2.exports = classof(global2.process) == "process";
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var redefine = __w_pdfjs_require__2(50);
              module2.exports = function(target, src, options) {
                for (var key in src)
                  redefine(target, key, src[key], options);
                return target;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var getBuiltIn = __w_pdfjs_require__2(26);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var SPECIES = wellKnownSymbol("species");
              module2.exports = function(CONSTRUCTOR_NAME) {
                var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
                var defineProperty = definePropertyModule.f;
                if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                  defineProperty(Constructor, SPECIES, {
                    configurable: true,
                    get: function() {
                      return this;
                    }
                  });
                }
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var TypeError2 = global2.TypeError;
              module2.exports = function(it, Prototype) {
                if (isPrototypeOf(Prototype, it))
                  return it;
                throw TypeError2("Incorrect invocation");
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var anObject = __w_pdfjs_require__2(49);
              var aConstructor = __w_pdfjs_require__2(106);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var SPECIES = wellKnownSymbol("species");
              module2.exports = function(O, defaultConstructor) {
                var C = anObject(O).constructor;
                var S;
                return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aConstructor(S);
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isConstructor = __w_pdfjs_require__2(107);
              var tryToString = __w_pdfjs_require__2(34);
              var TypeError2 = global2.TypeError;
              module2.exports = function(argument) {
                if (isConstructor(argument))
                  return argument;
                throw TypeError2(tryToString(argument) + " is not a constructor");
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var fails = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(24);
              var classof = __w_pdfjs_require__2(85);
              var getBuiltIn = __w_pdfjs_require__2(26);
              var inspectSource = __w_pdfjs_require__2(51);
              var noop = function() {
              };
              var empty = [];
              var construct = getBuiltIn("Reflect", "construct");
              var constructorRegExp = /^\s*(?:class|function)\b/;
              var exec = uncurryThis(constructorRegExp.exec);
              var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
              var isConstructorModern = function isConstructor(argument) {
                if (!isCallable(argument))
                  return false;
                try {
                  construct(noop, empty, argument);
                  return true;
                } catch (error) {
                  return false;
                }
              };
              var isConstructorLegacy = function isConstructor(argument) {
                if (!isCallable(argument))
                  return false;
                switch (classof(argument)) {
                  case "AsyncFunction":
                  case "GeneratorFunction":
                  case "AsyncGeneratorFunction":
                    return false;
                }
                try {
                  return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
                } catch (error) {
                  return true;
                }
              };
              isConstructorLegacy.sham = true;
              module2.exports = !construct || fails(function() {
                var called;
                return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
                  called = true;
                }) || called;
              }) ? isConstructorLegacy : isConstructorModern;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var apply = __w_pdfjs_require__2(109);
              var bind = __w_pdfjs_require__2(80);
              var isCallable = __w_pdfjs_require__2(24);
              var hasOwn = __w_pdfjs_require__2(41);
              var fails = __w_pdfjs_require__2(11);
              var html = __w_pdfjs_require__2(76);
              var arraySlice = __w_pdfjs_require__2(110);
              var createElement = __w_pdfjs_require__2(45);
              var validateArgumentsLength = __w_pdfjs_require__2(111);
              var IS_IOS = __w_pdfjs_require__2(112);
              var IS_NODE = __w_pdfjs_require__2(101);
              var set = global2.setImmediate;
              var clear = global2.clearImmediate;
              var process2 = global2.process;
              var Dispatch = global2.Dispatch;
              var Function2 = global2.Function;
              var MessageChannel = global2.MessageChannel;
              var String2 = global2.String;
              var counter = 0;
              var queue = {};
              var ONREADYSTATECHANGE = "onreadystatechange";
              var location, defer, channel, port;
              try {
                location = global2.location;
              } catch (error) {
              }
              var run = function(id) {
                if (hasOwn(queue, id)) {
                  var fn = queue[id];
                  delete queue[id];
                  fn();
                }
              };
              var runner = function(id) {
                return function() {
                  run(id);
                };
              };
              var listener = function(event) {
                run(event.data);
              };
              var post = function(id) {
                global2.postMessage(String2(id), location.protocol + "//" + location.host);
              };
              if (!set || !clear) {
                set = function setImmediate(handler) {
                  validateArgumentsLength(arguments.length, 1);
                  var fn = isCallable(handler) ? handler : Function2(handler);
                  var args = arraySlice(arguments, 1);
                  queue[++counter] = function() {
                    apply(fn, void 0, args);
                  };
                  defer(counter);
                  return counter;
                };
                clear = function clearImmediate(id) {
                  delete queue[id];
                };
                if (IS_NODE) {
                  defer = function(id) {
                    process2.nextTick(runner(id));
                  };
                } else if (Dispatch && Dispatch.now) {
                  defer = function(id) {
                    Dispatch.now(runner(id));
                  };
                } else if (MessageChannel && !IS_IOS) {
                  channel = new MessageChannel();
                  port = channel.port2;
                  channel.port1.onmessage = listener;
                  defer = bind(port.postMessage, port);
                } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && location && location.protocol !== "file:" && !fails(post)) {
                  defer = post;
                  global2.addEventListener("message", listener, false);
                } else if (ONREADYSTATECHANGE in createElement("script")) {
                  defer = function(id) {
                    html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
                      html.removeChild(this);
                      run(id);
                    };
                  };
                } else {
                  defer = function(id) {
                    setTimeout(runner(id), 0);
                  };
                }
              }
              module2.exports = {
                set,
                clear
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_BIND = __w_pdfjs_require__2(13);
              var FunctionPrototype = Function.prototype;
              var apply = FunctionPrototype.apply;
              var call = FunctionPrototype.call;
              module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
                return call.apply(apply, arguments);
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              module2.exports = uncurryThis([].slice);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var TypeError2 = global2.TypeError;
              module2.exports = function(passed, required) {
                if (passed < required)
                  throw TypeError2("Not enough arguments");
                return passed;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var userAgent = __w_pdfjs_require__2(31);
              module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var bind = __w_pdfjs_require__2(80);
              var getOwnPropertyDescriptor = __w_pdfjs_require__2(9).f;
              var macrotask = __w_pdfjs_require__2(108).set;
              var IS_IOS = __w_pdfjs_require__2(112);
              var IS_IOS_PEBBLE = __w_pdfjs_require__2(114);
              var IS_WEBOS_WEBKIT = __w_pdfjs_require__2(115);
              var IS_NODE = __w_pdfjs_require__2(101);
              var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
              var document2 = global2.document;
              var process2 = global2.process;
              var Promise2 = global2.Promise;
              var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
              var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
              var flush, head, last, notify, toggle, node, promise, then;
              if (!queueMicrotask) {
                flush = function() {
                  var parent, fn;
                  if (IS_NODE && (parent = process2.domain))
                    parent.exit();
                  while (head) {
                    fn = head.fn;
                    head = head.next;
                    try {
                      fn();
                    } catch (error) {
                      if (head)
                        notify();
                      else
                        last = void 0;
                      throw error;
                    }
                  }
                  last = void 0;
                  if (parent)
                    parent.enter();
                };
                if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
                  toggle = true;
                  node = document2.createTextNode("");
                  new MutationObserver(flush).observe(node, { characterData: true });
                  notify = function() {
                    node.data = toggle = !toggle;
                  };
                } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
                  promise = Promise2.resolve(void 0);
                  promise.constructor = Promise2;
                  then = bind(promise.then, promise);
                  notify = function() {
                    then(flush);
                  };
                } else if (IS_NODE) {
                  notify = function() {
                    process2.nextTick(flush);
                  };
                } else {
                  macrotask = bind(macrotask, global2);
                  notify = function() {
                    macrotask(flush);
                  };
                }
              }
              module2.exports = queueMicrotask || function(fn) {
                var task = {
                  fn,
                  next: void 0
                };
                if (last)
                  last.next = task;
                if (!head) {
                  head = task;
                  notify();
                }
                last = task;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var userAgent = __w_pdfjs_require__2(31);
              var global2 = __w_pdfjs_require__2(8);
              module2.exports = /ipad|iphone|ipod/i.test(userAgent) && global2.Pebble !== void 0;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var userAgent = __w_pdfjs_require__2(31);
              module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              module2.exports = function(a, b) {
                var console2 = global2.console;
                if (console2 && console2.error) {
                  arguments.length == 1 ? console2.error(a) : console2.error(a, b);
                }
              };
            },
            (module2) => {
              module2.exports = function(exec) {
                try {
                  return {
                    error: false,
                    value: exec()
                  };
                } catch (error) {
                  return {
                    error: true,
                    value: error
                  };
                }
              };
            },
            (module2) => {
              var Queue = function() {
                this.head = null;
                this.tail = null;
              };
              Queue.prototype = {
                add: function(item) {
                  var entry = {
                    item,
                    next: null
                  };
                  if (this.head)
                    this.tail.next = entry;
                  else
                    this.head = entry;
                  this.tail = entry;
                },
                get: function() {
                  var entry = this.head;
                  if (entry) {
                    this.head = entry.next;
                    if (this.tail === entry)
                      this.tail = null;
                    return entry.item;
                  }
                }
              };
              module2.exports = Queue;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              module2.exports = global2.Promise;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var NativePromiseConstructor = __w_pdfjs_require__2(119);
              var isCallable = __w_pdfjs_require__2(24);
              var isForced = __w_pdfjs_require__2(68);
              var inspectSource = __w_pdfjs_require__2(51);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var IS_BROWSER = __w_pdfjs_require__2(121);
              var IS_PURE = __w_pdfjs_require__2(38);
              var V8_VERSION = __w_pdfjs_require__2(30);
              var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
              var SPECIES = wellKnownSymbol("species");
              var SUBCLASSING = false;
              var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
              var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
                var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
                var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
                if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
                  return true;
                if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
                  return true;
                if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
                  return false;
                var promise = new NativePromiseConstructor(function(resolve) {
                  resolve(1);
                });
                var FakePromise = function(exec) {
                  exec(function() {
                  }, function() {
                  });
                };
                var constructor = promise.constructor = {};
                constructor[SPECIES] = FakePromise;
                SUBCLASSING = promise.then(function() {
                }) instanceof FakePromise;
                if (!SUBCLASSING)
                  return true;
                return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT;
              });
              module2.exports = {
                CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
                REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
                SUBCLASSING
              };
            },
            (module2) => {
              module2.exports = typeof window == "object" && typeof Deno != "object";
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var aCallable = __w_pdfjs_require__2(33);
              var PromiseCapability = function(C) {
                var resolve, reject;
                this.promise = new C(function($$resolve, $$reject) {
                  if (resolve !== void 0 || reject !== void 0)
                    throw TypeError("Bad Promise constructor");
                  resolve = $$resolve;
                  reject = $$reject;
                });
                this.resolve = aCallable(resolve);
                this.reject = aCallable(reject);
              };
              module2.exports.f = function(C) {
                return new PromiseCapability(C);
              };
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var call = __w_pdfjs_require__2(12);
              var aCallable = __w_pdfjs_require__2(33);
              var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
              var perform = __w_pdfjs_require__2(117);
              var iterate = __w_pdfjs_require__2(79);
              var PROMISE_STATICS_INCORRECT_ITERATION = __w_pdfjs_require__2(124);
              $({
                target: "Promise",
                stat: true,
                forced: PROMISE_STATICS_INCORRECT_ITERATION
              }, {
                all: function all(iterable) {
                  var C = this;
                  var capability = newPromiseCapabilityModule.f(C);
                  var resolve = capability.resolve;
                  var reject = capability.reject;
                  var result = perform(function() {
                    var $promiseResolve = aCallable(C.resolve);
                    var values = [];
                    var counter = 0;
                    var remaining = 1;
                    iterate(iterable, function(promise) {
                      var index = counter++;
                      var alreadyCalled = false;
                      remaining++;
                      call($promiseResolve, C, promise).then(function(value) {
                        if (alreadyCalled)
                          return;
                        alreadyCalled = true;
                        values[index] = value;
                        --remaining || resolve(values);
                      }, reject);
                    });
                    --remaining || resolve(values);
                  });
                  if (result.error)
                    reject(result.value);
                  return capability.promise;
                }
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NativePromiseConstructor = __w_pdfjs_require__2(119);
              var checkCorrectnessOfIteration = __w_pdfjs_require__2(125);
              var FORCED_PROMISE_CONSTRUCTOR = __w_pdfjs_require__2(120).CONSTRUCTOR;
              module2.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
                NativePromiseConstructor.all(iterable).then(void 0, function() {
                });
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var ITERATOR = wellKnownSymbol("iterator");
              var SAFE_CLOSING = false;
              try {
                var called = 0;
                var iteratorWithReturn = {
                  next: function() {
                    return { done: !!called++ };
                  },
                  "return": function() {
                    SAFE_CLOSING = true;
                  }
                };
                iteratorWithReturn[ITERATOR] = function() {
                  return this;
                };
                Array.from(iteratorWithReturn, function() {
                  throw 2;
                });
              } catch (error) {
              }
              module2.exports = function(exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING)
                  return false;
                var ITERATION_SUPPORT = false;
                try {
                  var object = {};
                  object[ITERATOR] = function() {
                    return {
                      next: function() {
                        return { done: ITERATION_SUPPORT = true };
                      }
                    };
                  };
                  exec(object);
                } catch (error) {
                }
                return ITERATION_SUPPORT;
              };
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var IS_PURE = __w_pdfjs_require__2(38);
              var FORCED_PROMISE_CONSTRUCTOR = __w_pdfjs_require__2(120).CONSTRUCTOR;
              var NativePromiseConstructor = __w_pdfjs_require__2(119);
              var getBuiltIn = __w_pdfjs_require__2(26);
              var isCallable = __w_pdfjs_require__2(24);
              var redefine = __w_pdfjs_require__2(50);
              var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
              $({
                target: "Promise",
                proto: true,
                forced: FORCED_PROMISE_CONSTRUCTOR,
                real: true
              }, {
                "catch": function(onRejected) {
                  return this.then(void 0, onRejected);
                }
              });
              if (!IS_PURE && isCallable(NativePromiseConstructor)) {
                var method = getBuiltIn("Promise").prototype["catch"];
                if (NativePromisePrototype["catch"] !== method) {
                  redefine(NativePromisePrototype, "catch", method, { unsafe: true });
                }
              }
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var call = __w_pdfjs_require__2(12);
              var aCallable = __w_pdfjs_require__2(33);
              var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
              var perform = __w_pdfjs_require__2(117);
              var iterate = __w_pdfjs_require__2(79);
              var PROMISE_STATICS_INCORRECT_ITERATION = __w_pdfjs_require__2(124);
              $({
                target: "Promise",
                stat: true,
                forced: PROMISE_STATICS_INCORRECT_ITERATION
              }, {
                race: function race(iterable) {
                  var C = this;
                  var capability = newPromiseCapabilityModule.f(C);
                  var reject = capability.reject;
                  var result = perform(function() {
                    var $promiseResolve = aCallable(C.resolve);
                    iterate(iterable, function(promise) {
                      call($promiseResolve, C, promise).then(capability.resolve, reject);
                    });
                  });
                  if (result.error)
                    reject(result.value);
                  return capability.promise;
                }
              });
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var call = __w_pdfjs_require__2(12);
              var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
              var FORCED_PROMISE_CONSTRUCTOR = __w_pdfjs_require__2(120).CONSTRUCTOR;
              $({
                target: "Promise",
                stat: true,
                forced: FORCED_PROMISE_CONSTRUCTOR
              }, {
                reject: function reject(r) {
                  var capability = newPromiseCapabilityModule.f(this);
                  call(capability.reject, void 0, r);
                  return capability.promise;
                }
              });
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var getBuiltIn = __w_pdfjs_require__2(26);
              var IS_PURE = __w_pdfjs_require__2(38);
              var NativePromiseConstructor = __w_pdfjs_require__2(119);
              var FORCED_PROMISE_CONSTRUCTOR = __w_pdfjs_require__2(120).CONSTRUCTOR;
              var promiseResolve = __w_pdfjs_require__2(130);
              var PromiseConstructorWrapper = getBuiltIn("Promise");
              var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
              $({
                target: "Promise",
                stat: true,
                forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR
              }, {
                resolve: function resolve(x) {
                  return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
                }
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var anObject = __w_pdfjs_require__2(49);
              var isObject = __w_pdfjs_require__2(23);
              var newPromiseCapability = __w_pdfjs_require__2(122);
              module2.exports = function(C, x) {
                anObject(C);
                if (isObject(x) && x.constructor === C)
                  return x;
                var promiseCapability = newPromiseCapability.f(C);
                var resolve = promiseCapability.resolve;
                resolve(x);
                return promiseCapability.promise;
              };
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var call = __w_pdfjs_require__2(12);
              var aCallable = __w_pdfjs_require__2(33);
              var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
              var perform = __w_pdfjs_require__2(117);
              var iterate = __w_pdfjs_require__2(79);
              $({
                target: "Promise",
                stat: true
              }, {
                allSettled: function allSettled(iterable) {
                  var C = this;
                  var capability = newPromiseCapabilityModule.f(C);
                  var resolve = capability.resolve;
                  var reject = capability.reject;
                  var result = perform(function() {
                    var promiseResolve = aCallable(C.resolve);
                    var values = [];
                    var counter = 0;
                    var remaining = 1;
                    iterate(iterable, function(promise) {
                      var index = counter++;
                      var alreadyCalled = false;
                      remaining++;
                      call(promiseResolve, C, promise).then(function(value) {
                        if (alreadyCalled)
                          return;
                        alreadyCalled = true;
                        values[index] = {
                          status: "fulfilled",
                          value
                        };
                        --remaining || resolve(values);
                      }, function(error) {
                        if (alreadyCalled)
                          return;
                        alreadyCalled = true;
                        values[index] = {
                          status: "rejected",
                          reason: error
                        };
                        --remaining || resolve(values);
                      });
                    });
                    --remaining || resolve(values);
                  });
                  if (result.error)
                    reject(result.value);
                  return capability.promise;
                }
              });
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var call = __w_pdfjs_require__2(12);
              var aCallable = __w_pdfjs_require__2(33);
              var getBuiltIn = __w_pdfjs_require__2(26);
              var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
              var perform = __w_pdfjs_require__2(117);
              var iterate = __w_pdfjs_require__2(79);
              var PROMISE_ANY_ERROR = "No one promise resolved";
              $({
                target: "Promise",
                stat: true
              }, {
                any: function any(iterable) {
                  var C = this;
                  var AggregateError = getBuiltIn("AggregateError");
                  var capability = newPromiseCapabilityModule.f(C);
                  var resolve = capability.resolve;
                  var reject = capability.reject;
                  var result = perform(function() {
                    var promiseResolve = aCallable(C.resolve);
                    var errors = [];
                    var counter = 0;
                    var remaining = 1;
                    var alreadyResolved = false;
                    iterate(iterable, function(promise) {
                      var index = counter++;
                      var alreadyRejected = false;
                      remaining++;
                      call(promiseResolve, C, promise).then(function(value) {
                        if (alreadyRejected || alreadyResolved)
                          return;
                        alreadyResolved = true;
                        resolve(value);
                      }, function(error) {
                        if (alreadyRejected || alreadyResolved)
                          return;
                        alreadyRejected = true;
                        errors[index] = error;
                        --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
                      });
                    });
                    --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
                  });
                  if (result.error)
                    reject(result.value);
                  return capability.promise;
                }
              });
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var IS_PURE = __w_pdfjs_require__2(38);
              var NativePromiseConstructor = __w_pdfjs_require__2(119);
              var fails = __w_pdfjs_require__2(11);
              var getBuiltIn = __w_pdfjs_require__2(26);
              var isCallable = __w_pdfjs_require__2(24);
              var speciesConstructor = __w_pdfjs_require__2(105);
              var promiseResolve = __w_pdfjs_require__2(130);
              var redefine = __w_pdfjs_require__2(50);
              var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
              var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
                NativePromisePrototype["finally"].call({
                  then: function() {
                  }
                }, function() {
                });
              });
              $({
                target: "Promise",
                proto: true,
                real: true,
                forced: NON_GENERIC
              }, {
                "finally": function(onFinally) {
                  var C = speciesConstructor(this, getBuiltIn("Promise"));
                  var isFunction = isCallable(onFinally);
                  return this.then(isFunction ? function(x) {
                    return promiseResolve(C, onFinally()).then(function() {
                      return x;
                    });
                  } : onFinally, isFunction ? function(e) {
                    return promiseResolve(C, onFinally()).then(function() {
                      throw e;
                    });
                  } : onFinally);
                }
              });
              if (!IS_PURE && isCallable(NativePromiseConstructor)) {
                var method = getBuiltIn("Promise").prototype["finally"];
                if (NativePromisePrototype["finally"] !== method) {
                  redefine(NativePromisePrototype, "finally", method, { unsafe: true });
                }
              }
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var charAt = __w_pdfjs_require__2(135).charAt;
              var toString = __w_pdfjs_require__2(89);
              var InternalStateModule = __w_pdfjs_require__2(52);
              var defineIterator = __w_pdfjs_require__2(93);
              var STRING_ITERATOR = "String Iterator";
              var setInternalState = InternalStateModule.set;
              var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
              defineIterator(String, "String", function(iterated) {
                setInternalState(this, {
                  type: STRING_ITERATOR,
                  string: toString(iterated),
                  index: 0
                });
              }, function next() {
                var state = getInternalState(this);
                var string = state.string;
                var index = state.index;
                var point;
                if (index >= string.length)
                  return {
                    value: void 0,
                    done: true
                  };
                point = charAt(string, index);
                state.index += point.length;
                return {
                  value: point,
                  done: false
                };
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var toIntegerOrInfinity = __w_pdfjs_require__2(63);
              var toString = __w_pdfjs_require__2(89);
              var requireObjectCoercible = __w_pdfjs_require__2(20);
              var charAt = uncurryThis("".charAt);
              var charCodeAt = uncurryThis("".charCodeAt);
              var stringSlice = uncurryThis("".slice);
              var createMethod = function(CONVERT_TO_STRING) {
                return function($this, pos) {
                  var S = toString(requireObjectCoercible($this));
                  var position = toIntegerOrInfinity(pos);
                  var size = S.length;
                  var first, second;
                  if (position < 0 || position >= size)
                    return CONVERT_TO_STRING ? "" : void 0;
                  first = charCodeAt(S, position);
                  return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
                };
              };
              module2.exports = {
                codeAt: createMethod(false),
                charAt: createMethod(true)
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              module2.exports = global2;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(91);
              __w_pdfjs_require__2(97);
              __w_pdfjs_require__2(138);
              __w_pdfjs_require__2(150);
              __w_pdfjs_require__2(152);
              var path = __w_pdfjs_require__2(136);
              module2.exports = path.structuredClone;
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(139);
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var collection = __w_pdfjs_require__2(140);
              var collectionStrong = __w_pdfjs_require__2(149);
              collection("Map", function(init) {
                return function Map2() {
                  return init(this, arguments.length ? arguments[0] : void 0);
                };
              }, collectionStrong);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(7);
              var global2 = __w_pdfjs_require__2(8);
              var uncurryThis = __w_pdfjs_require__2(18);
              var isForced = __w_pdfjs_require__2(68);
              var redefine = __w_pdfjs_require__2(50);
              var InternalMetadataModule = __w_pdfjs_require__2(141);
              var iterate = __w_pdfjs_require__2(79);
              var anInstance = __w_pdfjs_require__2(104);
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var fails = __w_pdfjs_require__2(11);
              var checkCorrectnessOfIteration = __w_pdfjs_require__2(125);
              var setToStringTag = __w_pdfjs_require__2(96);
              var inheritIfRequired = __w_pdfjs_require__2(148);
              module2.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
                var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
                var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
                var ADDER = IS_MAP ? "set" : "add";
                var NativeConstructor = global2[CONSTRUCTOR_NAME];
                var NativePrototype = NativeConstructor && NativeConstructor.prototype;
                var Constructor = NativeConstructor;
                var exported = {};
                var fixMethod = function(KEY) {
                  var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
                  redefine(NativePrototype, KEY, KEY == "add" ? function add(value) {
                    uncurriedNativeMethod(this, value === 0 ? 0 : value);
                    return this;
                  } : KEY == "delete" ? function(key) {
                    return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  } : KEY == "get" ? function get2(key) {
                    return IS_WEAK && !isObject(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  } : KEY == "has" ? function has(key) {
                    return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  } : function set(key, value) {
                    uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
                    return this;
                  });
                };
                var REPLACE = isForced(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
                  new NativeConstructor().entries().next();
                })));
                if (REPLACE) {
                  Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
                  InternalMetadataModule.enable();
                } else if (isForced(CONSTRUCTOR_NAME, true)) {
                  var instance = new Constructor();
                  var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                  var THROWS_ON_PRIMITIVES = fails(function() {
                    instance.has(1);
                  });
                  var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
                    new NativeConstructor(iterable);
                  });
                  var BUGGY_ZERO = !IS_WEAK && fails(function() {
                    var $instance = new NativeConstructor();
                    var index = 5;
                    while (index--)
                      $instance[ADDER](index, index);
                    return !$instance.has(-0);
                  });
                  if (!ACCEPT_ITERABLES) {
                    Constructor = wrapper(function(dummy, iterable) {
                      anInstance(dummy, NativePrototype);
                      var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                      if (iterable != void 0)
                        iterate(iterable, that[ADDER], {
                          that,
                          AS_ENTRIES: IS_MAP
                        });
                      return that;
                    });
                    Constructor.prototype = NativePrototype;
                    NativePrototype.constructor = Constructor;
                  }
                  if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                    fixMethod("delete");
                    fixMethod("has");
                    IS_MAP && fixMethod("get");
                  }
                  if (BUGGY_ZERO || HASNT_CHAINING)
                    fixMethod(ADDER);
                  if (IS_WEAK && NativePrototype.clear)
                    delete NativePrototype.clear;
                }
                exported[CONSTRUCTOR_NAME] = Constructor;
                $({
                  global: true,
                  forced: Constructor != NativeConstructor
                }, exported);
                setToStringTag(Constructor, CONSTRUCTOR_NAME);
                if (!IS_WEAK)
                  common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
                return Constructor;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var $ = __w_pdfjs_require__2(7);
              var uncurryThis = __w_pdfjs_require__2(18);
              var hiddenKeys = __w_pdfjs_require__2(55);
              var isObject = __w_pdfjs_require__2(23);
              var hasOwn = __w_pdfjs_require__2(41);
              var defineProperty = __w_pdfjs_require__2(47).f;
              var getOwnPropertyNamesModule = __w_pdfjs_require__2(59);
              var getOwnPropertyNamesExternalModule = __w_pdfjs_require__2(142);
              var isExtensible = __w_pdfjs_require__2(145);
              var uid = __w_pdfjs_require__2(43);
              var FREEZING = __w_pdfjs_require__2(147);
              var REQUIRED = false;
              var METADATA = uid("meta");
              var id = 0;
              var setMetadata = function(it) {
                defineProperty(it, METADATA, {
                  value: {
                    objectID: "O" + id++,
                    weakData: {}
                  }
                });
              };
              var fastKey = function(it, create) {
                if (!isObject(it))
                  return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
                if (!hasOwn(it, METADATA)) {
                  if (!isExtensible(it))
                    return "F";
                  if (!create)
                    return "E";
                  setMetadata(it);
                }
                return it[METADATA].objectID;
              };
              var getWeakData = function(it, create) {
                if (!hasOwn(it, METADATA)) {
                  if (!isExtensible(it))
                    return true;
                  if (!create)
                    return false;
                  setMetadata(it);
                }
                return it[METADATA].weakData;
              };
              var onFreeze = function(it) {
                if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
                  setMetadata(it);
                return it;
              };
              var enable = function() {
                meta.enable = function() {
                };
                REQUIRED = true;
                var getOwnPropertyNames = getOwnPropertyNamesModule.f;
                var splice = uncurryThis([].splice);
                var test = {};
                test[METADATA] = 1;
                if (getOwnPropertyNames(test).length) {
                  getOwnPropertyNamesModule.f = function(it) {
                    var result = getOwnPropertyNames(it);
                    for (var i = 0, length = result.length; i < length; i++) {
                      if (result[i] === METADATA) {
                        splice(result, i, 1);
                        break;
                      }
                    }
                    return result;
                  };
                  $({
                    target: "Object",
                    stat: true,
                    forced: true
                  }, { getOwnPropertyNames: getOwnPropertyNamesExternalModule.f });
                }
              };
              var meta = module2.exports = {
                enable,
                fastKey,
                getWeakData,
                onFreeze
              };
              hiddenKeys[METADATA] = true;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(19);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var $getOwnPropertyNames = __w_pdfjs_require__2(59).f;
              var arraySlice = __w_pdfjs_require__2(143);
              var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
              var getWindowNames = function(it) {
                try {
                  return $getOwnPropertyNames(it);
                } catch (error) {
                  return arraySlice(windowNames);
                }
              };
              module2.exports.f = function getOwnPropertyNames(it) {
                return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var toAbsoluteIndex = __w_pdfjs_require__2(62);
              var lengthOfArrayLike = __w_pdfjs_require__2(64);
              var createProperty = __w_pdfjs_require__2(144);
              var Array2 = global2.Array;
              var max = Math.max;
              module2.exports = function(O, start, end) {
                var length = lengthOfArrayLike(O);
                var k = toAbsoluteIndex(start, length);
                var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                var result = Array2(max(fin - k, 0));
                for (var n = 0; k < fin; k++, n++)
                  createProperty(result, n, O[k]);
                result.length = n;
                return result;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var toPropertyKey = __w_pdfjs_require__2(21);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              module2.exports = function(object, key, value) {
                var propertyKey = toPropertyKey(key);
                if (propertyKey in object)
                  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                else
                  object[propertyKey] = value;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var isObject = __w_pdfjs_require__2(23);
              var classof = __w_pdfjs_require__2(19);
              var ARRAY_BUFFER_NON_EXTENSIBLE = __w_pdfjs_require__2(146);
              var $isExtensible = Object.isExtensible;
              var FAILS_ON_PRIMITIVES = fails(function() {
                $isExtensible(1);
              });
              module2.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
                if (!isObject(it))
                  return false;
                if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
                  return false;
                return $isExtensible ? $isExtensible(it) : true;
              } : $isExtensible;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = fails(function() {
                if (typeof ArrayBuffer == "function") {
                  var buffer = new ArrayBuffer(8);
                  if (Object.isExtensible(buffer))
                    Object.defineProperty(buffer, "a", { value: 8 });
                }
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                return Object.isExtensible(Object.preventExtensions({}));
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var setPrototypeOf = __w_pdfjs_require__2(71);
              module2.exports = function($this, dummy, Wrapper) {
                var NewTarget, NewTargetPrototype;
                if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
                  setPrototypeOf($this, NewTargetPrototype);
                return $this;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var defineProperty = __w_pdfjs_require__2(47).f;
              var create = __w_pdfjs_require__2(73);
              var redefineAll = __w_pdfjs_require__2(102);
              var bind = __w_pdfjs_require__2(80);
              var anInstance = __w_pdfjs_require__2(104);
              var iterate = __w_pdfjs_require__2(79);
              var defineIterator = __w_pdfjs_require__2(93);
              var setSpecies = __w_pdfjs_require__2(103);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var fastKey = __w_pdfjs_require__2(141).fastKey;
              var InternalStateModule = __w_pdfjs_require__2(52);
              var setInternalState = InternalStateModule.set;
              var internalStateGetterFor = InternalStateModule.getterFor;
              module2.exports = {
                getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
                  var Constructor = wrapper(function(that, iterable) {
                    anInstance(that, Prototype);
                    setInternalState(that, {
                      type: CONSTRUCTOR_NAME,
                      index: create(null),
                      first: void 0,
                      last: void 0,
                      size: 0
                    });
                    if (!DESCRIPTORS)
                      that.size = 0;
                    if (iterable != void 0)
                      iterate(iterable, that[ADDER], {
                        that,
                        AS_ENTRIES: IS_MAP
                      });
                  });
                  var Prototype = Constructor.prototype;
                  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var define2 = function(that, key, value) {
                    var state = getInternalState(that);
                    var entry = getEntry(that, key);
                    var previous, index;
                    if (entry) {
                      entry.value = value;
                    } else {
                      state.last = entry = {
                        index: index = fastKey(key, true),
                        key,
                        value,
                        previous: previous = state.last,
                        next: void 0,
                        removed: false
                      };
                      if (!state.first)
                        state.first = entry;
                      if (previous)
                        previous.next = entry;
                      if (DESCRIPTORS)
                        state.size++;
                      else
                        that.size++;
                      if (index !== "F")
                        state.index[index] = entry;
                    }
                    return that;
                  };
                  var getEntry = function(that, key) {
                    var state = getInternalState(that);
                    var index = fastKey(key);
                    var entry;
                    if (index !== "F")
                      return state.index[index];
                    for (entry = state.first; entry; entry = entry.next) {
                      if (entry.key == key)
                        return entry;
                    }
                  };
                  redefineAll(Prototype, {
                    clear: function clear() {
                      var that = this;
                      var state = getInternalState(that);
                      var data = state.index;
                      var entry = state.first;
                      while (entry) {
                        entry.removed = true;
                        if (entry.previous)
                          entry.previous = entry.previous.next = void 0;
                        delete data[entry.index];
                        entry = entry.next;
                      }
                      state.first = state.last = void 0;
                      if (DESCRIPTORS)
                        state.size = 0;
                      else
                        that.size = 0;
                    },
                    "delete": function(key) {
                      var that = this;
                      var state = getInternalState(that);
                      var entry = getEntry(that, key);
                      if (entry) {
                        var next = entry.next;
                        var prev = entry.previous;
                        delete state.index[entry.index];
                        entry.removed = true;
                        if (prev)
                          prev.next = next;
                        if (next)
                          next.previous = prev;
                        if (state.first == entry)
                          state.first = next;
                        if (state.last == entry)
                          state.last = prev;
                        if (DESCRIPTORS)
                          state.size--;
                        else
                          that.size--;
                      }
                      return !!entry;
                    },
                    forEach: function forEach(callbackfn) {
                      var state = getInternalState(this);
                      var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                      var entry;
                      while (entry = entry ? entry.next : state.first) {
                        boundFunction(entry.value, entry.key, this);
                        while (entry && entry.removed)
                          entry = entry.previous;
                      }
                    },
                    has: function has(key) {
                      return !!getEntry(this, key);
                    }
                  });
                  redefineAll(Prototype, IS_MAP ? {
                    get: function get2(key) {
                      var entry = getEntry(this, key);
                      return entry && entry.value;
                    },
                    set: function set(key, value) {
                      return define2(this, key === 0 ? 0 : key, value);
                    }
                  } : {
                    add: function add(value) {
                      return define2(this, value = value === 0 ? 0 : value, value);
                    }
                  });
                  if (DESCRIPTORS)
                    defineProperty(Prototype, "size", {
                      get: function() {
                        return getInternalState(this).size;
                      }
                    });
                  return Constructor;
                },
                setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
                  var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
                  var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
                  defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
                    setInternalState(this, {
                      type: ITERATOR_NAME,
                      target: iterated,
                      state: getInternalCollectionState(iterated),
                      kind,
                      last: void 0
                    });
                  }, function() {
                    var state = getInternalIteratorState(this);
                    var kind = state.kind;
                    var entry = state.last;
                    while (entry && entry.removed)
                      entry = entry.previous;
                    if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                      state.target = void 0;
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    if (kind == "keys")
                      return {
                        value: entry.key,
                        done: false
                      };
                    if (kind == "values")
                      return {
                        value: entry.value,
                        done: false
                      };
                    return {
                      value: [
                        entry.key,
                        entry.value
                      ],
                      done: false
                    };
                  }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                  setSpecies(CONSTRUCTOR_NAME);
                }
              };
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(151);
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var collection = __w_pdfjs_require__2(140);
              var collectionStrong = __w_pdfjs_require__2(149);
              collection("Set", function(init) {
                return function Set2() {
                  return init(this, arguments.length ? arguments[0] : void 0);
                };
              }, collectionStrong);
            },
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_PURE = __w_pdfjs_require__2(38);
              var $ = __w_pdfjs_require__2(7);
              var global2 = __w_pdfjs_require__2(8);
              var getBuiltin = __w_pdfjs_require__2(26);
              var uncurryThis = __w_pdfjs_require__2(18);
              var fails = __w_pdfjs_require__2(11);
              var uid = __w_pdfjs_require__2(43);
              var isCallable = __w_pdfjs_require__2(24);
              var isConstructor = __w_pdfjs_require__2(107);
              var isObject = __w_pdfjs_require__2(23);
              var isSymbol = __w_pdfjs_require__2(25);
              var iterate = __w_pdfjs_require__2(79);
              var anObject = __w_pdfjs_require__2(49);
              var classof = __w_pdfjs_require__2(85);
              var hasOwn = __w_pdfjs_require__2(41);
              var createProperty = __w_pdfjs_require__2(144);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var lengthOfArrayLike = __w_pdfjs_require__2(64);
              var validateArgumentsLength = __w_pdfjs_require__2(111);
              var getRegExpFlags = __w_pdfjs_require__2(153);
              var ERROR_STACK_INSTALLABLE = __w_pdfjs_require__2(90);
              var Object2 = global2.Object;
              var Date2 = global2.Date;
              var Error2 = global2.Error;
              var EvalError = global2.EvalError;
              var RangeError2 = global2.RangeError;
              var ReferenceError2 = global2.ReferenceError;
              var SyntaxError = global2.SyntaxError;
              var TypeError2 = global2.TypeError;
              var URIError = global2.URIError;
              var PerformanceMark = global2.PerformanceMark;
              var WebAssembly = global2.WebAssembly;
              var CompileError = WebAssembly && WebAssembly.CompileError || Error2;
              var LinkError = WebAssembly && WebAssembly.LinkError || Error2;
              var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error2;
              var DOMException2 = getBuiltin("DOMException");
              var Set2 = getBuiltin("Set");
              var Map2 = getBuiltin("Map");
              var MapPrototype = Map2.prototype;
              var mapHas = uncurryThis(MapPrototype.has);
              var mapGet = uncurryThis(MapPrototype.get);
              var mapSet = uncurryThis(MapPrototype.set);
              var setAdd = uncurryThis(Set2.prototype.add);
              var objectKeys = getBuiltin("Object", "keys");
              var push = uncurryThis([].push);
              var booleanValueOf = uncurryThis(true.valueOf);
              var numberValueOf = uncurryThis(1 .valueOf);
              var stringValueOf = uncurryThis("".valueOf);
              var getTime = uncurryThis(Date2.prototype.getTime);
              var PERFORMANCE_MARK = uid("structuredClone");
              var DATA_CLONE_ERROR = "DataCloneError";
              var TRANSFERRING = "Transferring";
              var checkBasicSemantic = function(structuredCloneImplementation) {
                return !fails(function() {
                  var set1 = new global2.Set([7]);
                  var set2 = structuredCloneImplementation(set1);
                  var number = structuredCloneImplementation(Object2(7));
                  return set2 == set1 || !set2.has(7) || typeof number != "object" || number != 7;
                }) && structuredCloneImplementation;
              };
              var checkNewErrorsSemantic = function(structuredCloneImplementation) {
                return !fails(function() {
                  var test = structuredCloneImplementation(new global2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
                  return test.name != "AggregateError" || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
                }) && structuredCloneImplementation;
              };
              var nativeStructuredClone = global2.structuredClone;
              var FORCED_REPLACEMENT = IS_PURE || !checkNewErrorsSemantic(nativeStructuredClone);
              var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
                return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
              });
              var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
              var throwUncloneable = function(type) {
                throw new DOMException2("Uncloneable type: " + type, DATA_CLONE_ERROR);
              };
              var throwUnpolyfillable = function(type, kind) {
                throw new DOMException2((kind || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
              };
              var structuredCloneInternal = function(value, map) {
                if (isSymbol(value))
                  throwUncloneable("Symbol");
                if (!isObject(value))
                  return value;
                if (map) {
                  if (mapHas(map, value))
                    return mapGet(map, value);
                } else
                  map = new Map2();
                var type = classof(value);
                var deep = false;
                var C, name, cloned, dataTransfer, i, length, keys, key, source, target;
                switch (type) {
                  case "Array":
                    cloned = [];
                    deep = true;
                    break;
                  case "Object":
                    cloned = {};
                    deep = true;
                    break;
                  case "Map":
                    cloned = new Map2();
                    deep = true;
                    break;
                  case "Set":
                    cloned = new Set2();
                    deep = true;
                    break;
                  case "RegExp":
                    cloned = new RegExp(value.source, getRegExpFlags(value));
                    break;
                  case "Error":
                    name = value.name;
                    switch (name) {
                      case "AggregateError":
                        cloned = getBuiltin("AggregateError")([]);
                        break;
                      case "EvalError":
                        cloned = EvalError();
                        break;
                      case "RangeError":
                        cloned = RangeError2();
                        break;
                      case "ReferenceError":
                        cloned = ReferenceError2();
                        break;
                      case "SyntaxError":
                        cloned = SyntaxError();
                        break;
                      case "TypeError":
                        cloned = TypeError2();
                        break;
                      case "URIError":
                        cloned = URIError();
                        break;
                      case "CompileError":
                        cloned = CompileError();
                        break;
                      case "LinkError":
                        cloned = LinkError();
                        break;
                      case "RuntimeError":
                        cloned = RuntimeError();
                        break;
                      default:
                        cloned = Error2();
                    }
                    deep = true;
                    break;
                  case "DOMException":
                    cloned = new DOMException2(value.message, value.name);
                    deep = true;
                    break;
                  case "DataView":
                  case "Int8Array":
                  case "Uint8Array":
                  case "Uint8ClampedArray":
                  case "Int16Array":
                  case "Uint16Array":
                  case "Int32Array":
                  case "Uint32Array":
                  case "Float32Array":
                  case "Float64Array":
                  case "BigInt64Array":
                  case "BigUint64Array":
                    C = global2[type];
                    if (!isObject(C))
                      throwUnpolyfillable(type);
                    cloned = new C(structuredCloneInternal(value.buffer, map), value.byteOffset, type === "DataView" ? value.byteLength : value.length);
                    break;
                  case "DOMQuad":
                    try {
                      cloned = new DOMQuad(structuredCloneInternal(value.p1, map), structuredCloneInternal(value.p2, map), structuredCloneInternal(value.p3, map), structuredCloneInternal(value.p4, map));
                    } catch (error) {
                      if (nativeRestrictedStructuredClone) {
                        cloned = nativeRestrictedStructuredClone(value);
                      } else
                        throwUnpolyfillable(type);
                    }
                    break;
                  case "FileList":
                    C = global2.DataTransfer;
                    if (isConstructor(C)) {
                      dataTransfer = new C();
                      for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
                        dataTransfer.items.add(structuredCloneInternal(value[i], map));
                      }
                      cloned = dataTransfer.files;
                    } else if (nativeRestrictedStructuredClone) {
                      cloned = nativeRestrictedStructuredClone(value);
                    } else
                      throwUnpolyfillable(type);
                    break;
                  case "ImageData":
                    try {
                      cloned = new ImageData(structuredCloneInternal(value.data, map), value.width, value.height, { colorSpace: value.colorSpace });
                    } catch (error) {
                      if (nativeRestrictedStructuredClone) {
                        cloned = nativeRestrictedStructuredClone(value);
                      } else
                        throwUnpolyfillable(type);
                    }
                    break;
                  default:
                    if (nativeRestrictedStructuredClone) {
                      cloned = nativeRestrictedStructuredClone(value);
                    } else
                      switch (type) {
                        case "BigInt":
                          cloned = Object2(value.valueOf());
                          break;
                        case "Boolean":
                          cloned = Object2(booleanValueOf(value));
                          break;
                        case "Number":
                          cloned = Object2(numberValueOf(value));
                          break;
                        case "String":
                          cloned = Object2(stringValueOf(value));
                          break;
                        case "Date":
                          cloned = new Date2(getTime(value));
                          break;
                        case "ArrayBuffer":
                          C = global2.DataView;
                          if (!C && typeof value.slice != "function")
                            throwUnpolyfillable(type);
                          try {
                            if (typeof value.slice == "function") {
                              cloned = value.slice(0);
                            } else {
                              length = value.byteLength;
                              cloned = new ArrayBuffer(length);
                              source = new C(value);
                              target = new C(cloned);
                              for (i = 0; i < length; i++) {
                                target.setUint8(i, source.getUint8(i));
                              }
                            }
                          } catch (error) {
                            throw new DOMException2("ArrayBuffer is detached", DATA_CLONE_ERROR);
                          }
                          break;
                        case "SharedArrayBuffer":
                          cloned = value;
                          break;
                        case "Blob":
                          try {
                            cloned = value.slice(0, value.size, value.type);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMPoint":
                        case "DOMPointReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMRect":
                        case "DOMRectReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMMatrix":
                        case "DOMMatrixReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "AudioData":
                        case "VideoFrame":
                          if (!isCallable(value.clone))
                            throwUnpolyfillable(type);
                          try {
                            cloned = value.clone();
                          } catch (error) {
                            throwUncloneable(type);
                          }
                          break;
                        case "File":
                          try {
                            cloned = new File([value], value.name, value);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "CryptoKey":
                        case "GPUCompilationMessage":
                        case "GPUCompilationInfo":
                        case "ImageBitmap":
                        case "RTCCertificate":
                        case "WebAssembly.Module":
                          throwUnpolyfillable(type);
                        default:
                          throwUncloneable(type);
                      }
                }
                mapSet(map, value, cloned);
                if (deep)
                  switch (type) {
                    case "Array":
                    case "Object":
                      keys = objectKeys(value);
                      for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
                        key = keys[i];
                        createProperty(cloned, key, structuredCloneInternal(value[key], map));
                      }
                      break;
                    case "Map":
                      value.forEach(function(v, k) {
                        mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
                      });
                      break;
                    case "Set":
                      value.forEach(function(v) {
                        setAdd(cloned, structuredCloneInternal(v, map));
                      });
                      break;
                    case "Error":
                      createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
                      if (hasOwn(value, "cause")) {
                        createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
                      }
                      if (name == "AggregateError") {
                        cloned.errors = structuredCloneInternal(value.errors, map);
                      }
                    case "DOMException":
                      if (ERROR_STACK_INSTALLABLE) {
                        createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
                      }
                  }
                return cloned;
              };
              var PROPER_TRANSFER = nativeStructuredClone && !fails(function() {
                var buffer = new ArrayBuffer(8);
                var clone = nativeStructuredClone(buffer, { transfer: [buffer] });
                return buffer.byteLength != 0 || clone.byteLength != 8;
              });
              var tryToTransfer = function(rawTransfer, map) {
                if (!isObject(rawTransfer))
                  throw TypeError2("Transfer option cannot be converted to a sequence");
                var transfer = [];
                iterate(rawTransfer, function(value2) {
                  push(transfer, anObject(value2));
                });
                var i = 0;
                var length = lengthOfArrayLike(transfer);
                var value, type, C, transferredArray, transferred, canvas, context;
                if (PROPER_TRANSFER) {
                  transferredArray = nativeStructuredClone(transfer, { transfer });
                  while (i < length)
                    mapSet(map, transfer[i], transferredArray[i++]);
                } else
                  while (i < length) {
                    value = transfer[i++];
                    if (mapHas(map, value))
                      throw new DOMException2("Duplicate transferable", DATA_CLONE_ERROR);
                    type = classof(value);
                    switch (type) {
                      case "ImageBitmap":
                        C = global2.OffscreenCanvas;
                        if (!isConstructor(C))
                          throwUnpolyfillable(type, TRANSFERRING);
                        try {
                          canvas = new C(value.width, value.height);
                          context = canvas.getContext("bitmaprenderer");
                          context.transferFromImageBitmap(value);
                          transferred = canvas.transferToImageBitmap();
                        } catch (error) {
                        }
                        break;
                      case "AudioData":
                      case "VideoFrame":
                        if (!isCallable(value.clone) || !isCallable(value.close))
                          throwUnpolyfillable(type, TRANSFERRING);
                        try {
                          transferred = value.clone();
                          value.close();
                        } catch (error) {
                        }
                        break;
                      case "ArrayBuffer":
                      case "MessagePort":
                      case "OffscreenCanvas":
                      case "ReadableStream":
                      case "TransformStream":
                      case "WritableStream":
                        throwUnpolyfillable(type, TRANSFERRING);
                    }
                    if (transferred === void 0)
                      throw new DOMException2("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
                    mapSet(map, value, transferred);
                  }
              };
              $({
                global: true,
                enumerable: true,
                sham: !PROPER_TRANSFER,
                forced: FORCED_REPLACEMENT
              }, {
                structuredClone: function structuredClone2(value) {
                  var options = validateArgumentsLength(arguments.length, 1) > 1 && arguments[1] != null ? anObject(arguments[1]) : void 0;
                  var transfer = options ? options.transfer : void 0;
                  var map;
                  if (transfer !== void 0) {
                    map = new Map2();
                    tryToTransfer(transfer, map);
                  }
                  return structuredCloneInternal(value, map);
                }
              });
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(12);
              var hasOwn = __w_pdfjs_require__2(41);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var regExpFlags = __w_pdfjs_require__2(154);
              var RegExpPrototype = RegExp.prototype;
              module2.exports = function(R) {
                var flags = R.flags;
                return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
              };
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var anObject = __w_pdfjs_require__2(49);
              module2.exports = function() {
                var that = anObject(this);
                var result = "";
                if (that.hasIndices)
                  result += "d";
                if (that.global)
                  result += "g";
                if (that.ignoreCase)
                  result += "i";
                if (that.multiline)
                  result += "m";
                if (that.dotAll)
                  result += "s";
                if (that.unicode)
                  result += "u";
                if (that.sticky)
                  result += "y";
                return result;
              };
            },
            (__unused_webpack_module, exports, __w_pdfjs_require__) => {
              "use strict";
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
              exports.getDocument = getDocument;
              exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
              exports.version = void 0;
              var _regenerator = _interopRequireDefault(__w_pdfjs_require__(156));
              var _util = __w_pdfjs_require__(1);
              var _display_utils = __w_pdfjs_require__(158);
              var _font_loader = __w_pdfjs_require__(160);
              var _annotation_storage = __w_pdfjs_require__(161);
              var _canvas = __w_pdfjs_require__(163);
              var _worker_options = __w_pdfjs_require__(166);
              var _is_node = __w_pdfjs_require__(3);
              var _message_handler = __w_pdfjs_require__(167);
              var _metadata = __w_pdfjs_require__(168);
              var _optional_content_config = __w_pdfjs_require__(169);
              var _transport_stream = __w_pdfjs_require__(170);
              var _xfa_text = __w_pdfjs_require__(171);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function _classPrivateMethodInitSpec(obj, privateSet) {
                _checkPrivateRedeclaration(obj, privateSet);
                privateSet.add(obj);
              }
              function _classPrivateMethodGet(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldInitSpec(obj, privateMap, value) {
                _checkPrivateRedeclaration(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldSet(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
                _classApplyDescriptorSet(receiver, descriptor, value);
                return value;
              }
              function _classPrivateFieldGet(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
                return _classApplyDescriptorGet(receiver, descriptor);
              }
              function _classExtractFieldDescriptor(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _toConsumableArray(arr) {
                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
              }
              function _nonIterableSpread() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArray(iter) {
                if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                  return Array.from(iter);
              }
              function _arrayWithoutHoles(arr) {
                if (Array.isArray(arr))
                  return _arrayLikeToArray(arr);
              }
              function _createForOfIteratorHelper(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e2) {
                      throw _e2;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e3) {
                  didErr = true;
                  err = _e3;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
                _classCheckPrivateStaticAccess(receiver, classConstructor);
                _classCheckPrivateStaticFieldDescriptor(descriptor, "set");
                _classApplyDescriptorSet(receiver, descriptor, value);
                return value;
              }
              function _classApplyDescriptorSet(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
                _classCheckPrivateStaticAccess(receiver, classConstructor);
                _classCheckPrivateStaticFieldDescriptor(descriptor, "get");
                return _classApplyDescriptorGet(receiver, descriptor);
              }
              function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
                if (descriptor === void 0) {
                  throw new TypeError("attempted to " + action + " private static field before its declaration");
                }
              }
              function _classCheckPrivateStaticAccess(receiver, classConstructor) {
                if (receiver !== classConstructor) {
                  throw new TypeError("Private static access of wrong provenance");
                }
              }
              function _classApplyDescriptorGet(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _slicedToArray(arr, i) {
                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
              }
              function _nonIterableRest() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray(o, minLen);
              }
              function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _iterableToArrayLimit(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function _typeof(obj) {
                "@babel/helpers - typeof";
                return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof(obj);
              }
              var DEFAULT_RANGE_CHUNK_SIZE = 65536;
              var RENDERING_CANCELLED_TIMEOUT = 100;
              var DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
              exports.DefaultCanvasFactory = DefaultCanvasFactory;
              var DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
              exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
              var DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
              exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
              if (_is_node.isNodeJS) {
                var _require = __w_pdfjs_require__(172), NodeCanvasFactory = _require.NodeCanvasFactory, NodeCMapReaderFactory = _require.NodeCMapReaderFactory, NodeStandardFontDataFactory = _require.NodeStandardFontDataFactory;
                exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
              }
              var createPDFNetworkStream;
              function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
                createPDFNetworkStream = pdfNetworkStreamFactory;
              }
              function getDocument(src) {
                var task = new PDFDocumentLoadingTask();
                var source;
                if (typeof src === "string" || src instanceof URL) {
                  source = {
                    url: src
                  };
                } else if ((0, _util.isArrayBuffer)(src)) {
                  source = {
                    data: src
                  };
                } else if (src instanceof PDFDataRangeTransport) {
                  source = {
                    range: src
                  };
                } else {
                  if (_typeof(src) !== "object") {
                    throw new Error("Invalid parameter in getDocument, need either string, URL, Uint8Array, or parameter object.");
                  }
                  if (!src.url && !src.data && !src.range) {
                    throw new Error("Invalid parameter object: need either .data, .range or .url");
                  }
                  source = src;
                }
                var params = /* @__PURE__ */ Object.create(null);
                var rangeTransport = null, worker2 = null;
                for (var key in source) {
                  var value = source[key];
                  switch (key) {
                    case "url":
                      if (typeof window !== "undefined") {
                        try {
                          params[key] = new URL(value, window.location).href;
                          continue;
                        } catch (ex) {
                          (0, _util.warn)('Cannot create valid URL: "'.concat(ex, '".'));
                        }
                      } else if (typeof value === "string" || value instanceof URL) {
                        params[key] = value.toString();
                        continue;
                      }
                      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                    case "range":
                      rangeTransport = value;
                      continue;
                    case "worker":
                      worker2 = value;
                      continue;
                    case "data":
                      if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                        params[key] = new Uint8Array(value);
                      } else if (value instanceof Uint8Array) {
                        break;
                      } else if (typeof value === "string") {
                        params[key] = (0, _util.stringToBytes)(value);
                      } else if (_typeof(value) === "object" && value !== null && !isNaN(value.length)) {
                        params[key] = new Uint8Array(value);
                      } else if ((0, _util.isArrayBuffer)(value)) {
                        params[key] = new Uint8Array(value);
                      } else {
                        throw new Error("Invalid PDF binary data: either typed array, string, or array-like object is expected in the data property.");
                      }
                      continue;
                  }
                  params[key] = value;
                }
                params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
                params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
                params.ignoreErrors = params.stopAtErrors !== true;
                params.fontExtraProperties = params.fontExtraProperties === true;
                params.pdfBug = params.pdfBug === true;
                params.enableXfa = params.enableXfa === true;
                if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
                  params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
                }
                if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                  params.docBaseUrl = null;
                }
                if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
                  params.maxImageSize = -1;
                }
                if (typeof params.cMapUrl !== "string") {
                  params.cMapUrl = null;
                }
                if (typeof params.standardFontDataUrl !== "string") {
                  params.standardFontDataUrl = null;
                }
                if (typeof params.useWorkerFetch !== "boolean") {
                  params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
                }
                if (typeof params.isEvalSupported !== "boolean") {
                  params.isEvalSupported = true;
                }
                if (typeof params.disableFontFace !== "boolean") {
                  params.disableFontFace = _is_node.isNodeJS;
                }
                if (typeof params.useSystemFonts !== "boolean") {
                  params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
                }
                if (_typeof(params.ownerDocument) !== "object" || params.ownerDocument === null) {
                  params.ownerDocument = globalThis.document;
                }
                if (typeof params.disableRange !== "boolean") {
                  params.disableRange = false;
                }
                if (typeof params.disableStream !== "boolean") {
                  params.disableStream = false;
                }
                if (typeof params.disableAutoFetch !== "boolean") {
                  params.disableAutoFetch = false;
                }
                (0, _util.setVerbosityLevel)(params.verbosity);
                if (!worker2) {
                  var workerParams = {
                    verbosity: params.verbosity,
                    port: _worker_options.GlobalWorkerOptions.workerPort
                  };
                  worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                  task._worker = worker2;
                }
                var docId = task.docId;
                worker2.promise.then(function() {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  var workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                  var networkStreamPromise = new Promise(function(resolve) {
                    var networkStream;
                    if (rangeTransport) {
                      networkStream = new _transport_stream.PDFDataTransportStream({
                        length: params.length,
                        initialData: params.initialData,
                        progressiveDone: params.progressiveDone,
                        contentDispositionFilename: params.contentDispositionFilename,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      }, rangeTransport);
                    } else if (!params.data) {
                      networkStream = createPDFNetworkStream({
                        url: params.url,
                        length: params.length,
                        httpHeaders: params.httpHeaders,
                        withCredentials: params.withCredentials,
                        rangeChunkSize: params.rangeChunkSize,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      });
                    }
                    resolve(networkStream);
                  });
                  return Promise.all([workerIdPromise, networkStreamPromise]).then(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 2), workerId = _ref2[0], networkStream = _ref2[1];
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                    var transport = new WorkerTransport(messageHandler, task, networkStream, params);
                    task._transport = transport;
                    messageHandler.send("Ready", null);
                  });
                })["catch"](task._capability.reject);
                return task;
              }
              function _fetchDocument(_x, _x2, _x3, _x4) {
                return _fetchDocument2.apply(this, arguments);
              }
              function _fetchDocument2() {
                _fetchDocument2 = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee7(worker2, source, pdfDataRangeTransport, docId) {
                  var workerId;
                  return _regenerator["default"].wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          if (!worker2.destroyed) {
                            _context7.next = 2;
                            break;
                          }
                          throw new Error("Worker was destroyed");
                        case 2:
                          if (pdfDataRangeTransport) {
                            source.length = pdfDataRangeTransport.length;
                            source.initialData = pdfDataRangeTransport.initialData;
                            source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                            source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
                          }
                          _context7.next = 5;
                          return worker2.messageHandler.sendWithPromise("GetDocRequest", {
                            docId,
                            apiVersion: "2.14.305",
                            source: {
                              data: source.data,
                              url: source.url,
                              password: source.password,
                              disableAutoFetch: source.disableAutoFetch,
                              rangeChunkSize: source.rangeChunkSize,
                              length: source.length
                            },
                            maxImageSize: source.maxImageSize,
                            disableFontFace: source.disableFontFace,
                            docBaseUrl: source.docBaseUrl,
                            ignoreErrors: source.ignoreErrors,
                            isEvalSupported: source.isEvalSupported,
                            fontExtraProperties: source.fontExtraProperties,
                            enableXfa: source.enableXfa,
                            useSystemFonts: source.useSystemFonts,
                            cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
                            standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
                          });
                        case 5:
                          workerId = _context7.sent;
                          if (!worker2.destroyed) {
                            _context7.next = 8;
                            break;
                          }
                          throw new Error("Worker was destroyed");
                        case 8:
                          return _context7.abrupt("return", workerId);
                        case 9:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _callee7);
                }));
                return _fetchDocument2.apply(this, arguments);
              }
              var PDFDocumentLoadingTask = /* @__PURE__ */ function() {
                function PDFDocumentLoadingTask2() {
                  var _PDFDocumentLoadingTa, _PDFDocumentLoadingTa2;
                  _classCallCheck(this, PDFDocumentLoadingTask2);
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = "d".concat((_classStaticPrivateFieldSpecSet(PDFDocumentLoadingTask2, PDFDocumentLoadingTask2, _docId, (_PDFDocumentLoadingTa = _classStaticPrivateFieldSpecGet(PDFDocumentLoadingTask2, PDFDocumentLoadingTask2, _docId), _PDFDocumentLoadingTa2 = _PDFDocumentLoadingTa++, _PDFDocumentLoadingTa)), _PDFDocumentLoadingTa2));
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                _createClass(PDFDocumentLoadingTask2, [{
                  key: "promise",
                  get: function get2() {
                    return this._capability.promise;
                  }
                }, {
                  key: "destroy",
                  value: function() {
                    var _destroy = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee() {
                      var _this$_transport;
                      return _regenerator["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              this.destroyed = true;
                              _context.next = 3;
                              return (_this$_transport = this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy();
                            case 3:
                              this._transport = null;
                              if (this._worker) {
                                this._worker.destroy();
                                this._worker = null;
                              }
                            case 5:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this);
                    }));
                    function destroy() {
                      return _destroy.apply(this, arguments);
                    }
                    return destroy;
                  }()
                }]);
                return PDFDocumentLoadingTask2;
              }();
              exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
              var _docId = {
                writable: true,
                value: 0
              };
              var PDFDataRangeTransport = /* @__PURE__ */ function() {
                function PDFDataRangeTransport2(length, initialData) {
                  var progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var contentDispositionFilename = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                  _classCallCheck(this, PDFDataRangeTransport2);
                  this.length = length;
                  this.initialData = initialData;
                  this.progressiveDone = progressiveDone;
                  this.contentDispositionFilename = contentDispositionFilename;
                  this._rangeListeners = [];
                  this._progressListeners = [];
                  this._progressiveReadListeners = [];
                  this._progressiveDoneListeners = [];
                  this._readyCapability = (0, _util.createPromiseCapability)();
                }
                _createClass(PDFDataRangeTransport2, [{
                  key: "addRangeListener",
                  value: function addRangeListener(listener) {
                    this._rangeListeners.push(listener);
                  }
                }, {
                  key: "addProgressListener",
                  value: function addProgressListener(listener) {
                    this._progressListeners.push(listener);
                  }
                }, {
                  key: "addProgressiveReadListener",
                  value: function addProgressiveReadListener(listener) {
                    this._progressiveReadListeners.push(listener);
                  }
                }, {
                  key: "addProgressiveDoneListener",
                  value: function addProgressiveDoneListener(listener) {
                    this._progressiveDoneListeners.push(listener);
                  }
                }, {
                  key: "onDataRange",
                  value: function onDataRange(begin, chunk) {
                    var _iterator = _createForOfIteratorHelper(this._rangeListeners), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var listener = _step.value;
                        listener(begin, chunk);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  }
                }, {
                  key: "onDataProgress",
                  value: function onDataProgress(loaded, total) {
                    var _this = this;
                    this._readyCapability.promise.then(function() {
                      var _iterator2 = _createForOfIteratorHelper(_this._progressListeners), _step2;
                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                          var listener = _step2.value;
                          listener(loaded, total);
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                    });
                  }
                }, {
                  key: "onDataProgressiveRead",
                  value: function onDataProgressiveRead(chunk) {
                    var _this2 = this;
                    this._readyCapability.promise.then(function() {
                      var _iterator3 = _createForOfIteratorHelper(_this2._progressiveReadListeners), _step3;
                      try {
                        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                          var listener = _step3.value;
                          listener(chunk);
                        }
                      } catch (err) {
                        _iterator3.e(err);
                      } finally {
                        _iterator3.f();
                      }
                    });
                  }
                }, {
                  key: "onDataProgressiveDone",
                  value: function onDataProgressiveDone() {
                    var _this3 = this;
                    this._readyCapability.promise.then(function() {
                      var _iterator4 = _createForOfIteratorHelper(_this3._progressiveDoneListeners), _step4;
                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                          var listener = _step4.value;
                          listener();
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }
                    });
                  }
                }, {
                  key: "transportReady",
                  value: function transportReady() {
                    this._readyCapability.resolve();
                  }
                }, {
                  key: "requestDataRange",
                  value: function requestDataRange(begin, end) {
                    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                  }
                }, {
                  key: "abort",
                  value: function abort() {
                  }
                }]);
                return PDFDataRangeTransport2;
              }();
              exports.PDFDataRangeTransport = PDFDataRangeTransport;
              var PDFDocumentProxy = /* @__PURE__ */ function() {
                function PDFDocumentProxy2(pdfInfo, transport) {
                  var _this4 = this;
                  _classCallCheck(this, PDFDocumentProxy2);
                  this._pdfInfo = pdfInfo;
                  this._transport = transport;
                  Object.defineProperty(this, "fingerprint", {
                    get: function get2() {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead.");
                      return this.fingerprints[0];
                    }
                  });
                  Object.defineProperty(this, "getStats", {
                    value: function() {
                      var _value = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee2() {
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead.");
                                return _context2.abrupt("return", _this4.stats || {
                                  streamTypes: {},
                                  fontTypes: {}
                                });
                              case 2:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2);
                      }));
                      function value() {
                        return _value.apply(this, arguments);
                      }
                      return value;
                    }()
                  });
                }
                _createClass(PDFDocumentProxy2, [{
                  key: "annotationStorage",
                  get: function get2() {
                    return this._transport.annotationStorage;
                  }
                }, {
                  key: "numPages",
                  get: function get2() {
                    return this._pdfInfo.numPages;
                  }
                }, {
                  key: "fingerprints",
                  get: function get2() {
                    return this._pdfInfo.fingerprints;
                  }
                }, {
                  key: "stats",
                  get: function get2() {
                    return this._transport.stats;
                  }
                }, {
                  key: "isPureXfa",
                  get: function get2() {
                    return !!this._transport._htmlForXfa;
                  }
                }, {
                  key: "allXfaHtml",
                  get: function get2() {
                    return this._transport._htmlForXfa;
                  }
                }, {
                  key: "getPage",
                  value: function getPage(pageNumber) {
                    return this._transport.getPage(pageNumber);
                  }
                }, {
                  key: "getPageIndex",
                  value: function getPageIndex(ref) {
                    return this._transport.getPageIndex(ref);
                  }
                }, {
                  key: "getDestinations",
                  value: function getDestinations() {
                    return this._transport.getDestinations();
                  }
                }, {
                  key: "getDestination",
                  value: function getDestination(id) {
                    return this._transport.getDestination(id);
                  }
                }, {
                  key: "getPageLabels",
                  value: function getPageLabels() {
                    return this._transport.getPageLabels();
                  }
                }, {
                  key: "getPageLayout",
                  value: function getPageLayout() {
                    return this._transport.getPageLayout();
                  }
                }, {
                  key: "getPageMode",
                  value: function getPageMode() {
                    return this._transport.getPageMode();
                  }
                }, {
                  key: "getViewerPreferences",
                  value: function getViewerPreferences() {
                    return this._transport.getViewerPreferences();
                  }
                }, {
                  key: "getOpenAction",
                  value: function getOpenAction() {
                    return this._transport.getOpenAction();
                  }
                }, {
                  key: "getAttachments",
                  value: function getAttachments() {
                    return this._transport.getAttachments();
                  }
                }, {
                  key: "getJavaScript",
                  value: function getJavaScript() {
                    return this._transport.getJavaScript();
                  }
                }, {
                  key: "getJSActions",
                  value: function getJSActions() {
                    return this._transport.getDocJSActions();
                  }
                }, {
                  key: "getOutline",
                  value: function getOutline() {
                    return this._transport.getOutline();
                  }
                }, {
                  key: "getOptionalContentConfig",
                  value: function getOptionalContentConfig() {
                    return this._transport.getOptionalContentConfig();
                  }
                }, {
                  key: "getPermissions",
                  value: function getPermissions() {
                    return this._transport.getPermissions();
                  }
                }, {
                  key: "getMetadata",
                  value: function getMetadata() {
                    return this._transport.getMetadata();
                  }
                }, {
                  key: "getMarkInfo",
                  value: function getMarkInfo() {
                    return this._transport.getMarkInfo();
                  }
                }, {
                  key: "getData",
                  value: function getData() {
                    return this._transport.getData();
                  }
                }, {
                  key: "getDownloadInfo",
                  value: function getDownloadInfo() {
                    return this._transport.downloadInfoCapability.promise;
                  }
                }, {
                  key: "cleanup",
                  value: function cleanup() {
                    var keepLoadedFonts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                  }
                }, {
                  key: "destroy",
                  value: function destroy() {
                    return this.loadingTask.destroy();
                  }
                }, {
                  key: "loadingParams",
                  get: function get2() {
                    return this._transport.loadingParams;
                  }
                }, {
                  key: "loadingTask",
                  get: function get2() {
                    return this._transport.loadingTask;
                  }
                }, {
                  key: "saveDocument",
                  value: function saveDocument() {
                    if (this._transport.annotationStorage.size <= 0) {
                      (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                    }
                    return this._transport.saveDocument();
                  }
                }, {
                  key: "getFieldObjects",
                  value: function getFieldObjects() {
                    return this._transport.getFieldObjects();
                  }
                }, {
                  key: "hasJSActions",
                  value: function hasJSActions() {
                    return this._transport.hasJSActions();
                  }
                }, {
                  key: "getCalculationOrderIds",
                  value: function getCalculationOrderIds() {
                    return this._transport.getCalculationOrderIds();
                  }
                }]);
                return PDFDocumentProxy2;
              }();
              exports.PDFDocumentProxy = PDFDocumentProxy;
              var PDFPageProxy = /* @__PURE__ */ function() {
                function PDFPageProxy2(pageIndex, pageInfo, transport, ownerDocument) {
                  var pdfBug = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                  _classCallCheck(this, PDFPageProxy2);
                  this._pageIndex = pageIndex;
                  this._pageInfo = pageInfo;
                  this._ownerDocument = ownerDocument;
                  this._transport = transport;
                  this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                  this._pdfBug = pdfBug;
                  this.commonObjs = transport.commonObjs;
                  this.objs = new PDFObjects();
                  this._bitmaps = /* @__PURE__ */ new Set();
                  this.cleanupAfterRender = false;
                  this.pendingCleanup = false;
                  this._intentStates = /* @__PURE__ */ new Map();
                  this._annotationPromises = /* @__PURE__ */ new Map();
                  this.destroyed = false;
                }
                _createClass(PDFPageProxy2, [{
                  key: "pageNumber",
                  get: function get2() {
                    return this._pageIndex + 1;
                  }
                }, {
                  key: "rotate",
                  get: function get2() {
                    return this._pageInfo.rotate;
                  }
                }, {
                  key: "ref",
                  get: function get2() {
                    return this._pageInfo.ref;
                  }
                }, {
                  key: "userUnit",
                  get: function get2() {
                    return this._pageInfo.userUnit;
                  }
                }, {
                  key: "view",
                  get: function get2() {
                    return this._pageInfo.view;
                  }
                }, {
                  key: "getViewport",
                  value: function getViewport() {
                    var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, scale = _ref3.scale, _ref3$rotation = _ref3.rotation, rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation, _ref3$offsetX = _ref3.offsetX, offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX, _ref3$offsetY = _ref3.offsetY, offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY, _ref3$dontFlip = _ref3.dontFlip, dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;
                    return new _display_utils.PageViewport({
                      viewBox: this.view,
                      scale,
                      rotation,
                      offsetX,
                      offsetY,
                      dontFlip
                    });
                  }
                }, {
                  key: "getAnnotations",
                  value: function getAnnotations() {
                    var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$intent = _ref4.intent, intent = _ref4$intent === void 0 ? "display" : _ref4$intent;
                    var intentArgs = this._transport.getRenderingIntent(intent);
                    var promise = this._annotationPromises.get(intentArgs.cacheKey);
                    if (!promise) {
                      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                      this._annotationPromises.set(intentArgs.cacheKey, promise);
                      promise = promise.then(function(annotations) {
                        var _iterator5 = _createForOfIteratorHelper(annotations), _step5;
                        try {
                          var _loop = function _loop2() {
                            var annotation = _step5.value;
                            if (annotation.titleObj !== void 0) {
                              Object.defineProperty(annotation, "title", {
                                get: function get2() {
                                  (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                                  return annotation.titleObj.str;
                                }
                              });
                            }
                            if (annotation.contentsObj !== void 0) {
                              Object.defineProperty(annotation, "contents", {
                                get: function get2() {
                                  (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                                  return annotation.contentsObj.str;
                                }
                              });
                            }
                          };
                          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                            _loop();
                          }
                        } catch (err) {
                          _iterator5.e(err);
                        } finally {
                          _iterator5.f();
                        }
                        return annotations;
                      });
                    }
                    return promise;
                  }
                }, {
                  key: "getJSActions",
                  value: function getJSActions() {
                    return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
                  }
                }, {
                  key: "getXfa",
                  value: function() {
                    var _getXfa = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee3() {
                      var _this$_transport$_htm;
                      return _regenerator["default"].wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              return _context3.abrupt("return", ((_this$_transport$_htm = this._transport._htmlForXfa) === null || _this$_transport$_htm === void 0 ? void 0 : _this$_transport$_htm.children[this._pageIndex]) || null);
                            case 1:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3, this);
                    }));
                    function getXfa() {
                      return _getXfa.apply(this, arguments);
                    }
                    return getXfa;
                  }()
                }, {
                  key: "render",
                  value: function render(_ref5) {
                    var _arguments$, _arguments$2, _this5 = this, _intentState;
                    var canvasContext = _ref5.canvasContext, viewport = _ref5.viewport, _ref5$intent = _ref5.intent, intent = _ref5$intent === void 0 ? "display" : _ref5$intent, _ref5$annotationMode = _ref5.annotationMode, annotationMode = _ref5$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref5$annotationMode, _ref5$transform = _ref5.transform, transform = _ref5$transform === void 0 ? null : _ref5$transform, _ref5$imageLayer = _ref5.imageLayer, imageLayer = _ref5$imageLayer === void 0 ? null : _ref5$imageLayer, _ref5$canvasFactory = _ref5.canvasFactory, canvasFactory = _ref5$canvasFactory === void 0 ? null : _ref5$canvasFactory, _ref5$background = _ref5.background, background = _ref5$background === void 0 ? null : _ref5$background, _ref5$optionalContent = _ref5.optionalContentConfigPromise, optionalContentConfigPromise = _ref5$optionalContent === void 0 ? null : _ref5$optionalContent, _ref5$annotationCanva = _ref5.annotationCanvasMap, annotationCanvasMap = _ref5$annotationCanva === void 0 ? null : _ref5$annotationCanva, _ref5$pageColors = _ref5.pageColors, pageColors = _ref5$pageColors === void 0 ? null : _ref5$pageColors;
                    if (((_arguments$ = arguments[0]) === null || _arguments$ === void 0 ? void 0 : _arguments$.renderInteractiveForms) !== void 0) {
                      (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead.");
                      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                        annotationMode = _util.AnnotationMode.ENABLE_FORMS;
                      }
                    }
                    if (((_arguments$2 = arguments[0]) === null || _arguments$2 === void 0 ? void 0 : _arguments$2.includeAnnotationStorage) !== void 0) {
                      (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead.");
                      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
                      }
                    }
                    if (this._stats) {
                      this._stats.time("Overall");
                    }
                    var intentArgs = this._transport.getRenderingIntent(intent, annotationMode);
                    this.pendingCleanup = false;
                    if (!optionalContentConfigPromise) {
                      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                    }
                    var intentState = this._intentStates.get(intentArgs.cacheKey);
                    if (!intentState) {
                      intentState = /* @__PURE__ */ Object.create(null);
                      this._intentStates.set(intentArgs.cacheKey, intentState);
                    }
                    if (intentState.streamReaderCancelTimeout) {
                      clearTimeout(intentState.streamReaderCancelTimeout);
                      intentState.streamReaderCancelTimeout = null;
                    }
                    var canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                      ownerDocument: this._ownerDocument
                    });
                    var intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                    if (!intentState.displayReadyCapability) {
                      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                      intentState.operatorList = {
                        fnArray: [],
                        argsArray: [],
                        lastChunk: false
                      };
                      if (this._stats) {
                        this._stats.time("Page Request");
                      }
                      this._pumpOperatorList(intentArgs);
                    }
                    var complete = function complete2(error) {
                      intentState.renderTasks["delete"](internalRenderTask);
                      if (_this5.cleanupAfterRender || intentPrint) {
                        _this5.pendingCleanup = true;
                      }
                      _this5._tryCleanup();
                      if (error) {
                        internalRenderTask.capability.reject(error);
                        _this5._abortOperatorList({
                          intentState,
                          reason: error instanceof Error ? error : new Error(error)
                        });
                      } else {
                        internalRenderTask.capability.resolve();
                      }
                      if (_this5._stats) {
                        _this5._stats.timeEnd("Rendering");
                        _this5._stats.timeEnd("Overall");
                      }
                    };
                    var internalRenderTask = new InternalRenderTask({
                      callback: complete,
                      params: {
                        canvasContext,
                        viewport,
                        transform,
                        imageLayer,
                        background
                      },
                      objs: this.objs,
                      commonObjs: this.commonObjs,
                      annotationCanvasMap,
                      operatorList: intentState.operatorList,
                      pageIndex: this._pageIndex,
                      canvasFactory: canvasFactoryInstance,
                      useRequestAnimationFrame: !intentPrint,
                      pdfBug: this._pdfBug,
                      pageColors
                    });
                    ((_intentState = intentState).renderTasks || (_intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
                    var renderTask = internalRenderTask.task;
                    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function(_ref6) {
                      var _ref7 = _slicedToArray(_ref6, 2), transparency = _ref7[0], optionalContentConfig = _ref7[1];
                      if (_this5.pendingCleanup) {
                        complete();
                        return;
                      }
                      if (_this5._stats) {
                        _this5._stats.time("Rendering");
                      }
                      internalRenderTask.initializeGraphics({
                        transparency,
                        optionalContentConfig
                      });
                      internalRenderTask.operatorListChanged();
                    })["catch"](complete);
                    return renderTask;
                  }
                }, {
                  key: "getOperatorList",
                  value: function getOperatorList() {
                    var _ref8 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref8$intent = _ref8.intent, intent = _ref8$intent === void 0 ? "display" : _ref8$intent, _ref8$annotationMode = _ref8.annotationMode, annotationMode = _ref8$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref8$annotationMode;
                    function operatorListChanged() {
                      if (intentState.operatorList.lastChunk) {
                        intentState.opListReadCapability.resolve(intentState.operatorList);
                        intentState.renderTasks["delete"](opListTask);
                      }
                    }
                    var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);
                    var intentState = this._intentStates.get(intentArgs.cacheKey);
                    if (!intentState) {
                      intentState = /* @__PURE__ */ Object.create(null);
                      this._intentStates.set(intentArgs.cacheKey, intentState);
                    }
                    var opListTask;
                    if (!intentState.opListReadCapability) {
                      var _intentState2;
                      opListTask = /* @__PURE__ */ Object.create(null);
                      opListTask.operatorListChanged = operatorListChanged;
                      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                      ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
                      intentState.operatorList = {
                        fnArray: [],
                        argsArray: [],
                        lastChunk: false
                      };
                      if (this._stats) {
                        this._stats.time("Page Request");
                      }
                      this._pumpOperatorList(intentArgs);
                    }
                    return intentState.opListReadCapability.promise;
                  }
                }, {
                  key: "streamTextContent",
                  value: function streamTextContent() {
                    var _ref9 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref9$disableCombineT = _ref9.disableCombineTextItems, disableCombineTextItems = _ref9$disableCombineT === void 0 ? false : _ref9$disableCombineT, _ref9$includeMarkedCo = _ref9.includeMarkedContent, includeMarkedContent = _ref9$includeMarkedCo === void 0 ? false : _ref9$includeMarkedCo;
                    var TEXT_CONTENT_CHUNK_SIZE = 100;
                    return this._transport.messageHandler.sendWithStream("GetTextContent", {
                      pageIndex: this._pageIndex,
                      combineTextItems: disableCombineTextItems !== true,
                      includeMarkedContent: includeMarkedContent === true
                    }, {
                      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                      size: function size(textContent) {
                        return textContent.items.length;
                      }
                    });
                  }
                }, {
                  key: "getTextContent",
                  value: function getTextContent() {
                    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    if (this._transport._htmlForXfa) {
                      return this.getXfa().then(function(xfa) {
                        return _xfa_text.XfaText.textContent(xfa);
                      });
                    }
                    var readableStream = this.streamTextContent(params);
                    return new Promise(function(resolve, reject) {
                      function pump() {
                        reader.read().then(function(_ref10) {
                          var _textContent$items;
                          var value = _ref10.value, done = _ref10.done;
                          if (done) {
                            resolve(textContent);
                            return;
                          }
                          Object.assign(textContent.styles, value.styles);
                          (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));
                          pump();
                        }, reject);
                      }
                      var reader = readableStream.getReader();
                      var textContent = {
                        items: [],
                        styles: /* @__PURE__ */ Object.create(null)
                      };
                      pump();
                    });
                  }
                }, {
                  key: "getStructTree",
                  value: function getStructTree() {
                    return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
                  }
                }, {
                  key: "_destroy",
                  value: function _destroy() {
                    this.destroyed = true;
                    var waitOn = [];
                    var _iterator6 = _createForOfIteratorHelper(this._intentStates.values()), _step6;
                    try {
                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                        var intentState = _step6.value;
                        this._abortOperatorList({
                          intentState,
                          reason: new Error("Page was destroyed."),
                          force: true
                        });
                        if (intentState.opListReadCapability) {
                          continue;
                        }
                        var _iterator8 = _createForOfIteratorHelper(intentState.renderTasks), _step8;
                        try {
                          for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                            var internalRenderTask = _step8.value;
                            waitOn.push(internalRenderTask.completed);
                            internalRenderTask.cancel();
                          }
                        } catch (err) {
                          _iterator8.e(err);
                        } finally {
                          _iterator8.f();
                        }
                      }
                    } catch (err) {
                      _iterator6.e(err);
                    } finally {
                      _iterator6.f();
                    }
                    this.objs.clear();
                    var _iterator7 = _createForOfIteratorHelper(this._bitmaps), _step7;
                    try {
                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                        var bitmap = _step7.value;
                        bitmap.close();
                      }
                    } catch (err) {
                      _iterator7.e(err);
                    } finally {
                      _iterator7.f();
                    }
                    this._bitmaps.clear();
                    this._annotationPromises.clear();
                    this._jsActionsPromise = null;
                    this._structTreePromise = null;
                    this.pendingCleanup = false;
                    return Promise.all(waitOn);
                  }
                }, {
                  key: "cleanup",
                  value: function cleanup() {
                    var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    this.pendingCleanup = true;
                    return this._tryCleanup(resetStats);
                  }
                }, {
                  key: "_tryCleanup",
                  value: function _tryCleanup() {
                    var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (!this.pendingCleanup) {
                      return false;
                    }
                    var _iterator9 = _createForOfIteratorHelper(this._intentStates.values()), _step9;
                    try {
                      for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                        var _step9$value = _step9.value, renderTasks = _step9$value.renderTasks, operatorList = _step9$value.operatorList;
                        if (renderTasks.size > 0 || !operatorList.lastChunk) {
                          return false;
                        }
                      }
                    } catch (err) {
                      _iterator9.e(err);
                    } finally {
                      _iterator9.f();
                    }
                    this._intentStates.clear();
                    this.objs.clear();
                    this._annotationPromises.clear();
                    this._jsActionsPromise = null;
                    this._structTreePromise = null;
                    if (resetStats && this._stats) {
                      this._stats = new _display_utils.StatTimer();
                    }
                    var _iterator10 = _createForOfIteratorHelper(this._bitmaps), _step10;
                    try {
                      for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                        var bitmap = _step10.value;
                        bitmap.close();
                      }
                    } catch (err) {
                      _iterator10.e(err);
                    } finally {
                      _iterator10.f();
                    }
                    this._bitmaps.clear();
                    this.pendingCleanup = false;
                    return true;
                  }
                }, {
                  key: "_startRenderPage",
                  value: function _startRenderPage(transparency, cacheKey) {
                    var intentState = this._intentStates.get(cacheKey);
                    if (!intentState) {
                      return;
                    }
                    if (this._stats) {
                      this._stats.timeEnd("Page Request");
                    }
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.resolve(transparency);
                    }
                  }
                }, {
                  key: "_renderPageChunk",
                  value: function _renderPageChunk(operatorListChunk, intentState) {
                    for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
                      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                    }
                    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                    var _iterator11 = _createForOfIteratorHelper(intentState.renderTasks), _step11;
                    try {
                      for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                        var internalRenderTask = _step11.value;
                        internalRenderTask.operatorListChanged();
                      }
                    } catch (err) {
                      _iterator11.e(err);
                    } finally {
                      _iterator11.f();
                    }
                    if (operatorListChunk.lastChunk) {
                      this._tryCleanup();
                    }
                  }
                }, {
                  key: "_pumpOperatorList",
                  value: function _pumpOperatorList(_ref11) {
                    var _this6 = this;
                    var renderingIntent = _ref11.renderingIntent, cacheKey = _ref11.cacheKey;
                    var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                      pageIndex: this._pageIndex,
                      intent: renderingIntent,
                      cacheKey,
                      annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null
                    });
                    var reader = readableStream.getReader();
                    var intentState = this._intentStates.get(cacheKey);
                    intentState.streamReader = reader;
                    var pump = function pump2() {
                      reader.read().then(function(_ref12) {
                        var value = _ref12.value, done = _ref12.done;
                        if (done) {
                          intentState.streamReader = null;
                          return;
                        }
                        if (_this6._transport.destroyed) {
                          return;
                        }
                        _this6._renderPageChunk(value, intentState);
                        pump2();
                      }, function(reason) {
                        intentState.streamReader = null;
                        if (_this6._transport.destroyed) {
                          return;
                        }
                        if (intentState.operatorList) {
                          intentState.operatorList.lastChunk = true;
                          var _iterator12 = _createForOfIteratorHelper(intentState.renderTasks), _step12;
                          try {
                            for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                              var internalRenderTask = _step12.value;
                              internalRenderTask.operatorListChanged();
                            }
                          } catch (err) {
                            _iterator12.e(err);
                          } finally {
                            _iterator12.f();
                          }
                          _this6._tryCleanup();
                        }
                        if (intentState.displayReadyCapability) {
                          intentState.displayReadyCapability.reject(reason);
                        } else if (intentState.opListReadCapability) {
                          intentState.opListReadCapability.reject(reason);
                        } else {
                          throw reason;
                        }
                      });
                    };
                    pump();
                  }
                }, {
                  key: "_abortOperatorList",
                  value: function _abortOperatorList(_ref13) {
                    var _this7 = this;
                    var intentState = _ref13.intentState, reason = _ref13.reason, _ref13$force = _ref13.force, force = _ref13$force === void 0 ? false : _ref13$force;
                    if (!intentState.streamReader) {
                      return;
                    }
                    if (!force) {
                      if (intentState.renderTasks.size > 0) {
                        return;
                      }
                      if (reason instanceof _display_utils.RenderingCancelledException) {
                        intentState.streamReaderCancelTimeout = setTimeout(function() {
                          _this7._abortOperatorList({
                            intentState,
                            reason,
                            force: true
                          });
                          intentState.streamReaderCancelTimeout = null;
                        }, RENDERING_CANCELLED_TIMEOUT);
                        return;
                      }
                    }
                    intentState.streamReader.cancel(new _util.AbortException(reason.message))["catch"](function() {
                    });
                    intentState.streamReader = null;
                    if (this._transport.destroyed) {
                      return;
                    }
                    var _iterator13 = _createForOfIteratorHelper(this._intentStates), _step13;
                    try {
                      for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
                        var _step13$value = _slicedToArray(_step13.value, 2), curCacheKey = _step13$value[0], curIntentState = _step13$value[1];
                        if (curIntentState === intentState) {
                          this._intentStates["delete"](curCacheKey);
                          break;
                        }
                      }
                    } catch (err) {
                      _iterator13.e(err);
                    } finally {
                      _iterator13.f();
                    }
                    this.cleanup();
                  }
                }, {
                  key: "stats",
                  get: function get2() {
                    return this._stats;
                  }
                }]);
                return PDFPageProxy2;
              }();
              exports.PDFPageProxy = PDFPageProxy;
              var LoopbackPort = /* @__PURE__ */ function() {
                function LoopbackPort2() {
                  _classCallCheck(this, LoopbackPort2);
                  this._listeners = [];
                  this._deferred = Promise.resolve();
                }
                _createClass(LoopbackPort2, [{
                  key: "postMessage",
                  value: function postMessage(obj, transfers) {
                    var _this8 = this;
                    var event = {
                      data: structuredClone(obj, transfers)
                    };
                    this._deferred.then(function() {
                      var _iterator14 = _createForOfIteratorHelper(_this8._listeners), _step14;
                      try {
                        for (_iterator14.s(); !(_step14 = _iterator14.n()).done; ) {
                          var listener = _step14.value;
                          listener.call(_this8, event);
                        }
                      } catch (err) {
                        _iterator14.e(err);
                      } finally {
                        _iterator14.f();
                      }
                    });
                  }
                }, {
                  key: "addEventListener",
                  value: function addEventListener(name, listener) {
                    this._listeners.push(listener);
                  }
                }, {
                  key: "removeEventListener",
                  value: function removeEventListener(name, listener) {
                    var i = this._listeners.indexOf(listener);
                    this._listeners.splice(i, 1);
                  }
                }, {
                  key: "terminate",
                  value: function terminate() {
                    this._listeners.length = 0;
                  }
                }]);
                return LoopbackPort2;
              }();
              exports.LoopbackPort = LoopbackPort;
              var PDFWorkerUtil = {
                isWorkerDisabled: false,
                fallbackWorkerSrc: null,
                fakeWorkerId: 0
              };
              exports.PDFWorkerUtil = PDFWorkerUtil;
              {
                if (_is_node.isNodeJS && typeof __require === "function") {
                  PDFWorkerUtil.isWorkerDisabled = true;
                  PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                } else if ((typeof document === "undefined" ? "undefined" : _typeof(document)) === "object") {
                  var _document, _document$currentScri;
                  var pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;
                  if (pdfjsFilePath) {
                    PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                  }
                }
                PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                  var base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch (e) {
                    return false;
                  }
                  var other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                };
                PDFWorkerUtil.createCDNWrapper = function(url) {
                  var wrapper = 'importScripts("'.concat(url, '");');
                  return URL.createObjectURL(new Blob([wrapper]));
                };
              }
              var PDFWorker = /* @__PURE__ */ function() {
                function PDFWorker() {
                  var _ref14 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref14$name = _ref14.name, name = _ref14$name === void 0 ? null : _ref14$name, _ref14$port = _ref14.port, port = _ref14$port === void 0 ? null : _ref14$port, _ref14$verbosity = _ref14.verbosity, verbosity = _ref14$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref14$verbosity;
                  _classCallCheck(this, PDFWorker);
                  if (port && _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                _createClass(PDFWorker, [{
                  key: "promise",
                  get: function get2() {
                    return this._readyCapability.promise;
                  }
                }, {
                  key: "port",
                  get: function get2() {
                    return this._port;
                  }
                }, {
                  key: "messageHandler",
                  get: function get2() {
                    return this._messageHandler;
                  }
                }, {
                  key: "_initializeFromPort",
                  value: function _initializeFromPort(port) {
                    this._port = port;
                    this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                    this._messageHandler.on("ready", function() {
                    });
                    this._readyCapability.resolve();
                  }
                }, {
                  key: "_initialize",
                  value: function _initialize() {
                    var _this9 = this;
                    if (typeof Worker !== "undefined" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
                      var workerSrc = PDFWorker.workerSrc;
                      try {
                        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                        }
                        var worker2 = new Worker(workerSrc);
                        var messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                        var terminateEarly = function terminateEarly2() {
                          worker2.removeEventListener("error", onWorkerError);
                          messageHandler.destroy();
                          worker2.terminate();
                          if (_this9.destroyed) {
                            _this9._readyCapability.reject(new Error("Worker was destroyed"));
                          } else {
                            _this9._setupFakeWorker();
                          }
                        };
                        var onWorkerError = function onWorkerError2() {
                          if (!_this9._webWorker) {
                            terminateEarly();
                          }
                        };
                        worker2.addEventListener("error", onWorkerError);
                        messageHandler.on("test", function(data) {
                          worker2.removeEventListener("error", onWorkerError);
                          if (_this9.destroyed) {
                            terminateEarly();
                            return;
                          }
                          if (data) {
                            _this9._messageHandler = messageHandler;
                            _this9._port = worker2;
                            _this9._webWorker = worker2;
                            _this9._readyCapability.resolve();
                            messageHandler.send("configure", {
                              verbosity: _this9.verbosity
                            });
                          } else {
                            _this9._setupFakeWorker();
                            messageHandler.destroy();
                            worker2.terminate();
                          }
                        });
                        messageHandler.on("ready", function(data) {
                          worker2.removeEventListener("error", onWorkerError);
                          if (_this9.destroyed) {
                            terminateEarly();
                            return;
                          }
                          try {
                            sendTest();
                          } catch (e) {
                            _this9._setupFakeWorker();
                          }
                        });
                        var sendTest = function sendTest2() {
                          var testObj = new Uint8Array();
                          messageHandler.send("test", testObj, [testObj.buffer]);
                        };
                        sendTest();
                        return;
                      } catch (e) {
                        (0, _util.info)("The worker has been disabled.");
                      }
                    }
                    this._setupFakeWorker();
                  }
                }, {
                  key: "_setupFakeWorker",
                  value: function _setupFakeWorker() {
                    var _this10 = this;
                    if (!PDFWorkerUtil.isWorkerDisabled) {
                      (0, _util.warn)("Setting up fake worker.");
                      PDFWorkerUtil.isWorkerDisabled = true;
                    }
                    PDFWorker._setupFakeWorkerGlobal.then(function(WorkerMessageHandler) {
                      if (_this10.destroyed) {
                        _this10._readyCapability.reject(new Error("Worker was destroyed"));
                        return;
                      }
                      var port = new LoopbackPort();
                      _this10._port = port;
                      var id = "fake".concat(PDFWorkerUtil.fakeWorkerId++);
                      var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                      WorkerMessageHandler.setup(workerHandler, port);
                      var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                      _this10._messageHandler = messageHandler;
                      _this10._readyCapability.resolve();
                      messageHandler.send("configure", {
                        verbosity: _this10.verbosity
                      });
                    })["catch"](function(reason) {
                      _this10._readyCapability.reject(new Error('Setting up fake worker failed: "'.concat(reason.message, '".')));
                    });
                  }
                }, {
                  key: "destroy",
                  value: function destroy() {
                    this.destroyed = true;
                    if (this._webWorker) {
                      this._webWorker.terminate();
                      this._webWorker = null;
                    }
                    _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts)["delete"](this._port);
                    this._port = null;
                    if (this._messageHandler) {
                      this._messageHandler.destroy();
                      this._messageHandler = null;
                    }
                  }
                }], [{
                  key: "fromPort",
                  value: function fromPort(params) {
                    if (!(params !== null && params !== void 0 && params.port)) {
                      throw new Error("PDFWorker.fromPort - invalid method signature.");
                    }
                    if (_classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).has(params.port)) {
                      return _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).get(params.port);
                    }
                    return new PDFWorker(params);
                  }
                }, {
                  key: "workerSrc",
                  get: function get2() {
                    if (_worker_options.GlobalWorkerOptions.workerSrc) {
                      return _worker_options.GlobalWorkerOptions.workerSrc;
                    }
                    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                      if (!_is_node.isNodeJS) {
                        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                      }
                      return PDFWorkerUtil.fallbackWorkerSrc;
                    }
                    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                }, {
                  key: "_mainThreadWorkerMessageHandler",
                  get: function get2() {
                    try {
                      var _globalThis$pdfjsWork;
                      return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
                    } catch (ex) {
                      return null;
                    }
                  }
                }, {
                  key: "_setupFakeWorkerGlobal",
                  get: function get() {
                    var _this11 = this;
                    var loader = /* @__PURE__ */ function() {
                      var _ref15 = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee4() {
                        var mainWorkerMessageHandler, worker;
                        return _regenerator["default"].wrap(function _callee4$(_context4) {
                          while (1) {
                            switch (_context4.prev = _context4.next) {
                              case 0:
                                mainWorkerMessageHandler = _this11._mainThreadWorkerMessageHandler;
                                if (!mainWorkerMessageHandler) {
                                  _context4.next = 3;
                                  break;
                                }
                                return _context4.abrupt("return", mainWorkerMessageHandler);
                              case 3:
                                if (!(_is_node.isNodeJS && typeof __require === "function")) {
                                  _context4.next = 6;
                                  break;
                                }
                                worker = eval("require")(_this11.workerSrc);
                                return _context4.abrupt("return", worker.WorkerMessageHandler);
                              case 6:
                                _context4.next = 8;
                                return (0, _display_utils.loadScript)(_this11.workerSrc);
                              case 8:
                                return _context4.abrupt("return", window.pdfjsWorker.WorkerMessageHandler);
                              case 9:
                              case "end":
                                return _context4.stop();
                            }
                          }
                        }, _callee4);
                      }));
                      return function loader2() {
                        return _ref15.apply(this, arguments);
                      };
                    }();
                    return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                  }
                }]);
                return PDFWorker;
              }();
              exports.PDFWorker = PDFWorker;
              var _workerPorts = {
                writable: true,
                value: /* @__PURE__ */ new WeakMap()
              };
              {
                PDFWorker.getWorkerSrc = function() {
                  (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
                  return this.workerSrc;
                };
              }
              var _docStats = /* @__PURE__ */ new WeakMap();
              var _pageCache = /* @__PURE__ */ new WeakMap();
              var _pagePromises = /* @__PURE__ */ new WeakMap();
              var _metadataPromise = /* @__PURE__ */ new WeakMap();
              var WorkerTransport = /* @__PURE__ */ function() {
                function WorkerTransport2(messageHandler, loadingTask, networkStream, params) {
                  _classCallCheck(this, WorkerTransport2);
                  _classPrivateFieldInitSpec(this, _docStats, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec(this, _pageCache, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec(this, _pagePromises, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec(this, _metadataPromise, {
                    writable: true,
                    value: null
                  });
                  this.messageHandler = messageHandler;
                  this.loadingTask = loadingTask;
                  this.commonObjs = new PDFObjects();
                  this.fontLoader = new _font_loader.FontLoader({
                    docId: loadingTask.docId,
                    onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                    ownerDocument: params.ownerDocument,
                    styleElement: params.styleElement
                  });
                  this._params = params;
                  if (!params.useWorkerFetch) {
                    this.CMapReaderFactory = new params.CMapReaderFactory({
                      baseUrl: params.cMapUrl,
                      isCompressed: params.cMapPacked
                    });
                    this.StandardFontDataFactory = new params.StandardFontDataFactory({
                      baseUrl: params.standardFontDataUrl
                    });
                  }
                  this.destroyed = false;
                  this.destroyCapability = null;
                  this._passwordCapability = null;
                  this._networkStream = networkStream;
                  this._fullReader = null;
                  this._lastProgress = null;
                  this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                  this.setupMessageHandler();
                }
                _createClass(WorkerTransport2, [{
                  key: "annotationStorage",
                  get: function get2() {
                    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                  }
                }, {
                  key: "stats",
                  get: function get2() {
                    return _classPrivateFieldGet(this, _docStats);
                  }
                }, {
                  key: "getRenderingIntent",
                  value: function getRenderingIntent(intent) {
                    var annotationMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _util.AnnotationMode.ENABLE;
                    var isOpList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    var renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                    var annotationHash = "";
                    switch (intent) {
                      case "any":
                        renderingIntent = _util.RenderingIntentFlag.ANY;
                        break;
                      case "display":
                        break;
                      case "print":
                        renderingIntent = _util.RenderingIntentFlag.PRINT;
                        break;
                      default:
                        (0, _util.warn)("getRenderingIntent - invalid intent: ".concat(intent));
                    }
                    switch (annotationMode) {
                      case _util.AnnotationMode.DISABLE:
                        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                        break;
                      case _util.AnnotationMode.ENABLE:
                        break;
                      case _util.AnnotationMode.ENABLE_FORMS:
                        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                        break;
                      case _util.AnnotationMode.ENABLE_STORAGE:
                        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                        annotationHash = this.annotationStorage.hash;
                        break;
                      default:
                        (0, _util.warn)("getRenderingIntent - invalid annotationMode: ".concat(annotationMode));
                    }
                    if (isOpList) {
                      renderingIntent += _util.RenderingIntentFlag.OPLIST;
                    }
                    return {
                      renderingIntent,
                      cacheKey: "".concat(renderingIntent, "_").concat(annotationHash)
                    };
                  }
                }, {
                  key: "destroy",
                  value: function destroy() {
                    var _this12 = this;
                    if (this.destroyCapability) {
                      return this.destroyCapability.promise;
                    }
                    this.destroyed = true;
                    this.destroyCapability = (0, _util.createPromiseCapability)();
                    if (this._passwordCapability) {
                      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                    }
                    var waitOn = [];
                    var _iterator15 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _pageCache).values()), _step15;
                    try {
                      for (_iterator15.s(); !(_step15 = _iterator15.n()).done; ) {
                        var page = _step15.value;
                        waitOn.push(page._destroy());
                      }
                    } catch (err) {
                      _iterator15.e(err);
                    } finally {
                      _iterator15.f();
                    }
                    _classPrivateFieldGet(this, _pageCache).clear();
                    _classPrivateFieldGet(this, _pagePromises).clear();
                    if (this.hasOwnProperty("annotationStorage")) {
                      this.annotationStorage.resetModified();
                    }
                    var terminated = this.messageHandler.sendWithPromise("Terminate", null);
                    waitOn.push(terminated);
                    Promise.all(waitOn).then(function() {
                      _this12.commonObjs.clear();
                      _this12.fontLoader.clear();
                      _classPrivateFieldSet(_this12, _metadataPromise, null);
                      _this12._getFieldObjectsPromise = null;
                      _this12._hasJSActionsPromise = null;
                      if (_this12._networkStream) {
                        _this12._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                      }
                      if (_this12.messageHandler) {
                        _this12.messageHandler.destroy();
                        _this12.messageHandler = null;
                      }
                      _this12.destroyCapability.resolve();
                    }, this.destroyCapability.reject);
                    return this.destroyCapability.promise;
                  }
                }, {
                  key: "setupMessageHandler",
                  value: function setupMessageHandler() {
                    var _this13 = this;
                    var messageHandler = this.messageHandler, loadingTask = this.loadingTask;
                    messageHandler.on("GetReader", function(data, sink) {
                      (0, _util.assert)(_this13._networkStream, "GetReader - no `IPDFStream` instance available.");
                      _this13._fullReader = _this13._networkStream.getFullReader();
                      _this13._fullReader.onProgress = function(evt) {
                        _this13._lastProgress = {
                          loaded: evt.loaded,
                          total: evt.total
                        };
                      };
                      sink.onPull = function() {
                        _this13._fullReader.read().then(function(_ref16) {
                          var value = _ref16.value, done = _ref16.done;
                          if (done) {
                            sink.close();
                            return;
                          }
                          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                          sink.enqueue(new Uint8Array(value), 1, [value]);
                        })["catch"](function(reason) {
                          sink.error(reason);
                        });
                      };
                      sink.onCancel = function(reason) {
                        _this13._fullReader.cancel(reason);
                        sink.ready["catch"](function(readyReason) {
                          if (_this13.destroyed) {
                            return;
                          }
                          throw readyReason;
                        });
                      };
                    });
                    messageHandler.on("ReaderHeadersReady", function(data) {
                      var headersCapability = (0, _util.createPromiseCapability)();
                      var fullReader = _this13._fullReader;
                      fullReader.headersReady.then(function() {
                        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                          if (_this13._lastProgress) {
                            var _loadingTask$onProgre;
                            (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 ? void 0 : _loadingTask$onProgre.call(loadingTask, _this13._lastProgress);
                          }
                          fullReader.onProgress = function(evt) {
                            var _loadingTask$onProgre2;
                            (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 ? void 0 : _loadingTask$onProgre2.call(loadingTask, {
                              loaded: evt.loaded,
                              total: evt.total
                            });
                          };
                        }
                        headersCapability.resolve({
                          isStreamingSupported: fullReader.isStreamingSupported,
                          isRangeSupported: fullReader.isRangeSupported,
                          contentLength: fullReader.contentLength
                        });
                      }, headersCapability.reject);
                      return headersCapability.promise;
                    });
                    messageHandler.on("GetRangeReader", function(data, sink) {
                      (0, _util.assert)(_this13._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                      var rangeReader = _this13._networkStream.getRangeReader(data.begin, data.end);
                      if (!rangeReader) {
                        sink.close();
                        return;
                      }
                      sink.onPull = function() {
                        rangeReader.read().then(function(_ref17) {
                          var value = _ref17.value, done = _ref17.done;
                          if (done) {
                            sink.close();
                            return;
                          }
                          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                          sink.enqueue(new Uint8Array(value), 1, [value]);
                        })["catch"](function(reason) {
                          sink.error(reason);
                        });
                      };
                      sink.onCancel = function(reason) {
                        rangeReader.cancel(reason);
                        sink.ready["catch"](function(readyReason) {
                          if (_this13.destroyed) {
                            return;
                          }
                          throw readyReason;
                        });
                      };
                    });
                    messageHandler.on("GetDoc", function(_ref18) {
                      var pdfInfo = _ref18.pdfInfo;
                      _this13._numPages = pdfInfo.numPages;
                      _this13._htmlForXfa = pdfInfo.htmlForXfa;
                      delete pdfInfo.htmlForXfa;
                      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this13));
                    });
                    messageHandler.on("DocException", function(ex) {
                      var reason;
                      switch (ex.name) {
                        case "PasswordException":
                          reason = new _util.PasswordException(ex.message, ex.code);
                          break;
                        case "InvalidPDFException":
                          reason = new _util.InvalidPDFException(ex.message);
                          break;
                        case "MissingPDFException":
                          reason = new _util.MissingPDFException(ex.message);
                          break;
                        case "UnexpectedResponseException":
                          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                          break;
                        case "UnknownErrorException":
                          reason = new _util.UnknownErrorException(ex.message, ex.details);
                          break;
                        default:
                          (0, _util.unreachable)("DocException - expected a valid Error.");
                      }
                      loadingTask._capability.reject(reason);
                    });
                    messageHandler.on("PasswordRequest", function(exception) {
                      _this13._passwordCapability = (0, _util.createPromiseCapability)();
                      if (loadingTask.onPassword) {
                        var updatePassword = function updatePassword2(password) {
                          if (password instanceof Error) {
                            _this13._passwordCapability.reject(password);
                          } else {
                            _this13._passwordCapability.resolve({
                              password
                            });
                          }
                        };
                        try {
                          loadingTask.onPassword(updatePassword, exception.code);
                        } catch (ex) {
                          _this13._passwordCapability.reject(ex);
                        }
                      } else {
                        _this13._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                      }
                      return _this13._passwordCapability.promise;
                    });
                    messageHandler.on("DataLoaded", function(data) {
                      var _loadingTask$onProgre3;
                      (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 ? void 0 : _loadingTask$onProgre3.call(loadingTask, {
                        loaded: data.length,
                        total: data.length
                      });
                      _this13.downloadInfoCapability.resolve(data);
                    });
                    messageHandler.on("StartRenderPage", function(data) {
                      if (_this13.destroyed) {
                        return;
                      }
                      var page = _classPrivateFieldGet(_this13, _pageCache).get(data.pageIndex);
                      page._startRenderPage(data.transparency, data.cacheKey);
                    });
                    messageHandler.on("commonobj", function(_ref19) {
                      var _globalThis$FontInspe;
                      var _ref20 = _slicedToArray(_ref19, 3), id = _ref20[0], type = _ref20[1], exportedData = _ref20[2];
                      if (_this13.destroyed) {
                        return;
                      }
                      if (_this13.commonObjs.has(id)) {
                        return;
                      }
                      switch (type) {
                        case "Font":
                          var params = _this13._params;
                          if ("error" in exportedData) {
                            var exportedError = exportedData.error;
                            (0, _util.warn)("Error during font loading: ".concat(exportedError));
                            _this13.commonObjs.resolve(id, exportedError);
                            break;
                          }
                          var fontRegistry = null;
                          if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
                            fontRegistry = {
                              registerFont: function registerFont(font2, url) {
                                globalThis.FontInspector.fontAdded(font2, url);
                              }
                            };
                          }
                          var font = new _font_loader.FontFaceObject(exportedData, {
                            isEvalSupported: params.isEvalSupported,
                            disableFontFace: params.disableFontFace,
                            ignoreErrors: params.ignoreErrors,
                            onUnsupportedFeature: _this13._onUnsupportedFeature.bind(_this13),
                            fontRegistry
                          });
                          _this13.fontLoader.bind(font)["catch"](function(reason) {
                            return messageHandler.sendWithPromise("FontFallback", {
                              id
                            });
                          })["finally"](function() {
                            if (!params.fontExtraProperties && font.data) {
                              font.data = null;
                            }
                            _this13.commonObjs.resolve(id, font);
                          });
                          break;
                        case "FontPath":
                        case "Image":
                          _this13.commonObjs.resolve(id, exportedData);
                          break;
                        default:
                          throw new Error("Got unknown common object type ".concat(type));
                      }
                    });
                    messageHandler.on("obj", function(_ref21) {
                      var _ref22 = _slicedToArray(_ref21, 4), id = _ref22[0], pageIndex = _ref22[1], type = _ref22[2], imageData = _ref22[3];
                      if (_this13.destroyed) {
                        return;
                      }
                      var pageProxy = _classPrivateFieldGet(_this13, _pageCache).get(pageIndex);
                      if (pageProxy.objs.has(id)) {
                        return;
                      }
                      switch (type) {
                        case "Image":
                          pageProxy.objs.resolve(id, imageData);
                          var MAX_IMAGE_SIZE_TO_STORE = 8e6;
                          if (imageData) {
                            var length;
                            if (imageData.bitmap) {
                              var bitmap = imageData.bitmap, width = imageData.width, height = imageData.height;
                              length = width * height * 4;
                              pageProxy._bitmaps.add(bitmap);
                            } else {
                              var _imageData$data;
                              length = ((_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) || 0;
                            }
                            if (length > MAX_IMAGE_SIZE_TO_STORE) {
                              pageProxy.cleanupAfterRender = true;
                            }
                          }
                          break;
                        case "Pattern":
                          pageProxy.objs.resolve(id, imageData);
                          break;
                        default:
                          throw new Error("Got unknown object type ".concat(type));
                      }
                    });
                    messageHandler.on("DocProgress", function(data) {
                      var _loadingTask$onProgre4;
                      if (_this13.destroyed) {
                        return;
                      }
                      (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 ? void 0 : _loadingTask$onProgre4.call(loadingTask, {
                        loaded: data.loaded,
                        total: data.total
                      });
                    });
                    messageHandler.on("DocStats", function(data) {
                      if (_this13.destroyed) {
                        return;
                      }
                      _classPrivateFieldSet(_this13, _docStats, Object.freeze({
                        streamTypes: Object.freeze(data.streamTypes),
                        fontTypes: Object.freeze(data.fontTypes)
                      }));
                    });
                    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                    messageHandler.on("FetchBuiltInCMap", function(data) {
                      if (_this13.destroyed) {
                        return Promise.reject(new Error("Worker was destroyed."));
                      }
                      if (!_this13.CMapReaderFactory) {
                        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                      }
                      return _this13.CMapReaderFactory.fetch(data);
                    });
                    messageHandler.on("FetchStandardFontData", function(data) {
                      if (_this13.destroyed) {
                        return Promise.reject(new Error("Worker was destroyed."));
                      }
                      if (!_this13.StandardFontDataFactory) {
                        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                      }
                      return _this13.StandardFontDataFactory.fetch(data);
                    });
                  }
                }, {
                  key: "_onUnsupportedFeature",
                  value: function _onUnsupportedFeature(_ref23) {
                    var _this$loadingTask$onU, _this$loadingTask;
                    var featureId = _ref23.featureId;
                    if (this.destroyed) {
                      return;
                    }
                    (_this$loadingTask$onU = (_this$loadingTask = this.loadingTask).onUnsupportedFeature) === null || _this$loadingTask$onU === void 0 ? void 0 : _this$loadingTask$onU.call(_this$loadingTask, featureId);
                  }
                }, {
                  key: "getData",
                  value: function getData() {
                    return this.messageHandler.sendWithPromise("GetData", null);
                  }
                }, {
                  key: "getPage",
                  value: function getPage(pageNumber) {
                    var _this14 = this;
                    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                      return Promise.reject(new Error("Invalid page request."));
                    }
                    var pageIndex = pageNumber - 1, cachedPromise = _classPrivateFieldGet(this, _pagePromises).get(pageIndex);
                    if (cachedPromise) {
                      return cachedPromise;
                    }
                    var promise = this.messageHandler.sendWithPromise("GetPage", {
                      pageIndex
                    }).then(function(pageInfo) {
                      if (_this14.destroyed) {
                        throw new Error("Transport destroyed");
                      }
                      var page = new PDFPageProxy(pageIndex, pageInfo, _this14, _this14._params.ownerDocument, _this14._params.pdfBug);
                      _classPrivateFieldGet(_this14, _pageCache).set(pageIndex, page);
                      return page;
                    });
                    _classPrivateFieldGet(this, _pagePromises).set(pageIndex, promise);
                    return promise;
                  }
                }, {
                  key: "getPageIndex",
                  value: function getPageIndex(ref) {
                    if (_typeof(ref) !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                      return Promise.reject(new Error("Invalid pageIndex request."));
                    }
                    return this.messageHandler.sendWithPromise("GetPageIndex", {
                      num: ref.num,
                      gen: ref.gen
                    });
                  }
                }, {
                  key: "getAnnotations",
                  value: function getAnnotations(pageIndex, intent) {
                    return this.messageHandler.sendWithPromise("GetAnnotations", {
                      pageIndex,
                      intent
                    });
                  }
                }, {
                  key: "saveDocument",
                  value: function saveDocument() {
                    var _this$_fullReader$fil, _this$_fullReader, _this15 = this;
                    return this.messageHandler.sendWithPromise("SaveDocument", {
                      isPureXfa: !!this._htmlForXfa,
                      numPages: this._numPages,
                      annotationStorage: this.annotationStorage.serializable,
                      filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
                    })["finally"](function() {
                      _this15.annotationStorage.resetModified();
                    });
                  }
                }, {
                  key: "getFieldObjects",
                  value: function getFieldObjects() {
                    return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
                  }
                }, {
                  key: "hasJSActions",
                  value: function hasJSActions() {
                    return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
                  }
                }, {
                  key: "getCalculationOrderIds",
                  value: function getCalculationOrderIds() {
                    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                  }
                }, {
                  key: "getDestinations",
                  value: function getDestinations() {
                    return this.messageHandler.sendWithPromise("GetDestinations", null);
                  }
                }, {
                  key: "getDestination",
                  value: function getDestination(id) {
                    if (typeof id !== "string") {
                      return Promise.reject(new Error("Invalid destination request."));
                    }
                    return this.messageHandler.sendWithPromise("GetDestination", {
                      id
                    });
                  }
                }, {
                  key: "getPageLabels",
                  value: function getPageLabels() {
                    return this.messageHandler.sendWithPromise("GetPageLabels", null);
                  }
                }, {
                  key: "getPageLayout",
                  value: function getPageLayout() {
                    return this.messageHandler.sendWithPromise("GetPageLayout", null);
                  }
                }, {
                  key: "getPageMode",
                  value: function getPageMode() {
                    return this.messageHandler.sendWithPromise("GetPageMode", null);
                  }
                }, {
                  key: "getViewerPreferences",
                  value: function getViewerPreferences() {
                    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                  }
                }, {
                  key: "getOpenAction",
                  value: function getOpenAction() {
                    return this.messageHandler.sendWithPromise("GetOpenAction", null);
                  }
                }, {
                  key: "getAttachments",
                  value: function getAttachments() {
                    return this.messageHandler.sendWithPromise("GetAttachments", null);
                  }
                }, {
                  key: "getJavaScript",
                  value: function getJavaScript() {
                    return this.messageHandler.sendWithPromise("GetJavaScript", null);
                  }
                }, {
                  key: "getDocJSActions",
                  value: function getDocJSActions() {
                    return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                  }
                }, {
                  key: "getPageJSActions",
                  value: function getPageJSActions(pageIndex) {
                    return this.messageHandler.sendWithPromise("GetPageJSActions", {
                      pageIndex
                    });
                  }
                }, {
                  key: "getStructTree",
                  value: function getStructTree(pageIndex) {
                    return this.messageHandler.sendWithPromise("GetStructTree", {
                      pageIndex
                    });
                  }
                }, {
                  key: "getOutline",
                  value: function getOutline() {
                    return this.messageHandler.sendWithPromise("GetOutline", null);
                  }
                }, {
                  key: "getOptionalContentConfig",
                  value: function getOptionalContentConfig() {
                    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(function(results) {
                      return new _optional_content_config.OptionalContentConfig(results);
                    });
                  }
                }, {
                  key: "getPermissions",
                  value: function getPermissions() {
                    return this.messageHandler.sendWithPromise("GetPermissions", null);
                  }
                }, {
                  key: "getMetadata",
                  value: function getMetadata() {
                    var _this16 = this;
                    return _classPrivateFieldGet(this, _metadataPromise) || _classPrivateFieldSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then(function(results) {
                      var _this16$_fullReader$f, _this16$_fullReader, _this16$_fullReader$c, _this16$_fullReader2;
                      return {
                        info: results[0],
                        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                        contentDispositionFilename: (_this16$_fullReader$f = (_this16$_fullReader = _this16._fullReader) === null || _this16$_fullReader === void 0 ? void 0 : _this16$_fullReader.filename) !== null && _this16$_fullReader$f !== void 0 ? _this16$_fullReader$f : null,
                        contentLength: (_this16$_fullReader$c = (_this16$_fullReader2 = _this16._fullReader) === null || _this16$_fullReader2 === void 0 ? void 0 : _this16$_fullReader2.contentLength) !== null && _this16$_fullReader$c !== void 0 ? _this16$_fullReader$c : null
                      };
                    }));
                  }
                }, {
                  key: "getMarkInfo",
                  value: function getMarkInfo() {
                    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                  }
                }, {
                  key: "startCleanup",
                  value: function() {
                    var _startCleanup = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee5() {
                      var keepLoadedFonts, _iterator16, _step16, page, cleanupSuccessful, _args5 = arguments;
                      return _regenerator["default"].wrap(function _callee5$(_context5) {
                        while (1) {
                          switch (_context5.prev = _context5.next) {
                            case 0:
                              keepLoadedFonts = _args5.length > 0 && _args5[0] !== void 0 ? _args5[0] : false;
                              _context5.next = 3;
                              return this.messageHandler.sendWithPromise("Cleanup", null);
                            case 3:
                              if (!this.destroyed) {
                                _context5.next = 5;
                                break;
                              }
                              return _context5.abrupt("return");
                            case 5:
                              _iterator16 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _pageCache).values());
                              _context5.prev = 6;
                              _iterator16.s();
                            case 8:
                              if ((_step16 = _iterator16.n()).done) {
                                _context5.next = 15;
                                break;
                              }
                              page = _step16.value;
                              cleanupSuccessful = page.cleanup();
                              if (cleanupSuccessful) {
                                _context5.next = 13;
                                break;
                              }
                              throw new Error("startCleanup: Page ".concat(page.pageNumber, " is currently rendering."));
                            case 13:
                              _context5.next = 8;
                              break;
                            case 15:
                              _context5.next = 20;
                              break;
                            case 17:
                              _context5.prev = 17;
                              _context5.t0 = _context5["catch"](6);
                              _iterator16.e(_context5.t0);
                            case 20:
                              _context5.prev = 20;
                              _iterator16.f();
                              return _context5.finish(20);
                            case 23:
                              this.commonObjs.clear();
                              if (!keepLoadedFonts) {
                                this.fontLoader.clear();
                              }
                              _classPrivateFieldSet(this, _metadataPromise, null);
                              this._getFieldObjectsPromise = null;
                              this._hasJSActionsPromise = null;
                            case 28:
                            case "end":
                              return _context5.stop();
                          }
                        }
                      }, _callee5, this, [[6, 17, 20, 23]]);
                    }));
                    function startCleanup() {
                      return _startCleanup.apply(this, arguments);
                    }
                    return startCleanup;
                  }()
                }, {
                  key: "loadingParams",
                  get: function get2() {
                    var params = this._params;
                    return (0, _util.shadow)(this, "loadingParams", {
                      disableAutoFetch: params.disableAutoFetch,
                      enableXfa: params.enableXfa
                    });
                  }
                }]);
                return WorkerTransport2;
              }();
              var _objs = /* @__PURE__ */ new WeakMap();
              var _ensureObj = /* @__PURE__ */ new WeakSet();
              var PDFObjects = /* @__PURE__ */ function() {
                function PDFObjects2() {
                  _classCallCheck(this, PDFObjects2);
                  _classPrivateMethodInitSpec(this, _ensureObj);
                  _classPrivateFieldInitSpec(this, _objs, {
                    writable: true,
                    value: /* @__PURE__ */ Object.create(null)
                  });
                }
                _createClass(PDFObjects2, [{
                  key: "get",
                  value: function get2(objId) {
                    var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    if (callback) {
                      var _obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);
                      _obj.capability.promise.then(function() {
                        return callback(_obj.data);
                      });
                      return null;
                    }
                    var obj = _classPrivateFieldGet(this, _objs)[objId];
                    if (!(obj !== null && obj !== void 0 && obj.capability.settled)) {
                      throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
                    }
                    return obj.data;
                  }
                }, {
                  key: "has",
                  value: function has(objId) {
                    var obj = _classPrivateFieldGet(this, _objs)[objId];
                    return (obj === null || obj === void 0 ? void 0 : obj.capability.settled) || false;
                  }
                }, {
                  key: "resolve",
                  value: function resolve(objId) {
                    var data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    var obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);
                    obj.data = data;
                    obj.capability.resolve();
                  }
                }, {
                  key: "clear",
                  value: function clear() {
                    _classPrivateFieldSet(this, _objs, /* @__PURE__ */ Object.create(null));
                  }
                }]);
                return PDFObjects2;
              }();
              function _ensureObj2(objId) {
                var obj = _classPrivateFieldGet(this, _objs)[objId];
                if (obj) {
                  return obj;
                }
                return _classPrivateFieldGet(this, _objs)[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null
                };
              }
              var RenderTask = /* @__PURE__ */ function() {
                function RenderTask2(internalRenderTask) {
                  _classCallCheck(this, RenderTask2);
                  this._internalRenderTask = internalRenderTask;
                  this.onContinue = null;
                }
                _createClass(RenderTask2, [{
                  key: "promise",
                  get: function get2() {
                    return this._internalRenderTask.capability.promise;
                  }
                }, {
                  key: "cancel",
                  value: function cancel() {
                    this._internalRenderTask.cancel();
                  }
                }]);
                return RenderTask2;
              }();
              exports.RenderTask = RenderTask;
              var InternalRenderTask = /* @__PURE__ */ function() {
                function InternalRenderTask2(_ref24) {
                  var callback = _ref24.callback, params = _ref24.params, objs = _ref24.objs, commonObjs = _ref24.commonObjs, annotationCanvasMap = _ref24.annotationCanvasMap, operatorList = _ref24.operatorList, pageIndex = _ref24.pageIndex, canvasFactory = _ref24.canvasFactory, _ref24$useRequestAnim = _ref24.useRequestAnimationFrame, useRequestAnimationFrame = _ref24$useRequestAnim === void 0 ? false : _ref24$useRequestAnim, _ref24$pdfBug = _ref24.pdfBug, pdfBug = _ref24$pdfBug === void 0 ? false : _ref24$pdfBug, _ref24$pageColors = _ref24.pageColors, pageColors = _ref24$pageColors === void 0 ? null : _ref24$pageColors;
                  _classCallCheck(this, InternalRenderTask2);
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this._pdfBug = pdfBug;
                  this.pageColors = pageColors;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                _createClass(InternalRenderTask2, [{
                  key: "completed",
                  get: function get2() {
                    return this.capability.promise["catch"](function() {
                    });
                  }
                }, {
                  key: "initializeGraphics",
                  value: function initializeGraphics(_ref25) {
                    var _globalThis$StepperMa;
                    var _ref25$transparency = _ref25.transparency, transparency = _ref25$transparency === void 0 ? false : _ref25$transparency, optionalContentConfig = _ref25.optionalContentConfig;
                    if (this.cancelled) {
                      return;
                    }
                    if (this._canvas) {
                      if (_classStaticPrivateFieldSpecGet(InternalRenderTask2, InternalRenderTask2, _canvasInUse).has(this._canvas)) {
                        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                      }
                      _classStaticPrivateFieldSpecGet(InternalRenderTask2, InternalRenderTask2, _canvasInUse).add(this._canvas);
                    }
                    if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
                      this.stepper = globalThis.StepperManager.create(this._pageIndex);
                      this.stepper.init(this.operatorList);
                      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                    }
                    var _this$params = this.params, canvasContext = _this$params.canvasContext, viewport = _this$params.viewport, transform = _this$params.transform, imageLayer = _this$params.imageLayer, background = _this$params.background;
                    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
                    this.gfx.beginDrawing({
                      transform,
                      viewport,
                      transparency,
                      background
                    });
                    this.operatorListIdx = 0;
                    this.graphicsReady = true;
                    if (this.graphicsReadyCallback) {
                      this.graphicsReadyCallback();
                    }
                  }
                }, {
                  key: "cancel",
                  value: function cancel() {
                    var error = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                    this.running = false;
                    this.cancelled = true;
                    if (this.gfx) {
                      this.gfx.endDrawing();
                    }
                    if (this._canvas) {
                      _classStaticPrivateFieldSpecGet(InternalRenderTask2, InternalRenderTask2, _canvasInUse)["delete"](this._canvas);
                    }
                    this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas"));
                  }
                }, {
                  key: "operatorListChanged",
                  value: function operatorListChanged() {
                    if (!this.graphicsReady) {
                      if (!this.graphicsReadyCallback) {
                        this.graphicsReadyCallback = this._continueBound;
                      }
                      return;
                    }
                    if (this.stepper) {
                      this.stepper.updateOperatorList(this.operatorList);
                    }
                    if (this.running) {
                      return;
                    }
                    this._continue();
                  }
                }, {
                  key: "_continue",
                  value: function _continue() {
                    this.running = true;
                    if (this.cancelled) {
                      return;
                    }
                    if (this.task.onContinue) {
                      this.task.onContinue(this._scheduleNextBound);
                    } else {
                      this._scheduleNext();
                    }
                  }
                }, {
                  key: "_scheduleNext",
                  value: function _scheduleNext() {
                    var _this17 = this;
                    if (this._useRequestAnimationFrame) {
                      window.requestAnimationFrame(function() {
                        _this17._nextBound()["catch"](_this17._cancelBound);
                      });
                    } else {
                      Promise.resolve().then(this._nextBound)["catch"](this._cancelBound);
                    }
                  }
                }, {
                  key: "_next",
                  value: function() {
                    var _next2 = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee6() {
                      return _regenerator["default"].wrap(function _callee6$(_context6) {
                        while (1) {
                          switch (_context6.prev = _context6.next) {
                            case 0:
                              if (!this.cancelled) {
                                _context6.next = 2;
                                break;
                              }
                              return _context6.abrupt("return");
                            case 2:
                              this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                              if (this.operatorListIdx === this.operatorList.argsArray.length) {
                                this.running = false;
                                if (this.operatorList.lastChunk) {
                                  this.gfx.endDrawing();
                                  if (this._canvas) {
                                    _classStaticPrivateFieldSpecGet(InternalRenderTask2, InternalRenderTask2, _canvasInUse)["delete"](this._canvas);
                                  }
                                  this.callback();
                                }
                              }
                            case 4:
                            case "end":
                              return _context6.stop();
                          }
                        }
                      }, _callee6, this);
                    }));
                    function _next() {
                      return _next2.apply(this, arguments);
                    }
                    return _next;
                  }()
                }]);
                return InternalRenderTask2;
              }();
              var _canvasInUse = {
                writable: true,
                value: /* @__PURE__ */ new WeakSet()
              };
              var version = "2.14.305";
              exports.version = version;
              var build = "eaaa8b4ad";
              exports.build = build;
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              module2.exports = __w_pdfjs_require__2(157);
            },
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              module2 = __w_pdfjs_require__2.nmd(module2);
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              var runtime = function(exports2) {
                "use strict";
                var Op = Object.prototype;
                var hasOwn = Op.hasOwnProperty;
                var undefined2;
                var $Symbol = typeof Symbol === "function" ? Symbol : {};
                var iteratorSymbol = $Symbol.iterator || "@@iterator";
                var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
                var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
                function define2(obj, key, value) {
                  Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                  return obj[key];
                }
                try {
                  define2({}, "");
                } catch (err) {
                  define2 = function define3(obj, key, value) {
                    return obj[key] = value;
                  };
                }
                function wrap(innerFn, outerFn, self2, tryLocsList) {
                  var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
                  var generator = Object.create(protoGenerator.prototype);
                  var context = new Context(tryLocsList || []);
                  generator._invoke = makeInvokeMethod(innerFn, self2, context);
                  return generator;
                }
                exports2.wrap = wrap;
                function tryCatch(fn, obj, arg) {
                  try {
                    return {
                      type: "normal",
                      arg: fn.call(obj, arg)
                    };
                  } catch (err) {
                    return {
                      type: "throw",
                      arg: err
                    };
                  }
                }
                var GenStateSuspendedStart = "suspendedStart";
                var GenStateSuspendedYield = "suspendedYield";
                var GenStateExecuting = "executing";
                var GenStateCompleted = "completed";
                var ContinueSentinel = {};
                function Generator() {
                }
                function GeneratorFunction() {
                }
                function GeneratorFunctionPrototype() {
                }
                var IteratorPrototype = {};
                define2(IteratorPrototype, iteratorSymbol, function() {
                  return this;
                });
                var getProto = Object.getPrototypeOf;
                var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
                  IteratorPrototype = NativeIteratorPrototype;
                }
                var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
                GeneratorFunction.prototype = GeneratorFunctionPrototype;
                define2(Gp, "constructor", GeneratorFunctionPrototype);
                define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
                GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
                function defineIteratorMethods(prototype) {
                  ["next", "throw", "return"].forEach(function(method) {
                    define2(prototype, method, function(arg) {
                      return this._invoke(method, arg);
                    });
                  });
                }
                exports2.isGeneratorFunction = function(genFun) {
                  var ctor = typeof genFun === "function" && genFun.constructor;
                  return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
                };
                exports2.mark = function(genFun) {
                  if (Object.setPrototypeOf) {
                    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
                  } else {
                    genFun.__proto__ = GeneratorFunctionPrototype;
                    define2(genFun, toStringTagSymbol, "GeneratorFunction");
                  }
                  genFun.prototype = Object.create(Gp);
                  return genFun;
                };
                exports2.awrap = function(arg) {
                  return {
                    __await: arg
                  };
                };
                function AsyncIterator(generator, PromiseImpl) {
                  function invoke(method, arg, resolve, reject) {
                    var record = tryCatch(generator[method], generator, arg);
                    if (record.type === "throw") {
                      reject(record.arg);
                    } else {
                      var result = record.arg;
                      var value = result.value;
                      if (value && _typeof2(value) === "object" && hasOwn.call(value, "__await")) {
                        return PromiseImpl.resolve(value.__await).then(function(value2) {
                          invoke("next", value2, resolve, reject);
                        }, function(err) {
                          invoke("throw", err, resolve, reject);
                        });
                      }
                      return PromiseImpl.resolve(value).then(function(unwrapped) {
                        result.value = unwrapped;
                        resolve(result);
                      }, function(error) {
                        return invoke("throw", error, resolve, reject);
                      });
                    }
                  }
                  var previousPromise;
                  function enqueue(method, arg) {
                    function callInvokeWithMethodAndArg() {
                      return new PromiseImpl(function(resolve, reject) {
                        invoke(method, arg, resolve, reject);
                      });
                    }
                    return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                  }
                  this._invoke = enqueue;
                }
                defineIteratorMethods(AsyncIterator.prototype);
                define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
                  return this;
                });
                exports2.AsyncIterator = AsyncIterator;
                exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
                  if (PromiseImpl === void 0)
                    PromiseImpl = Promise;
                  var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
                  return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                    return result.done ? result.value : iter.next();
                  });
                };
                function makeInvokeMethod(innerFn, self2, context) {
                  var state = GenStateSuspendedStart;
                  return function invoke(method, arg) {
                    if (state === GenStateExecuting) {
                      throw new Error("Generator is already running");
                    }
                    if (state === GenStateCompleted) {
                      if (method === "throw") {
                        throw arg;
                      }
                      return doneResult();
                    }
                    context.method = method;
                    context.arg = arg;
                    while (true) {
                      var delegate = context.delegate;
                      if (delegate) {
                        var delegateResult = maybeInvokeDelegate(delegate, context);
                        if (delegateResult) {
                          if (delegateResult === ContinueSentinel)
                            continue;
                          return delegateResult;
                        }
                      }
                      if (context.method === "next") {
                        context.sent = context._sent = context.arg;
                      } else if (context.method === "throw") {
                        if (state === GenStateSuspendedStart) {
                          state = GenStateCompleted;
                          throw context.arg;
                        }
                        context.dispatchException(context.arg);
                      } else if (context.method === "return") {
                        context.abrupt("return", context.arg);
                      }
                      state = GenStateExecuting;
                      var record = tryCatch(innerFn, self2, context);
                      if (record.type === "normal") {
                        state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                        if (record.arg === ContinueSentinel) {
                          continue;
                        }
                        return {
                          value: record.arg,
                          done: context.done
                        };
                      } else if (record.type === "throw") {
                        state = GenStateCompleted;
                        context.method = "throw";
                        context.arg = record.arg;
                      }
                    }
                  };
                }
                function maybeInvokeDelegate(delegate, context) {
                  var method = delegate.iterator[context.method];
                  if (method === undefined2) {
                    context.delegate = null;
                    if (context.method === "throw") {
                      if (delegate.iterator["return"]) {
                        context.method = "return";
                        context.arg = undefined2;
                        maybeInvokeDelegate(delegate, context);
                        if (context.method === "throw") {
                          return ContinueSentinel;
                        }
                      }
                      context.method = "throw";
                      context.arg = new TypeError("The iterator does not provide a 'throw' method");
                    }
                    return ContinueSentinel;
                  }
                  var record = tryCatch(method, delegate.iterator, context.arg);
                  if (record.type === "throw") {
                    context.method = "throw";
                    context.arg = record.arg;
                    context.delegate = null;
                    return ContinueSentinel;
                  }
                  var info = record.arg;
                  if (!info) {
                    context.method = "throw";
                    context.arg = new TypeError("iterator result is not an object");
                    context.delegate = null;
                    return ContinueSentinel;
                  }
                  if (info.done) {
                    context[delegate.resultName] = info.value;
                    context.next = delegate.nextLoc;
                    if (context.method !== "return") {
                      context.method = "next";
                      context.arg = undefined2;
                    }
                  } else {
                    return info;
                  }
                  context.delegate = null;
                  return ContinueSentinel;
                }
                defineIteratorMethods(Gp);
                define2(Gp, toStringTagSymbol, "Generator");
                define2(Gp, iteratorSymbol, function() {
                  return this;
                });
                define2(Gp, "toString", function() {
                  return "[object Generator]";
                });
                function pushTryEntry(locs) {
                  var entry = {
                    tryLoc: locs[0]
                  };
                  if (1 in locs) {
                    entry.catchLoc = locs[1];
                  }
                  if (2 in locs) {
                    entry.finallyLoc = locs[2];
                    entry.afterLoc = locs[3];
                  }
                  this.tryEntries.push(entry);
                }
                function resetTryEntry(entry) {
                  var record = entry.completion || {};
                  record.type = "normal";
                  delete record.arg;
                  entry.completion = record;
                }
                function Context(tryLocsList) {
                  this.tryEntries = [{
                    tryLoc: "root"
                  }];
                  tryLocsList.forEach(pushTryEntry, this);
                  this.reset(true);
                }
                exports2.keys = function(object) {
                  var keys = [];
                  for (var key in object) {
                    keys.push(key);
                  }
                  keys.reverse();
                  return function next() {
                    while (keys.length) {
                      var key2 = keys.pop();
                      if (key2 in object) {
                        next.value = key2;
                        next.done = false;
                        return next;
                      }
                    }
                    next.done = true;
                    return next;
                  };
                };
                function values(iterable) {
                  if (iterable) {
                    var iteratorMethod = iterable[iteratorSymbol];
                    if (iteratorMethod) {
                      return iteratorMethod.call(iterable);
                    }
                    if (typeof iterable.next === "function") {
                      return iterable;
                    }
                    if (!isNaN(iterable.length)) {
                      var i = -1, next = function next2() {
                        while (++i < iterable.length) {
                          if (hasOwn.call(iterable, i)) {
                            next2.value = iterable[i];
                            next2.done = false;
                            return next2;
                          }
                        }
                        next2.value = undefined2;
                        next2.done = true;
                        return next2;
                      };
                      return next.next = next;
                    }
                  }
                  return {
                    next: doneResult
                  };
                }
                exports2.values = values;
                function doneResult() {
                  return {
                    value: undefined2,
                    done: true
                  };
                }
                Context.prototype = {
                  constructor: Context,
                  reset: function reset(skipTempReset) {
                    this.prev = 0;
                    this.next = 0;
                    this.sent = this._sent = undefined2;
                    this.done = false;
                    this.delegate = null;
                    this.method = "next";
                    this.arg = undefined2;
                    this.tryEntries.forEach(resetTryEntry);
                    if (!skipTempReset) {
                      for (var name in this) {
                        if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                          this[name] = undefined2;
                        }
                      }
                    }
                  },
                  stop: function stop() {
                    this.done = true;
                    var rootEntry = this.tryEntries[0];
                    var rootRecord = rootEntry.completion;
                    if (rootRecord.type === "throw") {
                      throw rootRecord.arg;
                    }
                    return this.rval;
                  },
                  dispatchException: function dispatchException(exception) {
                    if (this.done) {
                      throw exception;
                    }
                    var context = this;
                    function handle(loc, caught) {
                      record.type = "throw";
                      record.arg = exception;
                      context.next = loc;
                      if (caught) {
                        context.method = "next";
                        context.arg = undefined2;
                      }
                      return !!caught;
                    }
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i];
                      var record = entry.completion;
                      if (entry.tryLoc === "root") {
                        return handle("end");
                      }
                      if (entry.tryLoc <= this.prev) {
                        var hasCatch = hasOwn.call(entry, "catchLoc");
                        var hasFinally = hasOwn.call(entry, "finallyLoc");
                        if (hasCatch && hasFinally) {
                          if (this.prev < entry.catchLoc) {
                            return handle(entry.catchLoc, true);
                          } else if (this.prev < entry.finallyLoc) {
                            return handle(entry.finallyLoc);
                          }
                        } else if (hasCatch) {
                          if (this.prev < entry.catchLoc) {
                            return handle(entry.catchLoc, true);
                          }
                        } else if (hasFinally) {
                          if (this.prev < entry.finallyLoc) {
                            return handle(entry.finallyLoc);
                          }
                        } else {
                          throw new Error("try statement without catch or finally");
                        }
                      }
                    }
                  },
                  abrupt: function abrupt(type, arg) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i];
                      if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                        var finallyEntry = entry;
                        break;
                      }
                    }
                    if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                      finallyEntry = null;
                    }
                    var record = finallyEntry ? finallyEntry.completion : {};
                    record.type = type;
                    record.arg = arg;
                    if (finallyEntry) {
                      this.method = "next";
                      this.next = finallyEntry.finallyLoc;
                      return ContinueSentinel;
                    }
                    return this.complete(record);
                  },
                  complete: function complete(record, afterLoc) {
                    if (record.type === "throw") {
                      throw record.arg;
                    }
                    if (record.type === "break" || record.type === "continue") {
                      this.next = record.arg;
                    } else if (record.type === "return") {
                      this.rval = this.arg = record.arg;
                      this.method = "return";
                      this.next = "end";
                    } else if (record.type === "normal" && afterLoc) {
                      this.next = afterLoc;
                    }
                    return ContinueSentinel;
                  },
                  finish: function finish(finallyLoc) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i];
                      if (entry.finallyLoc === finallyLoc) {
                        this.complete(entry.completion, entry.afterLoc);
                        resetTryEntry(entry);
                        return ContinueSentinel;
                      }
                    }
                  },
                  "catch": function _catch(tryLoc) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i];
                      if (entry.tryLoc === tryLoc) {
                        var record = entry.completion;
                        if (record.type === "throw") {
                          var thrown = record.arg;
                          resetTryEntry(entry);
                        }
                        return thrown;
                      }
                    }
                    throw new Error("illegal catch attempt");
                  },
                  delegateYield: function delegateYield(iterable, resultName, nextLoc) {
                    this.delegate = {
                      iterator: values(iterable),
                      resultName,
                      nextLoc
                    };
                    if (this.method === "next") {
                      this.arg = undefined2;
                    }
                    return ContinueSentinel;
                  }
                };
                return exports2;
              }((false ? 0 : _typeof2(module2)) === "object" ? module2.exports : {});
              try {
                regeneratorRuntime = runtime;
              } catch (accidentalStrictMode) {
                if ((typeof globalThis === "undefined" ? "undefined" : _typeof2(globalThis)) === "object") {
                  globalThis.regeneratorRuntime = runtime;
                } else {
                  Function("r", "regeneratorRuntime = r")(runtime);
                }
              }
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = void 0;
              exports2.deprecated = deprecated;
              exports2.getFilenameFromUrl = getFilenameFromUrl;
              exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
              exports2.getXfaPageViewport = getXfaPageViewport;
              exports2.isDataScheme = isDataScheme;
              exports2.isPdfFile = isPdfFile;
              exports2.isValidFetchUrl = isValidFetchUrl;
              exports2.loadScript = loadScript;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _base_factory = __w_pdfjs_require__2(159);
              var _util2 = __w_pdfjs_require__2(1);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              var SVG_NS = "http://www.w3.org/2000/svg";
              var PixelsPerInch = /* @__PURE__ */ _createClass2(function PixelsPerInch2() {
                _classCallCheck2(this, PixelsPerInch2);
              });
              exports2.PixelsPerInch = PixelsPerInch;
              _defineProperty(PixelsPerInch, "CSS", 96);
              _defineProperty(PixelsPerInch, "PDF", 72);
              _defineProperty(PixelsPerInch, "PDF_TO_CSS_UNITS", PixelsPerInch.CSS / PixelsPerInch.PDF);
              var DOMCanvasFactory = /* @__PURE__ */ function(_BaseCanvasFactory) {
                _inherits(DOMCanvasFactory2, _BaseCanvasFactory);
                var _super = _createSuper(DOMCanvasFactory2);
                function DOMCanvasFactory2() {
                  var _this;
                  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$ownerDocument = _ref.ownerDocument, ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;
                  _classCallCheck2(this, DOMCanvasFactory2);
                  _this = _super.call(this);
                  _this._document = ownerDocument;
                  return _this;
                }
                _createClass2(DOMCanvasFactory2, [{
                  key: "_createCanvas",
                  value: function _createCanvas(width, height) {
                    var canvas = this._document.createElement("canvas");
                    canvas.width = width;
                    canvas.height = height;
                    return canvas;
                  }
                }]);
                return DOMCanvasFactory2;
              }(_base_factory.BaseCanvasFactory);
              exports2.DOMCanvasFactory = DOMCanvasFactory;
              function fetchData(_x) {
                return _fetchData.apply(this, arguments);
              }
              function _fetchData() {
                _fetchData = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee(url) {
                  var asTypedArray, response, _args = arguments;
                  return _regenerator2["default"].wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          asTypedArray = _args.length > 1 && _args[1] !== void 0 ? _args[1] : false;
                          if (!isValidFetchUrl(url, document.baseURI)) {
                            _context.next = 21;
                            break;
                          }
                          _context.next = 4;
                          return fetch(url);
                        case 4:
                          response = _context.sent;
                          if (response.ok) {
                            _context.next = 7;
                            break;
                          }
                          throw new Error(response.statusText);
                        case 7:
                          if (!asTypedArray) {
                            _context.next = 15;
                            break;
                          }
                          _context.t1 = Uint8Array;
                          _context.next = 11;
                          return response.arrayBuffer();
                        case 11:
                          _context.t2 = _context.sent;
                          _context.t0 = new _context.t1(_context.t2);
                          _context.next = 20;
                          break;
                        case 15:
                          _context.t3 = _util2.stringToBytes;
                          _context.next = 18;
                          return response.text();
                        case 18:
                          _context.t4 = _context.sent;
                          _context.t0 = (0, _context.t3)(_context.t4);
                        case 20:
                          return _context.abrupt("return", _context.t0);
                        case 21:
                          return _context.abrupt("return", new Promise(function(resolve, reject) {
                            var request = new XMLHttpRequest();
                            request.open("GET", url, true);
                            if (asTypedArray) {
                              request.responseType = "arraybuffer";
                            }
                            request.onreadystatechange = function() {
                              if (request.readyState !== XMLHttpRequest.DONE) {
                                return;
                              }
                              if (request.status === 200 || request.status === 0) {
                                var data;
                                if (asTypedArray && request.response) {
                                  data = new Uint8Array(request.response);
                                } else if (!asTypedArray && request.responseText) {
                                  data = (0, _util2.stringToBytes)(request.responseText);
                                }
                                if (data) {
                                  resolve(data);
                                  return;
                                }
                              }
                              reject(new Error(request.statusText));
                            };
                            request.send(null);
                          }));
                        case 22:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));
                return _fetchData.apply(this, arguments);
              }
              var DOMCMapReaderFactory = /* @__PURE__ */ function(_BaseCMapReaderFactor) {
                _inherits(DOMCMapReaderFactory2, _BaseCMapReaderFactor);
                var _super2 = _createSuper(DOMCMapReaderFactory2);
                function DOMCMapReaderFactory2() {
                  _classCallCheck2(this, DOMCMapReaderFactory2);
                  return _super2.apply(this, arguments);
                }
                _createClass2(DOMCMapReaderFactory2, [{
                  key: "_fetchData",
                  value: function _fetchData2(url, compressionType) {
                    return fetchData(url, this.isCompressed).then(function(data) {
                      return {
                        cMapData: data,
                        compressionType
                      };
                    });
                  }
                }]);
                return DOMCMapReaderFactory2;
              }(_base_factory.BaseCMapReaderFactory);
              exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
              var DOMStandardFontDataFactory = /* @__PURE__ */ function(_BaseStandardFontData) {
                _inherits(DOMStandardFontDataFactory2, _BaseStandardFontData);
                var _super3 = _createSuper(DOMStandardFontDataFactory2);
                function DOMStandardFontDataFactory2() {
                  _classCallCheck2(this, DOMStandardFontDataFactory2);
                  return _super3.apply(this, arguments);
                }
                _createClass2(DOMStandardFontDataFactory2, [{
                  key: "_fetchData",
                  value: function _fetchData2(url) {
                    return fetchData(url, true);
                  }
                }]);
                return DOMStandardFontDataFactory2;
              }(_base_factory.BaseStandardFontDataFactory);
              exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
              var DOMSVGFactory = /* @__PURE__ */ function(_BaseSVGFactory) {
                _inherits(DOMSVGFactory2, _BaseSVGFactory);
                var _super4 = _createSuper(DOMSVGFactory2);
                function DOMSVGFactory2() {
                  _classCallCheck2(this, DOMSVGFactory2);
                  return _super4.apply(this, arguments);
                }
                _createClass2(DOMSVGFactory2, [{
                  key: "_createSVG",
                  value: function _createSVG(type) {
                    return document.createElementNS(SVG_NS, type);
                  }
                }]);
                return DOMSVGFactory2;
              }(_base_factory.BaseSVGFactory);
              exports2.DOMSVGFactory = DOMSVGFactory;
              var PageViewport = /* @__PURE__ */ function() {
                function PageViewport2(_ref2) {
                  var viewBox = _ref2.viewBox, scale = _ref2.scale, rotation = _ref2.rotation, _ref2$offsetX = _ref2.offsetX, offsetX = _ref2$offsetX === void 0 ? 0 : _ref2$offsetX, _ref2$offsetY = _ref2.offsetY, offsetY = _ref2$offsetY === void 0 ? 0 : _ref2$offsetY, _ref2$dontFlip = _ref2.dontFlip, dontFlip = _ref2$dontFlip === void 0 ? false : _ref2$dontFlip;
                  _classCallCheck2(this, PageViewport2);
                  this.viewBox = viewBox;
                  this.scale = scale;
                  this.rotation = rotation;
                  this.offsetX = offsetX;
                  this.offsetY = offsetY;
                  var centerX = (viewBox[2] + viewBox[0]) / 2;
                  var centerY = (viewBox[3] + viewBox[1]) / 2;
                  var rotateA, rotateB, rotateC, rotateD;
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  switch (rotation) {
                    case 180:
                      rotateA = -1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = 1;
                      break;
                    case 90:
                      rotateA = 0;
                      rotateB = 1;
                      rotateC = 1;
                      rotateD = 0;
                      break;
                    case 270:
                      rotateA = 0;
                      rotateB = -1;
                      rotateC = -1;
                      rotateD = 0;
                      break;
                    case 0:
                      rotateA = 1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = -1;
                      break;
                    default:
                      throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                  }
                  if (dontFlip) {
                    rotateC = -rotateC;
                    rotateD = -rotateD;
                  }
                  var offsetCanvasX, offsetCanvasY;
                  var width, height;
                  if (rotateA === 0) {
                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                    width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                    height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  } else {
                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                    width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                    height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  }
                  this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                  this.width = width;
                  this.height = height;
                }
                _createClass2(PageViewport2, [{
                  key: "clone",
                  value: function clone() {
                    var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$scale = _ref3.scale, scale = _ref3$scale === void 0 ? this.scale : _ref3$scale, _ref3$rotation = _ref3.rotation, rotation = _ref3$rotation === void 0 ? this.rotation : _ref3$rotation, _ref3$offsetX = _ref3.offsetX, offsetX = _ref3$offsetX === void 0 ? this.offsetX : _ref3$offsetX, _ref3$offsetY = _ref3.offsetY, offsetY = _ref3$offsetY === void 0 ? this.offsetY : _ref3$offsetY, _ref3$dontFlip = _ref3.dontFlip, dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;
                    return new PageViewport2({
                      viewBox: this.viewBox.slice(),
                      scale,
                      rotation,
                      offsetX,
                      offsetY,
                      dontFlip
                    });
                  }
                }, {
                  key: "convertToViewportPoint",
                  value: function convertToViewportPoint(x, y) {
                    return _util2.Util.applyTransform([x, y], this.transform);
                  }
                }, {
                  key: "convertToViewportRectangle",
                  value: function convertToViewportRectangle(rect) {
                    var topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                    var bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                  }
                }, {
                  key: "convertToPdfPoint",
                  value: function convertToPdfPoint(x, y) {
                    return _util2.Util.applyInverseTransform([x, y], this.transform);
                  }
                }]);
                return PageViewport2;
              }();
              exports2.PageViewport = PageViewport;
              var RenderingCancelledException = /* @__PURE__ */ function(_BaseException) {
                _inherits(RenderingCancelledException2, _BaseException);
                var _super5 = _createSuper(RenderingCancelledException2);
                function RenderingCancelledException2(msg, type) {
                  var _this2;
                  _classCallCheck2(this, RenderingCancelledException2);
                  _this2 = _super5.call(this, msg, "RenderingCancelledException");
                  _this2.type = type;
                  return _this2;
                }
                return _createClass2(RenderingCancelledException2);
              }(_util2.BaseException);
              exports2.RenderingCancelledException = RenderingCancelledException;
              function isDataScheme(url) {
                var ii = url.length;
                var i = 0;
                while (i < ii && url[i].trim() === "") {
                  i++;
                }
                return url.substring(i, i + 5).toLowerCase() === "data:";
              }
              function isPdfFile(filename) {
                return typeof filename === "string" && /\.pdf$/i.test(filename);
              }
              function getFilenameFromUrl(url) {
                var anchor = url.indexOf("#");
                var query = url.indexOf("?");
                var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
                return url.substring(url.lastIndexOf("/", end) + 1, end);
              }
              function getPdfFilenameFromUrl(url) {
                var defaultFilename = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "document.pdf";
                if (typeof url !== "string") {
                  return defaultFilename;
                }
                if (isDataScheme(url)) {
                  (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                  return defaultFilename;
                }
                var reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                var reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                var splitURI = reURI.exec(url);
                var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                if (suggestedFilename) {
                  suggestedFilename = suggestedFilename[0];
                  if (suggestedFilename.includes("%")) {
                    try {
                      suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                    } catch (ex) {
                    }
                  }
                }
                return suggestedFilename || defaultFilename;
              }
              var StatTimer = /* @__PURE__ */ function() {
                function StatTimer2() {
                  _classCallCheck2(this, StatTimer2);
                  this.started = /* @__PURE__ */ Object.create(null);
                  this.times = [];
                }
                _createClass2(StatTimer2, [{
                  key: "time",
                  value: function time(name) {
                    if (name in this.started) {
                      (0, _util2.warn)("Timer is already running for ".concat(name));
                    }
                    this.started[name] = Date.now();
                  }
                }, {
                  key: "timeEnd",
                  value: function timeEnd(name) {
                    if (!(name in this.started)) {
                      (0, _util2.warn)("Timer has not been started for ".concat(name));
                    }
                    this.times.push({
                      name,
                      start: this.started[name],
                      end: Date.now()
                    });
                    delete this.started[name];
                  }
                }, {
                  key: "toString",
                  value: function toString() {
                    var outBuf = [];
                    var longest = 0;
                    var _iterator = _createForOfIteratorHelper2(this.times), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var time = _step.value;
                        var name = time.name;
                        if (name.length > longest) {
                          longest = name.length;
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    var _iterator2 = _createForOfIteratorHelper2(this.times), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var _time = _step2.value;
                        var duration = _time.end - _time.start;
                        outBuf.push("".concat(_time.name.padEnd(longest), " ").concat(duration, "ms\n"));
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    return outBuf.join("");
                  }
                }]);
                return StatTimer2;
              }();
              exports2.StatTimer = StatTimer;
              function isValidFetchUrl(url, baseUrl) {
                try {
                  var _ref4 = baseUrl ? new URL(url, baseUrl) : new URL(url), protocol = _ref4.protocol;
                  return protocol === "http:" || protocol === "https:";
                } catch (ex) {
                  return false;
                }
              }
              function loadScript(src) {
                var removeScriptElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                return new Promise(function(resolve, reject) {
                  var script = document.createElement("script");
                  script.src = src;
                  script.onload = function(evt) {
                    if (removeScriptElement) {
                      script.remove();
                    }
                    resolve(evt);
                  };
                  script.onerror = function() {
                    reject(new Error("Cannot load script at: ".concat(script.src)));
                  };
                  (document.head || document.documentElement).appendChild(script);
                });
              }
              function deprecated(details) {
                console.log("Deprecated API usage: " + details);
              }
              var pdfDateStringRegex;
              var PDFDateString = /* @__PURE__ */ function() {
                function PDFDateString2() {
                  _classCallCheck2(this, PDFDateString2);
                }
                _createClass2(PDFDateString2, null, [{
                  key: "toDateObject",
                  value: function toDateObject(input) {
                    if (!input || typeof input !== "string") {
                      return null;
                    }
                    if (!pdfDateStringRegex) {
                      pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                    }
                    var matches = pdfDateStringRegex.exec(input);
                    if (!matches) {
                      return null;
                    }
                    var year = parseInt(matches[1], 10);
                    var month = parseInt(matches[2], 10);
                    month = month >= 1 && month <= 12 ? month - 1 : 0;
                    var day = parseInt(matches[3], 10);
                    day = day >= 1 && day <= 31 ? day : 1;
                    var hour = parseInt(matches[4], 10);
                    hour = hour >= 0 && hour <= 23 ? hour : 0;
                    var minute = parseInt(matches[5], 10);
                    minute = minute >= 0 && minute <= 59 ? minute : 0;
                    var second = parseInt(matches[6], 10);
                    second = second >= 0 && second <= 59 ? second : 0;
                    var universalTimeRelation = matches[7] || "Z";
                    var offsetHour = parseInt(matches[8], 10);
                    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                    var offsetMinute = parseInt(matches[9], 10) || 0;
                    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                    if (universalTimeRelation === "-") {
                      hour += offsetHour;
                      minute += offsetMinute;
                    } else if (universalTimeRelation === "+") {
                      hour -= offsetHour;
                      minute -= offsetMinute;
                    }
                    return new Date(Date.UTC(year, month, day, hour, minute, second));
                  }
                }]);
                return PDFDateString2;
              }();
              exports2.PDFDateString = PDFDateString;
              function getXfaPageViewport(xfaPage, _ref5) {
                var _ref5$scale = _ref5.scale, scale = _ref5$scale === void 0 ? 1 : _ref5$scale, _ref5$rotation = _ref5.rotation, rotation = _ref5$rotation === void 0 ? 0 : _ref5$rotation;
                var _xfaPage$attributes$s = xfaPage.attributes.style, width = _xfaPage$attributes$s.width, height = _xfaPage$attributes$s.height;
                var viewBox = [0, 0, parseInt(width), parseInt(height)];
                return new PageViewport({
                  viewBox,
                  scale,
                  rotation
                });
              }
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _util2 = __w_pdfjs_require__2(1);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var BaseCanvasFactory = /* @__PURE__ */ function() {
                function BaseCanvasFactory2() {
                  _classCallCheck2(this, BaseCanvasFactory2);
                  if (this.constructor === BaseCanvasFactory2) {
                    (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                  }
                }
                _createClass2(BaseCanvasFactory2, [{
                  key: "create",
                  value: function create(width, height) {
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid canvas size");
                    }
                    var canvas = this._createCanvas(width, height);
                    return {
                      canvas,
                      context: canvas.getContext("2d")
                    };
                  }
                }, {
                  key: "reset",
                  value: function reset(canvasAndContext, width, height) {
                    if (!canvasAndContext.canvas) {
                      throw new Error("Canvas is not specified");
                    }
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid canvas size");
                    }
                    canvasAndContext.canvas.width = width;
                    canvasAndContext.canvas.height = height;
                  }
                }, {
                  key: "destroy",
                  value: function destroy(canvasAndContext) {
                    if (!canvasAndContext.canvas) {
                      throw new Error("Canvas is not specified");
                    }
                    canvasAndContext.canvas.width = 0;
                    canvasAndContext.canvas.height = 0;
                    canvasAndContext.canvas = null;
                    canvasAndContext.context = null;
                  }
                }, {
                  key: "_createCanvas",
                  value: function _createCanvas(width, height) {
                    (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                  }
                }]);
                return BaseCanvasFactory2;
              }();
              exports2.BaseCanvasFactory = BaseCanvasFactory;
              var BaseCMapReaderFactory = /* @__PURE__ */ function() {
                function BaseCMapReaderFactory2(_ref) {
                  var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? null : _ref$baseUrl, _ref$isCompressed = _ref.isCompressed, isCompressed = _ref$isCompressed === void 0 ? false : _ref$isCompressed;
                  _classCallCheck2(this, BaseCMapReaderFactory2);
                  if (this.constructor === BaseCMapReaderFactory2) {
                    (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                  }
                  this.baseUrl = baseUrl;
                  this.isCompressed = isCompressed;
                }
                _createClass2(BaseCMapReaderFactory2, [{
                  key: "fetch",
                  value: function() {
                    var _fetch = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee(_ref2) {
                      var _this = this;
                      var name, url, compressionType;
                      return _regenerator2["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              name = _ref2.name;
                              if (this.baseUrl) {
                                _context.next = 3;
                                break;
                              }
                              throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                            case 3:
                              if (name) {
                                _context.next = 5;
                                break;
                              }
                              throw new Error("CMap name must be specified.");
                            case 5:
                              url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                              compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                              return _context.abrupt("return", this._fetchData(url, compressionType)["catch"](function(reason) {
                                throw new Error("Unable to load ".concat(_this.isCompressed ? "binary " : "", "CMap at: ").concat(url));
                              }));
                            case 8:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this);
                    }));
                    function fetch2(_x) {
                      return _fetch.apply(this, arguments);
                    }
                    return fetch2;
                  }()
                }, {
                  key: "_fetchData",
                  value: function _fetchData(url, compressionType) {
                    (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                  }
                }]);
                return BaseCMapReaderFactory2;
              }();
              exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
              var BaseStandardFontDataFactory = /* @__PURE__ */ function() {
                function BaseStandardFontDataFactory2(_ref3) {
                  var _ref3$baseUrl = _ref3.baseUrl, baseUrl = _ref3$baseUrl === void 0 ? null : _ref3$baseUrl;
                  _classCallCheck2(this, BaseStandardFontDataFactory2);
                  if (this.constructor === BaseStandardFontDataFactory2) {
                    (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                  }
                  this.baseUrl = baseUrl;
                }
                _createClass2(BaseStandardFontDataFactory2, [{
                  key: "fetch",
                  value: function() {
                    var _fetch2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2(_ref4) {
                      var filename, url;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              filename = _ref4.filename;
                              if (this.baseUrl) {
                                _context2.next = 3;
                                break;
                              }
                              throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                            case 3:
                              if (filename) {
                                _context2.next = 5;
                                break;
                              }
                              throw new Error("Font filename must be specified.");
                            case 5:
                              url = "".concat(this.baseUrl).concat(filename);
                              return _context2.abrupt("return", this._fetchData(url)["catch"](function(reason) {
                                throw new Error("Unable to load font data at: ".concat(url));
                              }));
                            case 7:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function fetch2(_x2) {
                      return _fetch2.apply(this, arguments);
                    }
                    return fetch2;
                  }()
                }, {
                  key: "_fetchData",
                  value: function _fetchData(url) {
                    (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                  }
                }]);
                return BaseStandardFontDataFactory2;
              }();
              exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
              var BaseSVGFactory = /* @__PURE__ */ function() {
                function BaseSVGFactory2() {
                  _classCallCheck2(this, BaseSVGFactory2);
                  if (this.constructor === BaseSVGFactory2) {
                    (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                  }
                }
                _createClass2(BaseSVGFactory2, [{
                  key: "create",
                  value: function create(width, height) {
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid SVG dimensions");
                    }
                    var svg = this._createSVG("svg:svg");
                    svg.setAttribute("version", "1.1");
                    svg.setAttribute("width", "".concat(width, "px"));
                    svg.setAttribute("height", "".concat(height, "px"));
                    svg.setAttribute("preserveAspectRatio", "none");
                    svg.setAttribute("viewBox", "0 0 ".concat(width, " ").concat(height));
                    return svg;
                  }
                }, {
                  key: "createElement",
                  value: function createElement(type) {
                    if (typeof type !== "string") {
                      throw new Error("Invalid SVG element type");
                    }
                    return this._createSVG(type);
                  }
                }, {
                  key: "_createSVG",
                  value: function _createSVG(type) {
                    (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                  }
                }]);
                return BaseSVGFactory2;
              }();
              exports2.BaseSVGFactory = BaseSVGFactory;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontLoader = exports2.FontFaceObject = void 0;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _util2 = __w_pdfjs_require__2(1);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var BaseFontLoader = /* @__PURE__ */ function() {
                function BaseFontLoader2(_ref) {
                  var docId = _ref.docId, onUnsupportedFeature = _ref.onUnsupportedFeature, _ref$ownerDocument = _ref.ownerDocument, ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument, _ref$styleElement = _ref.styleElement, styleElement = _ref$styleElement === void 0 ? null : _ref$styleElement;
                  _classCallCheck2(this, BaseFontLoader2);
                  if (this.constructor === BaseFontLoader2) {
                    (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                  }
                  this.docId = docId;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this._document = ownerDocument;
                  this.nativeFontFaces = [];
                  this.styleElement = null;
                }
                _createClass2(BaseFontLoader2, [{
                  key: "addNativeFontFace",
                  value: function addNativeFontFace(nativeFontFace) {
                    this.nativeFontFaces.push(nativeFontFace);
                    this._document.fonts.add(nativeFontFace);
                  }
                }, {
                  key: "insertRule",
                  value: function insertRule(rule) {
                    var styleElement = this.styleElement;
                    if (!styleElement) {
                      styleElement = this.styleElement = this._document.createElement("style");
                      styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);
                      this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                    }
                    var styleSheet = styleElement.sheet;
                    styleSheet.insertRule(rule, styleSheet.cssRules.length);
                  }
                }, {
                  key: "clear",
                  value: function clear() {
                    var _iterator = _createForOfIteratorHelper2(this.nativeFontFaces), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var nativeFontFace = _step.value;
                        this._document.fonts["delete"](nativeFontFace);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    this.nativeFontFaces.length = 0;
                    if (this.styleElement) {
                      this.styleElement.remove();
                      this.styleElement = null;
                    }
                  }
                }, {
                  key: "bind",
                  value: function() {
                    var _bind = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee(font) {
                      var _this = this;
                      var nativeFontFace, rule;
                      return _regenerator2["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              if (!(font.attached || font.missingFile)) {
                                _context.next = 2;
                                break;
                              }
                              return _context.abrupt("return");
                            case 2:
                              font.attached = true;
                              if (!this.isFontLoadingAPISupported) {
                                _context.next = 19;
                                break;
                              }
                              nativeFontFace = font.createNativeFontFace();
                              if (!nativeFontFace) {
                                _context.next = 18;
                                break;
                              }
                              this.addNativeFontFace(nativeFontFace);
                              _context.prev = 7;
                              _context.next = 10;
                              return nativeFontFace.loaded;
                            case 10:
                              _context.next = 18;
                              break;
                            case 12:
                              _context.prev = 12;
                              _context.t0 = _context["catch"](7);
                              this._onUnsupportedFeature({
                                featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                              });
                              (0, _util2.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context.t0, "'."));
                              font.disableFontFace = true;
                              throw _context.t0;
                            case 18:
                              return _context.abrupt("return");
                            case 19:
                              rule = font.createFontFaceRule();
                              if (!rule) {
                                _context.next = 26;
                                break;
                              }
                              this.insertRule(rule);
                              if (!this.isSyncFontLoadingSupported) {
                                _context.next = 24;
                                break;
                              }
                              return _context.abrupt("return");
                            case 24:
                              _context.next = 26;
                              return new Promise(function(resolve) {
                                var request = _this._queueLoadingCallback(resolve);
                                _this._prepareFontLoadEvent([rule], [font], request);
                              });
                            case 26:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this, [[7, 12]]);
                    }));
                    function bind(_x) {
                      return _bind.apply(this, arguments);
                    }
                    return bind;
                  }()
                }, {
                  key: "_queueLoadingCallback",
                  value: function _queueLoadingCallback(callback) {
                    (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                  }
                }, {
                  key: "isFontLoadingAPISupported",
                  get: function get2() {
                    var _this$_document;
                    var hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
                    return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                  }
                }, {
                  key: "isSyncFontLoadingSupported",
                  get: function get2() {
                    (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                  }
                }, {
                  key: "_loadTestFont",
                  get: function get2() {
                    (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                  }
                }, {
                  key: "_prepareFontLoadEvent",
                  value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {
                    (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                  }
                }]);
                return BaseFontLoader2;
              }();
              var FontLoader;
              exports2.FontLoader = FontLoader;
              {
                exports2.FontLoader = FontLoader = /* @__PURE__ */ function(_BaseFontLoader) {
                  _inherits(GenericFontLoader, _BaseFontLoader);
                  var _super = _createSuper(GenericFontLoader);
                  function GenericFontLoader(params) {
                    var _this2;
                    _classCallCheck2(this, GenericFontLoader);
                    _this2 = _super.call(this, params);
                    _this2.loadingContext = {
                      requests: [],
                      nextRequestId: 0
                    };
                    _this2.loadTestFontId = 0;
                    return _this2;
                  }
                  _createClass2(GenericFontLoader, [{
                    key: "isSyncFontLoadingSupported",
                    get: function get2() {
                      var supported = false;
                      if (typeof navigator === "undefined") {
                        supported = true;
                      } else {
                        var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                        if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
                          supported = true;
                        }
                      }
                      return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                    }
                  }, {
                    key: "_queueLoadingCallback",
                    value: function _queueLoadingCallback(callback) {
                      function completeRequest() {
                        (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                        request.done = true;
                        while (context.requests.length > 0 && context.requests[0].done) {
                          var otherRequest = context.requests.shift();
                          setTimeout(otherRequest.callback, 0);
                        }
                      }
                      var context = this.loadingContext;
                      var request = {
                        id: "pdfjs-font-loading-".concat(context.nextRequestId++),
                        done: false,
                        complete: completeRequest,
                        callback
                      };
                      context.requests.push(request);
                      return request;
                    }
                  }, {
                    key: "_loadTestFont",
                    get: function get2() {
                      var getLoadTestFont = function getLoadTestFont2() {
                        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                      };
                      return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                    }
                  }, {
                    key: "_prepareFontLoadEvent",
                    value: function _prepareFontLoadEvent(rules, fonts, request) {
                      function int32(data2, offset) {
                        return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                      }
                      function spliceString(s, offset, remove, insert) {
                        var chunk1 = s.substring(0, offset);
                        var chunk2 = s.substring(offset + remove);
                        return chunk1 + insert + chunk2;
                      }
                      var i, ii;
                      var canvas = this._document.createElement("canvas");
                      canvas.width = 1;
                      canvas.height = 1;
                      var ctx = canvas.getContext("2d");
                      var called = 0;
                      function isFontReady(name2, callback) {
                        called++;
                        if (called > 30) {
                          (0, _util2.warn)("Load test font never loaded.");
                          callback();
                          return;
                        }
                        ctx.font = "30px " + name2;
                        ctx.fillText(".", 0, 20);
                        var imageData = ctx.getImageData(0, 0, 1, 1);
                        if (imageData.data[3] > 0) {
                          callback();
                          return;
                        }
                        setTimeout(isFontReady.bind(null, name2, callback));
                      }
                      var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
                      var data = this._loadTestFont;
                      var COMMENT_OFFSET = 976;
                      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                      var CFF_CHECKSUM_OFFSET = 16;
                      var XXXX_VALUE = 1482184792;
                      var checksum = int32(data, CFF_CHECKSUM_OFFSET);
                      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                      }
                      if (i < loadTestFontId.length) {
                        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                      }
                      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                      var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
                      var rule = '@font-face {font-family:"'.concat(loadTestFontId, '";src:').concat(url, "}");
                      this.insertRule(rule);
                      var names = [];
                      var _iterator2 = _createForOfIteratorHelper2(fonts), _step2;
                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                          var font = _step2.value;
                          names.push(font.loadedName);
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                      names.push(loadTestFontId);
                      var div = this._document.createElement("div");
                      div.style.visibility = "hidden";
                      div.style.width = div.style.height = "10px";
                      div.style.position = "absolute";
                      div.style.top = div.style.left = "0px";
                      for (var _i = 0, _names = names; _i < _names.length; _i++) {
                        var name = _names[_i];
                        var span = this._document.createElement("span");
                        span.textContent = "Hi";
                        span.style.fontFamily = name;
                        div.appendChild(span);
                      }
                      this._document.body.appendChild(div);
                      isFontReady(loadTestFontId, function() {
                        div.remove();
                        request.complete();
                      });
                    }
                  }]);
                  return GenericFontLoader;
                }(BaseFontLoader);
              }
              var FontFaceObject = /* @__PURE__ */ function() {
                function FontFaceObject2(translatedData, _ref2) {
                  var _ref2$isEvalSupported = _ref2.isEvalSupported, isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported, _ref2$disableFontFace = _ref2.disableFontFace, disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace, _ref2$ignoreErrors = _ref2.ignoreErrors, ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors, onUnsupportedFeature = _ref2.onUnsupportedFeature, _ref2$fontRegistry = _ref2.fontRegistry, fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry;
                  _classCallCheck2(this, FontFaceObject2);
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  for (var i in translatedData) {
                    this[i] = translatedData[i];
                  }
                  this.isEvalSupported = isEvalSupported !== false;
                  this.disableFontFace = disableFontFace === true;
                  this.ignoreErrors = ignoreErrors === true;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this.fontRegistry = fontRegistry;
                }
                _createClass2(FontFaceObject2, [{
                  key: "createNativeFontFace",
                  value: function createNativeFontFace() {
                    if (!this.data || this.disableFontFace) {
                      return null;
                    }
                    var nativeFontFace;
                    if (!this.cssFontInfo) {
                      nativeFontFace = new FontFace(this.loadedName, this.data, {});
                    } else {
                      var css = {
                        weight: this.cssFontInfo.fontWeight
                      };
                      if (this.cssFontInfo.italicAngle) {
                        css.style = "oblique ".concat(this.cssFontInfo.italicAngle, "deg");
                      }
                      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                    }
                    if (this.fontRegistry) {
                      this.fontRegistry.registerFont(this);
                    }
                    return nativeFontFace;
                  }
                }, {
                  key: "createFontFaceRule",
                  value: function createFontFaceRule() {
                    if (!this.data || this.disableFontFace) {
                      return null;
                    }
                    var data = (0, _util2.bytesToString)(this.data);
                    var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
                    var rule;
                    if (!this.cssFontInfo) {
                      rule = '@font-face {font-family:"'.concat(this.loadedName, '";src:').concat(url, "}");
                    } else {
                      var css = "font-weight: ".concat(this.cssFontInfo.fontWeight, ";");
                      if (this.cssFontInfo.italicAngle) {
                        css += "font-style: oblique ".concat(this.cssFontInfo.italicAngle, "deg;");
                      }
                      rule = '@font-face {font-family:"'.concat(this.cssFontInfo.fontFamily, '";').concat(css, "src:").concat(url, "}");
                    }
                    if (this.fontRegistry) {
                      this.fontRegistry.registerFont(this, url);
                    }
                    return rule;
                  }
                }, {
                  key: "getPathGenerator",
                  value: function getPathGenerator(objs, character) {
                    if (this.compiledGlyphs[character] !== void 0) {
                      return this.compiledGlyphs[character];
                    }
                    var cmds;
                    try {
                      cmds = objs.get(this.loadedName + "_path_" + character);
                    } catch (ex) {
                      if (!this.ignoreErrors) {
                        throw ex;
                      }
                      this._onUnsupportedFeature({
                        featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                      });
                      (0, _util2.warn)('getPathGenerator - ignoring character: "'.concat(ex, '".'));
                      return this.compiledGlyphs[character] = function(c, size) {
                      };
                    }
                    if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                      var jsBuf = [];
                      var _iterator3 = _createForOfIteratorHelper2(cmds), _step3;
                      try {
                        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                          var current = _step3.value;
                          var args = current.args !== void 0 ? current.args.join(",") : "";
                          jsBuf.push("c.", current.cmd, "(", args, ");\n");
                        }
                      } catch (err) {
                        _iterator3.e(err);
                      } finally {
                        _iterator3.f();
                      }
                      return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                    }
                    return this.compiledGlyphs[character] = function(c, size) {
                      var _iterator4 = _createForOfIteratorHelper2(cmds), _step4;
                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                          var _current = _step4.value;
                          if (_current.cmd === "scale") {
                            _current.args = [size, -size];
                          }
                          c[_current.cmd].apply(c, _current.args);
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }
                    };
                  }
                }]);
                return FontFaceObject2;
              }();
              exports2.FontFaceObject = FontFaceObject;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationStorage = void 0;
              var _murmurhash = __w_pdfjs_require__2(162);
              var _util2 = __w_pdfjs_require__2(1);
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e2) {
                      throw _e2;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e3) {
                  didErr = true;
                  err = _e3;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var AnnotationStorage = /* @__PURE__ */ function() {
                function AnnotationStorage2() {
                  _classCallCheck2(this, AnnotationStorage2);
                  this._storage = /* @__PURE__ */ new Map();
                  this._modified = false;
                  this.onSetModified = null;
                  this.onResetModified = null;
                }
                _createClass2(AnnotationStorage2, [{
                  key: "getValue",
                  value: function getValue(key, defaultValue) {
                    var value = this._storage.get(key);
                    if (value === void 0) {
                      return defaultValue;
                    }
                    return Object.assign(defaultValue, value);
                  }
                }, {
                  key: "getRawValue",
                  value: function getRawValue(key) {
                    return this._storage.get(key);
                  }
                }, {
                  key: "setValue",
                  value: function setValue(key, value) {
                    var obj = this._storage.get(key);
                    var modified = false;
                    if (obj !== void 0) {
                      for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {
                        var _Object$entries$_i = _slicedToArray2(_Object$entries[_i], 2), entry = _Object$entries$_i[0], val = _Object$entries$_i[1];
                        if (obj[entry] !== val) {
                          modified = true;
                          obj[entry] = val;
                        }
                      }
                    } else {
                      modified = true;
                      this._storage.set(key, value);
                    }
                    if (modified) {
                      this._setModified();
                    }
                  }
                }, {
                  key: "getAll",
                  value: function getAll() {
                    return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
                  }
                }, {
                  key: "size",
                  get: function get2() {
                    return this._storage.size;
                  }
                }, {
                  key: "_setModified",
                  value: function _setModified() {
                    if (!this._modified) {
                      this._modified = true;
                      if (typeof this.onSetModified === "function") {
                        this.onSetModified();
                      }
                    }
                  }
                }, {
                  key: "resetModified",
                  value: function resetModified() {
                    if (this._modified) {
                      this._modified = false;
                      if (typeof this.onResetModified === "function") {
                        this.onResetModified();
                      }
                    }
                  }
                }, {
                  key: "serializable",
                  get: function get2() {
                    return this._storage.size > 0 ? this._storage : null;
                  }
                }, {
                  key: "hash",
                  get: function get2() {
                    var hash = new _murmurhash.MurmurHash3_64();
                    var _iterator = _createForOfIteratorHelper2(this._storage), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var _step$value = _slicedToArray2(_step.value, 2), key = _step$value[0], value = _step$value[1];
                        hash.update("".concat(key, ":").concat(JSON.stringify(value)));
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    return hash.hexdigest();
                  }
                }]);
                return AnnotationStorage2;
              }();
              exports2.AnnotationStorage = AnnotationStorage;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var SEED = 3285377520;
              var MASK_HIGH = 4294901760;
              var MASK_LOW = 65535;
              var MurmurHash3_64 = /* @__PURE__ */ function() {
                function MurmurHash3_642(seed) {
                  _classCallCheck2(this, MurmurHash3_642);
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                _createClass2(MurmurHash3_642, [{
                  key: "update",
                  value: function update(input) {
                    var data, length;
                    if (typeof input === "string") {
                      data = new Uint8Array(input.length * 2);
                      length = 0;
                      for (var i = 0, ii = input.length; i < ii; i++) {
                        var code = input.charCodeAt(i);
                        if (code <= 255) {
                          data[length++] = code;
                        } else {
                          data[length++] = code >>> 8;
                          data[length++] = code & 255;
                        }
                      }
                    } else if ((0, _util2.isArrayBuffer)(input)) {
                      data = input.slice();
                      length = data.byteLength;
                    } else {
                      throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                    }
                    var blockCounts = length >> 2;
                    var tailLength = length - blockCounts * 4;
                    var dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                    var k1 = 0, k2 = 0;
                    var h1 = this.h1, h2 = this.h2;
                    var C1 = 3432918353, C2 = 461845907;
                    var C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                    for (var _i = 0; _i < blockCounts; _i++) {
                      if (_i & 1) {
                        k1 = dataUint32[_i];
                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                        k1 = k1 << 15 | k1 >>> 17;
                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                        h1 ^= k1;
                        h1 = h1 << 13 | h1 >>> 19;
                        h1 = h1 * 5 + 3864292196;
                      } else {
                        k2 = dataUint32[_i];
                        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                        k2 = k2 << 15 | k2 >>> 17;
                        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                        h2 ^= k2;
                        h2 = h2 << 13 | h2 >>> 19;
                        h2 = h2 * 5 + 3864292196;
                      }
                    }
                    k1 = 0;
                    switch (tailLength) {
                      case 3:
                        k1 ^= data[blockCounts * 4 + 2] << 16;
                      case 2:
                        k1 ^= data[blockCounts * 4 + 1] << 8;
                      case 1:
                        k1 ^= data[blockCounts * 4];
                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                        k1 = k1 << 15 | k1 >>> 17;
                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                        if (blockCounts & 1) {
                          h1 ^= k1;
                        } else {
                          h2 ^= k1;
                        }
                    }
                    this.h1 = h1;
                    this.h2 = h2;
                  }
                }, {
                  key: "hexdigest",
                  value: function hexdigest() {
                    var h1 = this.h1, h2 = this.h2;
                    h1 ^= h2 >>> 1;
                    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                    h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                    h1 ^= h2 >>> 1;
                    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                    h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                    h1 ^= h2 >>> 1;
                    var hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                    return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                  }
                }]);
                return MurmurHash3_642;
              }();
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CanvasGraphics = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _pattern_helper = __w_pdfjs_require__2(164);
              var _image_utils = __w_pdfjs_require__2(165);
              var _is_node2 = __w_pdfjs_require__2(3);
              var _display_utils2 = __w_pdfjs_require__2(158);
              function _toConsumableArray2(arr) {
                return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
              }
              function _nonIterableSpread2() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArray2(iter) {
                if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                  return Array.from(iter);
              }
              function _arrayWithoutHoles2(arr) {
                if (Array.isArray(arr))
                  return _arrayLikeToArray2(arr);
              }
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e2) {
                      throw _e2;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e3) {
                  didErr = true;
                  err = _e3;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              var MIN_FONT_SIZE = 16;
              var MAX_FONT_SIZE = 100;
              var MAX_GROUP_SIZE = 4096;
              var EXECUTION_TIME = 15;
              var EXECUTION_STEPS = 10;
              var COMPILE_TYPE3_GLYPHS = true;
              var MAX_SIZE_TO_COMPILE = 1e3;
              var FULL_CHUNK_HEIGHT = 16;
              var LINEWIDTH_SCALE_FACTOR = 1.000001;
              function mirrorContextOperations(ctx, destCtx) {
                if (ctx._removeMirroring) {
                  throw new Error("Context is already forwarding operations.");
                }
                ctx.__originalSave = ctx.save;
                ctx.__originalRestore = ctx.restore;
                ctx.__originalRotate = ctx.rotate;
                ctx.__originalScale = ctx.scale;
                ctx.__originalTranslate = ctx.translate;
                ctx.__originalTransform = ctx.transform;
                ctx.__originalSetTransform = ctx.setTransform;
                ctx.__originalResetTransform = ctx.resetTransform;
                ctx.__originalClip = ctx.clip;
                ctx.__originalMoveTo = ctx.moveTo;
                ctx.__originalLineTo = ctx.lineTo;
                ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                ctx.__originalRect = ctx.rect;
                ctx.__originalClosePath = ctx.closePath;
                ctx.__originalBeginPath = ctx.beginPath;
                ctx._removeMirroring = function() {
                  ctx.save = ctx.__originalSave;
                  ctx.restore = ctx.__originalRestore;
                  ctx.rotate = ctx.__originalRotate;
                  ctx.scale = ctx.__originalScale;
                  ctx.translate = ctx.__originalTranslate;
                  ctx.transform = ctx.__originalTransform;
                  ctx.setTransform = ctx.__originalSetTransform;
                  ctx.resetTransform = ctx.__originalResetTransform;
                  ctx.clip = ctx.__originalClip;
                  ctx.moveTo = ctx.__originalMoveTo;
                  ctx.lineTo = ctx.__originalLineTo;
                  ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                  ctx.rect = ctx.__originalRect;
                  ctx.closePath = ctx.__originalClosePath;
                  ctx.beginPath = ctx.__originalBeginPath;
                  delete ctx._removeMirroring;
                };
                ctx.save = function ctxSave() {
                  destCtx.save();
                  this.__originalSave();
                };
                ctx.restore = function ctxRestore() {
                  destCtx.restore();
                  this.__originalRestore();
                };
                ctx.translate = function ctxTranslate(x, y) {
                  destCtx.translate(x, y);
                  this.__originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  destCtx.scale(x, y);
                  this.__originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  destCtx.transform(a, b, c, d, e, f);
                  this.__originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  destCtx.setTransform(a, b, c, d, e, f);
                  this.__originalSetTransform(a, b, c, d, e, f);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  destCtx.resetTransform();
                  this.__originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle) {
                  destCtx.rotate(angle);
                  this.__originalRotate(angle);
                };
                ctx.clip = function ctxRotate(rule) {
                  destCtx.clip(rule);
                  this.__originalClip(rule);
                };
                ctx.moveTo = function(x, y) {
                  destCtx.moveTo(x, y);
                  this.__originalMoveTo(x, y);
                };
                ctx.lineTo = function(x, y) {
                  destCtx.lineTo(x, y);
                  this.__originalLineTo(x, y);
                };
                ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
                  destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                  this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                };
                ctx.rect = function(x, y, width, height) {
                  destCtx.rect(x, y, width, height);
                  this.__originalRect(x, y, width, height);
                };
                ctx.closePath = function() {
                  destCtx.closePath();
                  this.__originalClosePath();
                };
                ctx.beginPath = function() {
                  destCtx.beginPath();
                  this.__originalBeginPath();
                };
              }
              function addContextCurrentTransform(ctx) {
                if (ctx._transformStack) {
                  ctx._transformStack = [];
                }
                if (ctx.mozCurrentTransform) {
                  return;
                }
                ctx._originalSave = ctx.save;
                ctx._originalRestore = ctx.restore;
                ctx._originalRotate = ctx.rotate;
                ctx._originalScale = ctx.scale;
                ctx._originalTranslate = ctx.translate;
                ctx._originalTransform = ctx.transform;
                ctx._originalSetTransform = ctx.setTransform;
                ctx._originalResetTransform = ctx.resetTransform;
                ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                ctx._transformStack = [];
                try {
                  var desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
                  ctx._setLineWidth = desc.set;
                  ctx._getLineWidth = desc.get;
                  Object.defineProperty(ctx, "lineWidth", {
                    set: function setLineWidth(width) {
                      this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
                    },
                    get: function getLineWidth() {
                      return this._getLineWidth();
                    }
                  });
                } catch (_) {
                }
                Object.defineProperty(ctx, "mozCurrentTransform", {
                  get: function getCurrentTransform() {
                    return this._transformMatrix;
                  }
                });
                Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                  get: function getCurrentTransformInverse() {
                    var _this$_transformMatri = _slicedToArray2(this._transformMatrix, 6), a = _this$_transformMatri[0], b = _this$_transformMatri[1], c = _this$_transformMatri[2], d = _this$_transformMatri[3], e = _this$_transformMatri[4], f = _this$_transformMatri[5];
                    var ad_bc = a * d - b * c;
                    var bc_ad = b * c - a * d;
                    return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                  }
                });
                ctx.save = function ctxSave() {
                  var old = this._transformMatrix;
                  this._transformStack.push(old);
                  this._transformMatrix = old.slice(0, 6);
                  this._originalSave();
                };
                ctx.restore = function ctxRestore() {
                  if (this._transformStack.length === 0) {
                    (0, _util2.warn)("Tried to restore a ctx when the stack was already empty.");
                  }
                  var prev = this._transformStack.pop();
                  if (prev) {
                    this._transformMatrix = prev;
                    this._originalRestore();
                  }
                };
                ctx.translate = function ctxTranslate(x, y) {
                  var m = this._transformMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                  this._originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  var m = this._transformMatrix;
                  m[0] *= x;
                  m[1] *= x;
                  m[2] *= y;
                  m[3] *= y;
                  this._originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                  ctx._originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  this._transformMatrix = [a, b, c, d, e, f];
                  ctx._originalSetTransform(a, b, c, d, e, f);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  this._transformMatrix = [1, 0, 0, 1, 0, 0];
                  ctx._originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle) {
                  var cosValue = Math.cos(angle);
                  var sinValue = Math.sin(angle);
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                  this._originalRotate(angle);
                };
              }
              var CachedCanvases = /* @__PURE__ */ function() {
                function CachedCanvases2(canvasFactory) {
                  _classCallCheck2(this, CachedCanvases2);
                  this.canvasFactory = canvasFactory;
                  this.cache = /* @__PURE__ */ Object.create(null);
                }
                _createClass2(CachedCanvases2, [{
                  key: "getCanvas",
                  value: function getCanvas(id, width, height, trackTransform) {
                    var canvasEntry;
                    if (this.cache[id] !== void 0) {
                      canvasEntry = this.cache[id];
                      this.canvasFactory.reset(canvasEntry, width, height);
                      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                    } else {
                      canvasEntry = this.canvasFactory.create(width, height);
                      this.cache[id] = canvasEntry;
                    }
                    if (trackTransform) {
                      addContextCurrentTransform(canvasEntry.context);
                    }
                    return canvasEntry;
                  }
                }, {
                  key: "delete",
                  value: function _delete(id) {
                    delete this.cache[id];
                  }
                }, {
                  key: "clear",
                  value: function clear() {
                    for (var id in this.cache) {
                      var canvasEntry = this.cache[id];
                      this.canvasFactory.destroy(canvasEntry);
                      delete this.cache[id];
                    }
                  }
                }]);
                return CachedCanvases2;
              }();
              function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                var _ctx$mozCurrentTransf = _slicedToArray2(ctx.mozCurrentTransform, 6), a = _ctx$mozCurrentTransf[0], b = _ctx$mozCurrentTransf[1], c = _ctx$mozCurrentTransf[2], d = _ctx$mozCurrentTransf[3], tx = _ctx$mozCurrentTransf[4], ty = _ctx$mozCurrentTransf[5];
                if (b === 0 && c === 0) {
                  var tlX = destX * a + tx;
                  var rTlX = Math.round(tlX);
                  var tlY = destY * d + ty;
                  var rTlY = Math.round(tlY);
                  var brX = (destX + destW) * a + tx;
                  var rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  var brY = (destY + destH) * d + ty;
                  var rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rWidth, rHeight];
                }
                if (a === 0 && d === 0) {
                  var _tlX = destY * c + tx;
                  var _rTlX = Math.round(_tlX);
                  var _tlY = destX * b + ty;
                  var _rTlY = Math.round(_tlY);
                  var _brX = (destY + destH) * c + tx;
                  var _rWidth = Math.abs(Math.round(_brX) - _rTlX) || 1;
                  var _brY = (destX + destW) * b + ty;
                  var _rHeight = Math.abs(Math.round(_brY) - _rTlY) || 1;
                  ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, _rTlX, _rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, _rHeight, _rWidth);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [_rHeight, _rWidth];
                }
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                var scaleX = Math.hypot(a, b);
                var scaleY = Math.hypot(c, d);
                return [scaleX * destW, scaleY * destH];
              }
              function compileType3Glyph(imgData) {
                var width = imgData.width, height = imgData.height;
                if (!COMPILE_TYPE3_GLYPHS || width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                  return null;
                }
                var POINT_TO_PROCESS_LIMIT = 1e3;
                var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                var width1 = width + 1;
                var points = new Uint8Array(width1 * (height + 1));
                var i, j, j0;
                var lineSize = width + 7 & ~7;
                var data = new Uint8Array(lineSize * height), pos = 0;
                var _iterator = _createForOfIteratorHelper2(imgData.data), _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var elem = _step.value;
                    var mask = 128;
                    while (mask > 0) {
                      data[pos++] = elem & mask ? 0 : 255;
                      mask >>= 1;
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                var count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                  points[0] = 1;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j] = data[pos] ? 2 : 1;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j] = 2;
                  ++count;
                }
                for (i = 1; i < height; i++) {
                  pos = i * lineSize;
                  j0 = i * width1;
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0] = data[pos] ? 1 : 8;
                    ++count;
                  }
                  var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                  for (j = 1; j < width; j++) {
                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                    if (POINT_TYPES[sum]) {
                      points[j0 + j] = POINT_TYPES[sum];
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0 + j] = data[pos] ? 2 : 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                }
                pos = lineSize * (height - 1);
                j0 = i * width1;
                if (data[pos] !== 0) {
                  points[j0] = 8;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j0 + j] = data[pos] ? 4 : 8;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j0 + j] = 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
                var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                var path, outlines, coords;
                if (!_is_node2.isNodeJS) {
                  path = new Path2D();
                } else {
                  outlines = [];
                }
                for (i = 0; count && i <= height; i++) {
                  var p = i * width1;
                  var end = p + width;
                  while (p < end && !points[p]) {
                    p++;
                  }
                  if (p === end) {
                    continue;
                  }
                  if (path) {
                    path.moveTo(p % width1, i);
                  } else {
                    coords = [p % width1, i];
                  }
                  var p0 = p;
                  var type = points[p];
                  do {
                    var step = steps[type];
                    do {
                      p += step;
                    } while (!points[p]);
                    var pp = points[p];
                    if (pp !== 5 && pp !== 10) {
                      type = pp;
                      points[p] = 0;
                    } else {
                      type = pp & 51 * type >> 4;
                      points[p] &= type >> 2 | type << 2;
                    }
                    if (path) {
                      path.lineTo(p % width1, p / width1 | 0);
                    } else {
                      coords.push(p % width1, p / width1 | 0);
                    }
                    if (!points[p]) {
                      --count;
                    }
                  } while (p0 !== p);
                  if (!path) {
                    outlines.push(coords);
                  }
                  --i;
                }
                data = null;
                points = null;
                var drawOutline = function drawOutline2(c) {
                  c.save();
                  c.scale(1 / width, -1 / height);
                  c.translate(0, -height);
                  if (path) {
                    c.fill(path);
                  } else {
                    c.beginPath();
                    var _iterator2 = _createForOfIteratorHelper2(outlines), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var o = _step2.value;
                        c.moveTo(o[0], o[1]);
                        for (var l = 2, ll = o.length; l < ll; l += 2) {
                          c.lineTo(o[l], o[l + 1]);
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    c.fill();
                  }
                  c.beginPath();
                  c.restore();
                };
                return drawOutline;
              }
              var CanvasExtraState = /* @__PURE__ */ function() {
                function CanvasExtraState2(width, height) {
                  _classCallCheck2(this, CanvasExtraState2);
                  this.alphaIsShape = false;
                  this.fontSize = 0;
                  this.fontSizeScale = 1;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.textMatrixScale = 1;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textRise = 0;
                  this.fillColor = "#000000";
                  this.strokeColor = "#000000";
                  this.patternFill = false;
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.activeSMask = null;
                  this.transferMaps = null;
                  this.startNewPathAndClipBox([0, 0, width, height]);
                }
                _createClass2(CanvasExtraState2, [{
                  key: "clone",
                  value: function clone() {
                    var clone2 = Object.create(this);
                    clone2.clipBox = this.clipBox.slice();
                    return clone2;
                  }
                }, {
                  key: "setCurrentPoint",
                  value: function setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                }, {
                  key: "updatePathMinMax",
                  value: function updatePathMinMax(transform, x, y) {
                    var _Util$applyTransform = _util2.Util.applyTransform([x, y], transform);
                    var _Util$applyTransform2 = _slicedToArray2(_Util$applyTransform, 2);
                    x = _Util$applyTransform2[0];
                    y = _Util$applyTransform2[1];
                    this.minX = Math.min(this.minX, x);
                    this.minY = Math.min(this.minY, y);
                    this.maxX = Math.max(this.maxX, x);
                    this.maxY = Math.max(this.maxY, y);
                  }
                }, {
                  key: "updateRectMinMax",
                  value: function updateRectMinMax(transform, rect) {
                    var p1 = _util2.Util.applyTransform(rect, transform);
                    var p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                    this.minX = Math.min(this.minX, p1[0], p2[0]);
                    this.minY = Math.min(this.minY, p1[1], p2[1]);
                    this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                    this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                  }
                }, {
                  key: "updateScalingPathMinMax",
                  value: function updateScalingPathMinMax(transform, minMax) {
                    _util2.Util.scaleMinMax(transform, minMax);
                    this.minX = Math.min(this.minX, minMax[0]);
                    this.maxX = Math.max(this.maxX, minMax[1]);
                    this.minY = Math.min(this.minY, minMax[2]);
                    this.maxY = Math.max(this.maxY, minMax[3]);
                  }
                }, {
                  key: "updateCurvePathMinMax",
                  value: function updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                    var box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                    if (minMax) {
                      minMax[0] = Math.min(minMax[0], box[0], box[2]);
                      minMax[1] = Math.max(minMax[1], box[0], box[2]);
                      minMax[2] = Math.min(minMax[2], box[1], box[3]);
                      minMax[3] = Math.max(minMax[3], box[1], box[3]);
                      return;
                    }
                    this.updateRectMinMax(transform, box);
                  }
                }, {
                  key: "getPathBoundingBox",
                  value: function getPathBoundingBox() {
                    var pathType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _pattern_helper.PathType.FILL;
                    var transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    var box = [this.minX, this.minY, this.maxX, this.maxY];
                    if (pathType === _pattern_helper.PathType.STROKE) {
                      if (!transform) {
                        (0, _util2.unreachable)("Stroke bounding box must include transform.");
                      }
                      var scale = _util2.Util.singularValueDecompose2dScale(transform);
                      var xStrokePad = scale[0] * this.lineWidth / 2;
                      var yStrokePad = scale[1] * this.lineWidth / 2;
                      box[0] -= xStrokePad;
                      box[1] -= yStrokePad;
                      box[2] += xStrokePad;
                      box[3] += yStrokePad;
                    }
                    return box;
                  }
                }, {
                  key: "updateClipFromPath",
                  value: function updateClipFromPath() {
                    var intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                  }
                }, {
                  key: "isEmptyClip",
                  value: function isEmptyClip() {
                    return this.minX === Infinity;
                  }
                }, {
                  key: "startNewPathAndClipBox",
                  value: function startNewPathAndClipBox(box) {
                    this.clipBox = box;
                    this.minX = Infinity;
                    this.minY = Infinity;
                    this.maxX = 0;
                    this.maxY = 0;
                  }
                }, {
                  key: "getClippedPathBoundingBox",
                  value: function getClippedPathBoundingBox() {
                    var pathType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _pattern_helper.PathType.FILL;
                    var transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
                  }
                }]);
                return CanvasExtraState2;
              }();
              function putBinaryImageData(ctx, imgData) {
                var transferMaps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0, destPos;
                var src = imgData.data;
                var dest = chunkImgData.data;
                var i, j, thisChunkHeight, elemsInThisChunk;
                var transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                if (transferMaps) {
                  switch (transferMaps.length) {
                    case 1:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[0];
                      transferMapBlue = transferMaps[0];
                      transferMapGray = transferMaps[0];
                      break;
                    case 4:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[1];
                      transferMapBlue = transferMaps[2];
                      transferMapGray = transferMaps[3];
                      break;
                  }
                }
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  var srcLength = src.byteLength;
                  var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  var dest32DataLength = dest32.length;
                  var fullSrcDiff = width + 7 >> 3;
                  var white = 4294967295;
                  var black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  if (transferMapGray) {
                    if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                      var _ref = [black, white];
                      white = _ref[0];
                      black = _ref[1];
                    }
                  }
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      var srcDiff = srcLength - srcPos;
                      var k = 0;
                      var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      var kEndUnrolled = kEnd & ~7;
                      var mask = 0;
                      var srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  var hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    if (hasTransferMaps) {
                      for (var _k = 0; _k < elemsInThisChunk; _k += 4) {
                        if (transferMapRed) {
                          dest[_k + 0] = transferMapRed[dest[_k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[_k + 1] = transferMapGreen[dest[_k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[_k + 2] = transferMapBlue[dest[_k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    if (hasTransferMaps) {
                      for (var _k2 = 0; _k2 < elemsInThisChunk; _k2 += 4) {
                        if (transferMapRed) {
                          dest[_k2 + 0] = transferMapRed[dest[_k2 + 0]];
                        }
                        if (transferMapGreen) {
                          dest[_k2 + 1] = transferMapGreen[dest[_k2 + 1]];
                        }
                        if (transferMapBlue) {
                          dest[_k2 + 2] = transferMapBlue[dest[_k2 + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  var _hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    if (_hasTransferMaps) {
                      for (var _k3 = 0; _k3 < destPos; _k3 += 4) {
                        if (transferMapRed) {
                          dest[_k3 + 0] = transferMapRed[dest[_k3 + 0]];
                        }
                        if (transferMapGreen) {
                          dest[_k3 + 1] = transferMapGreen[dest[_k3 + 1]];
                        }
                        if (transferMapBlue) {
                          dest[_k3 + 2] = transferMapBlue[dest[_k3 + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error("bad image kind: ".concat(imgData.kind));
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                if (imgData.bitmap) {
                  ctx.drawImage(imgData.bitmap, 0, 0);
                  return;
                }
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0;
                var src = imgData.data;
                var dest = chunkImgData.data;
                for (var i = 0; i < totalChunks; i++) {
                  var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  var _applyMaskImageData = (0, _image_utils.applyMaskImageData)({
                    src,
                    srcPos,
                    dest,
                    width,
                    height: thisChunkHeight
                  });
                  srcPos = _applyMaskImageData.srcPos;
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (var i = 0, ii = properties.length; i < ii; i++) {
                  var property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx, foregroundColor) {
                ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                var length = bytes.length;
                for (var i = 3; i < length; i += 4) {
                  var alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    var alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                var length = maskData.length;
                var scale = 1 / 255;
                for (var i = 3; i < length; i += 4) {
                  var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                var length = maskData.length;
                for (var i = 3; i < length; i += 4) {
                  var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                var hasBackdrop = !!backdrop;
                var r0 = hasBackdrop ? backdrop[0] : 0;
                var g0 = hasBackdrop ? backdrop[1] : 0;
                var b0 = hasBackdrop ? backdrop[2] : 0;
                var composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                var PIXELS_TO_PROCESS = 1048576;
                var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (var row = 0; row < height; row += chunkSize) {
                  var chunkHeight = Math.min(chunkSize, height - row);
                  var maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
                  var layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                }
              }
              function composeSMask(ctx, smask, layerCtx, layerBox) {
                var layerOffsetX = layerBox[0];
                var layerOffsetY = layerBox[1];
                var layerWidth = layerBox[2] - layerOffsetX;
                var layerHeight = layerBox[3] - layerOffsetY;
                if (layerWidth === 0 || layerHeight === 0) {
                  return;
                }
                genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(layerCtx.canvas, 0, 0);
                ctx.restore();
              }
              function getImageSmoothingEnabled(transform, interpolate) {
                var scale = _util2.Util.singularValueDecompose2dScale(transform);
                scale[0] = Math.fround(scale[0]);
                scale[1] = Math.fround(scale[1]);
                var actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                if (interpolate !== void 0) {
                  return interpolate;
                } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
                  return true;
                }
                return false;
              }
              var LINE_CAP_STYLES = ["butt", "round", "square"];
              var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              var NORMAL_CLIP = {};
              var EO_CLIP = {};
              var CanvasGraphics = /* @__PURE__ */ function() {
                function CanvasGraphics2(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
                  _classCallCheck2(this, CanvasGraphics2);
                  this.ctx = canvasCtx;
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.stateStack = [];
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.res = null;
                  this.xobjs = null;
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.canvasFactory = canvasFactory;
                  this.imageLayer = imageLayer;
                  this.groupStack = [];
                  this.processingType3 = null;
                  this.baseTransform = null;
                  this.baseTransformStack = [];
                  this.groupLevel = 0;
                  this.smaskStack = [];
                  this.smaskCounter = 0;
                  this.tempSMask = null;
                  this.suspendedCtx = null;
                  this.contentVisible = true;
                  this.markedContentStack = [];
                  this.optionalContentConfig = optionalContentConfig;
                  this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                  this.cachedPatterns = /* @__PURE__ */ new Map();
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.viewportScale = 1;
                  this.outputScaleX = 1;
                  this.outputScaleY = 1;
                  this.backgroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.background) || null;
                  this.foregroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.foreground) || null;
                  if (canvasCtx) {
                    addContextCurrentTransform(canvasCtx);
                  }
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                }
                _createClass2(CanvasGraphics2, [{
                  key: "getObject",
                  value: function getObject(data) {
                    var fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    if (typeof data === "string") {
                      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                    }
                    return fallback;
                  }
                }, {
                  key: "beginDrawing",
                  value: function beginDrawing(_ref2) {
                    var transform = _ref2.transform, viewport = _ref2.viewport, _ref2$transparency = _ref2.transparency, transparency = _ref2$transparency === void 0 ? false : _ref2$transparency, _ref2$background = _ref2.background, background = _ref2$background === void 0 ? null : _ref2$background;
                    var width = this.ctx.canvas.width;
                    var height = this.ctx.canvas.height;
                    var defaultBackgroundColor = background || "#ffffff";
                    this.ctx.save();
                    if (this.foregroundColor && this.backgroundColor) {
                      this.ctx.fillStyle = this.foregroundColor;
                      var fg = this.foregroundColor = this.ctx.fillStyle;
                      this.ctx.fillStyle = this.backgroundColor;
                      var bg = this.backgroundColor = this.ctx.fillStyle;
                      var isValidDefaultBg = true;
                      var defaultBg = defaultBackgroundColor;
                      this.ctx.fillStyle = defaultBackgroundColor;
                      defaultBg = this.ctx.fillStyle;
                      isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);
                      if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
                        this.foregroundColor = this.backgroundColor = null;
                      } else {
                        var cB = parseInt(defaultBg.slice(1), 16);
                        var rB = (cB && 16711680) >> 16;
                        var gB = (cB && 65280) >> 8;
                        var bB = cB && 255;
                        var newComp = function newComp2(x) {
                          x /= 255;
                          return x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
                        };
                        var lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));
                        this.selectColor = function(r, g, b) {
                          var lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                          return Math.round(lumC) === lumB ? bg : fg;
                        };
                      }
                    }
                    this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
                    this.ctx.fillRect(0, 0, width, height);
                    this.ctx.restore();
                    if (transparency) {
                      var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                      this.compositeCtx = this.ctx;
                      this.transparentCanvas = transparentCanvas.canvas;
                      this.ctx = transparentCanvas.context;
                      this.ctx.save();
                      this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                    }
                    this.ctx.save();
                    resetCtxToDefault(this.ctx, this.foregroundColor);
                    if (transform) {
                      this.ctx.transform.apply(this.ctx, transform);
                      this.outputScaleX = transform[0];
                      this.outputScaleY = transform[0];
                    }
                    this.ctx.transform.apply(this.ctx, viewport.transform);
                    this.viewportScale = viewport.scale;
                    this.baseTransform = this.ctx.mozCurrentTransform.slice();
                    if (this.imageLayer) {
                      this.imageLayer.beginLayout();
                    }
                  }
                }, {
                  key: "executeOperatorList",
                  value: function executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                    var argsArray = operatorList.argsArray;
                    var fnArray = operatorList.fnArray;
                    var i = executionStartIdx || 0;
                    var argsArrayLen = argsArray.length;
                    if (argsArrayLen === i) {
                      return i;
                    }
                    var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                    var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                    var steps = 0;
                    var commonObjs = this.commonObjs;
                    var objs = this.objs;
                    var fnId;
                    while (true) {
                      if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                        stepper.breakIt(i, continueCallback);
                        return i;
                      }
                      fnId = fnArray[i];
                      if (fnId !== _util2.OPS.dependency) {
                        this[fnId].apply(this, argsArray[i]);
                      } else {
                        var _iterator3 = _createForOfIteratorHelper2(argsArray[i]), _step3;
                        try {
                          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                            var depObjId = _step3.value;
                            var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                            if (!objsPool.has(depObjId)) {
                              objsPool.get(depObjId, continueCallback);
                              return i;
                            }
                          }
                        } catch (err) {
                          _iterator3.e(err);
                        } finally {
                          _iterator3.f();
                        }
                      }
                      i++;
                      if (i === argsArrayLen) {
                        return i;
                      }
                      if (chunkOperations && ++steps > EXECUTION_STEPS) {
                        if (Date.now() > endTime) {
                          continueCallback();
                          return i;
                        }
                        steps = 0;
                      }
                    }
                  }
                }, {
                  key: "endDrawing",
                  value: function endDrawing() {
                    while (this.stateStack.length || this.inSMaskMode) {
                      this.restore();
                    }
                    this.ctx.restore();
                    if (this.transparentCanvas) {
                      this.ctx = this.compositeCtx;
                      this.ctx.save();
                      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                      this.ctx.drawImage(this.transparentCanvas, 0, 0);
                      this.ctx.restore();
                      this.transparentCanvas = null;
                    }
                    this.cachedCanvases.clear();
                    this.cachedPatterns.clear();
                    var _iterator4 = _createForOfIteratorHelper2(this._cachedBitmapsMap.values()), _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                        var cache = _step4.value;
                        var _iterator5 = _createForOfIteratorHelper2(cache.values()), _step5;
                        try {
                          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                            var canvas = _step5.value;
                            if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                              canvas.width = canvas.height = 0;
                            }
                          }
                        } catch (err) {
                          _iterator5.e(err);
                        } finally {
                          _iterator5.f();
                        }
                        cache.clear();
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    this._cachedBitmapsMap.clear();
                    if (this.imageLayer) {
                      this.imageLayer.endLayout();
                    }
                  }
                }, {
                  key: "_scaleImage",
                  value: function _scaleImage(img, inverseTransform) {
                    var width = img.width;
                    var height = img.height;
                    var widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                    var heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                    var paintWidth = width, paintHeight = height;
                    var tmpCanvasId = "prescale1";
                    var tmpCanvas, tmpCtx;
                    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                      var newWidth = paintWidth, newHeight = paintHeight;
                      if (widthScale > 2 && paintWidth > 1) {
                        newWidth = Math.ceil(paintWidth / 2);
                        widthScale /= paintWidth / newWidth;
                      }
                      if (heightScale > 2 && paintHeight > 1) {
                        newHeight = Math.ceil(paintHeight / 2);
                        heightScale /= paintHeight / newHeight;
                      }
                      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight, false);
                      tmpCtx = tmpCanvas.context;
                      tmpCtx.clearRect(0, 0, newWidth, newHeight);
                      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                      img = tmpCanvas.canvas;
                      paintWidth = newWidth;
                      paintHeight = newHeight;
                      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                    }
                    return {
                      img,
                      paintWidth,
                      paintHeight
                    };
                  }
                }, {
                  key: "_createMaskCanvas",
                  value: function _createMaskCanvas(img) {
                    var ctx = this.ctx;
                    var width = img.width, height = img.height;
                    var fillColor = this.current.fillColor;
                    var isPatternFill = this.current.patternFill;
                    var currentTransform = ctx.mozCurrentTransform;
                    var cache, cacheKey, scaled, maskCanvas;
                    if ((img.bitmap || img.data) && img.count > 1) {
                      var mainKey = img.bitmap || img.data.buffer;
                      var withoutTranslation = currentTransform.slice(0, 4);
                      cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
                      cache = this._cachedBitmapsMap.get(mainKey);
                      if (!cache) {
                        cache = /* @__PURE__ */ new Map();
                        this._cachedBitmapsMap.set(mainKey, cache);
                      }
                      var cachedImage = cache.get(cacheKey);
                      if (cachedImage && !isPatternFill) {
                        var _offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                        var _offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                        return {
                          canvas: cachedImage,
                          offsetX: _offsetX,
                          offsetY: _offsetY
                        };
                      }
                      scaled = cachedImage;
                    }
                    if (!scaled) {
                      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
                      putBinaryImageMask(maskCanvas.context, img);
                    }
                    var maskToCanvas = _util2.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
                    maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                    var cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                    var cord2 = _util2.Util.applyTransform([width, height], maskToCanvas);
                    var rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                    var drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                    var drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                    var fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight, true);
                    var fillCtx = fillCanvas.context;
                    var offsetX = Math.min(cord1[0], cord2[0]);
                    var offsetY = Math.min(cord1[1], cord2[1]);
                    fillCtx.translate(-offsetX, -offsetY);
                    fillCtx.transform.apply(fillCtx, maskToCanvas);
                    if (!scaled) {
                      scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);
                      scaled = scaled.img;
                      if (cache && isPatternFill) {
                        cache.set(cacheKey, scaled);
                      }
                    }
                    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);
                    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
                    fillCtx.globalCompositeOperation = "source-in";
                    var inverse = _util2.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);
                    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
                    fillCtx.fillRect(0, 0, width, height);
                    if (cache && !isPatternFill) {
                      this.cachedCanvases["delete"]("fillCanvas");
                      cache.set(cacheKey, fillCanvas.canvas);
                    }
                    return {
                      canvas: fillCanvas.canvas,
                      offsetX: Math.round(offsetX),
                      offsetY: Math.round(offsetY)
                    };
                  }
                }, {
                  key: "setLineWidth",
                  value: function setLineWidth(width) {
                    if (width !== this.current.lineWidth) {
                      this._cachedScaleForStroking = null;
                    }
                    this.current.lineWidth = width;
                    this.ctx.lineWidth = width;
                  }
                }, {
                  key: "setLineCap",
                  value: function setLineCap(style) {
                    this.ctx.lineCap = LINE_CAP_STYLES[style];
                  }
                }, {
                  key: "setLineJoin",
                  value: function setLineJoin(style) {
                    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                  }
                }, {
                  key: "setMiterLimit",
                  value: function setMiterLimit(limit) {
                    this.ctx.miterLimit = limit;
                  }
                }, {
                  key: "setDash",
                  value: function setDash(dashArray, dashPhase) {
                    var ctx = this.ctx;
                    if (ctx.setLineDash !== void 0) {
                      ctx.setLineDash(dashArray);
                      ctx.lineDashOffset = dashPhase;
                    }
                  }
                }, {
                  key: "setRenderingIntent",
                  value: function setRenderingIntent(intent) {
                  }
                }, {
                  key: "setFlatness",
                  value: function setFlatness(flatness) {
                  }
                }, {
                  key: "setGState",
                  value: function setGState(states) {
                    for (var i = 0, ii = states.length; i < ii; i++) {
                      var state = states[i];
                      var key = state[0];
                      var value = state[1];
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value);
                          break;
                        case "LC":
                          this.setLineCap(value);
                          break;
                        case "LJ":
                          this.setLineJoin(value);
                          break;
                        case "ML":
                          this.setMiterLimit(value);
                          break;
                        case "D":
                          this.setDash(value[0], value[1]);
                          break;
                        case "RI":
                          this.setRenderingIntent(value);
                          break;
                        case "FL":
                          this.setFlatness(value);
                          break;
                        case "Font":
                          this.setFont(value[0], value[1]);
                          break;
                        case "CA":
                          this.current.strokeAlpha = state[1];
                          break;
                        case "ca":
                          this.current.fillAlpha = state[1];
                          this.ctx.globalAlpha = state[1];
                          break;
                        case "BM":
                          this.ctx.globalCompositeOperation = value;
                          break;
                        case "SMask":
                          this.current.activeSMask = value ? this.tempSMask : null;
                          this.tempSMask = null;
                          this.checkSMaskState();
                          break;
                        case "TR":
                          this.current.transferMaps = value;
                      }
                    }
                  }
                }, {
                  key: "inSMaskMode",
                  get: function get2() {
                    return !!this.suspendedCtx;
                  }
                }, {
                  key: "checkSMaskState",
                  value: function checkSMaskState() {
                    var inSMaskMode = this.inSMaskMode;
                    if (this.current.activeSMask && !inSMaskMode) {
                      this.beginSMaskMode();
                    } else if (!this.current.activeSMask && inSMaskMode) {
                      this.endSMaskMode();
                    }
                  }
                }, {
                  key: "beginSMaskMode",
                  value: function beginSMaskMode() {
                    if (this.inSMaskMode) {
                      throw new Error("beginSMaskMode called while already in smask mode");
                    }
                    var drawnWidth = this.ctx.canvas.width;
                    var drawnHeight = this.ctx.canvas.height;
                    var cacheId = "smaskGroupAt" + this.groupLevel;
                    var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                    this.suspendedCtx = this.ctx;
                    this.ctx = scratchCanvas.context;
                    var ctx = this.ctx;
                    ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);
                    copyCtxState(this.suspendedCtx, ctx);
                    mirrorContextOperations(ctx, this.suspendedCtx);
                    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  }
                }, {
                  key: "endSMaskMode",
                  value: function endSMaskMode() {
                    if (!this.inSMaskMode) {
                      throw new Error("endSMaskMode called while not in smask mode");
                    }
                    this.ctx._removeMirroring();
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.ctx = this.suspendedCtx;
                    this.suspendedCtx = null;
                  }
                }, {
                  key: "compose",
                  value: function compose(dirtyBox) {
                    if (!this.current.activeSMask) {
                      return;
                    }
                    if (!dirtyBox) {
                      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                    } else {
                      dirtyBox[0] = Math.floor(dirtyBox[0]);
                      dirtyBox[1] = Math.floor(dirtyBox[1]);
                      dirtyBox[2] = Math.ceil(dirtyBox[2]);
                      dirtyBox[3] = Math.ceil(dirtyBox[3]);
                    }
                    var smask = this.current.activeSMask;
                    var suspendedCtx = this.suspendedCtx;
                    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                    this.ctx.restore();
                  }
                }, {
                  key: "save",
                  value: function save() {
                    if (this.inSMaskMode) {
                      copyCtxState(this.ctx, this.suspendedCtx);
                      this.suspendedCtx.save();
                    } else {
                      this.ctx.save();
                    }
                    var old = this.current;
                    this.stateStack.push(old);
                    this.current = old.clone();
                  }
                }, {
                  key: "restore",
                  value: function restore() {
                    if (this.stateStack.length === 0 && this.inSMaskMode) {
                      this.endSMaskMode();
                    }
                    if (this.stateStack.length !== 0) {
                      this.current = this.stateStack.pop();
                      if (this.inSMaskMode) {
                        this.suspendedCtx.restore();
                        copyCtxState(this.suspendedCtx, this.ctx);
                      } else {
                        this.ctx.restore();
                      }
                      this.checkSMaskState();
                      this.pendingClip = null;
                      this._cachedScaleForStroking = null;
                      this._cachedGetSinglePixelWidth = null;
                    }
                  }
                }, {
                  key: "transform",
                  value: function transform(a, b, c, d, e, f) {
                    this.ctx.transform(a, b, c, d, e, f);
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                }, {
                  key: "constructPath",
                  value: function constructPath(ops, args, minMax) {
                    var ctx = this.ctx;
                    var current = this.current;
                    var x = current.x, y = current.y;
                    var startX, startY;
                    var currentTransform = ctx.mozCurrentTransform;
                    var isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                    var minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                    for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                      switch (ops[i] | 0) {
                        case _util2.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          var width = args[j++];
                          var height = args[j++];
                          var xw = x + width;
                          var yh = y + height;
                          ctx.moveTo(x, y);
                          if (width === 0 || height === 0) {
                            ctx.lineTo(xw, yh);
                          } else {
                            ctx.lineTo(xw, y);
                            ctx.lineTo(xw, yh);
                            ctx.lineTo(x, yh);
                          }
                          if (!isScalingMatrix) {
                            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                          }
                          ctx.closePath();
                          break;
                        case _util2.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          ctx.moveTo(x, y);
                          if (!isScalingMatrix) {
                            current.updatePathMinMax(currentTransform, x, y);
                          }
                          break;
                        case _util2.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          ctx.lineTo(x, y);
                          if (!isScalingMatrix) {
                            current.updatePathMinMax(currentTransform, x, y);
                          }
                          break;
                        case _util2.OPS.curveTo:
                          startX = x;
                          startY = y;
                          x = args[j + 4];
                          y = args[j + 5];
                          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                          j += 6;
                          break;
                        case _util2.OPS.curveTo2:
                          startX = x;
                          startY = y;
                          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;
                        case _util2.OPS.curveTo3:
                          startX = x;
                          startY = y;
                          x = args[j + 2];
                          y = args[j + 3];
                          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                          j += 4;
                          break;
                        case _util2.OPS.closePath:
                          ctx.closePath();
                          break;
                      }
                    }
                    if (isScalingMatrix) {
                      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                    }
                    current.setCurrentPoint(x, y);
                  }
                }, {
                  key: "closePath",
                  value: function closePath() {
                    this.ctx.closePath();
                  }
                }, {
                  key: "stroke",
                  value: function stroke(consumePath) {
                    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                    var ctx = this.ctx;
                    var strokeColor = this.current.strokeColor;
                    ctx.globalAlpha = this.current.strokeAlpha;
                    if (this.contentVisible) {
                      if (_typeof2(strokeColor) === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
                        ctx.save();
                        ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);
                        this.rescaleAndStroke(false);
                        ctx.restore();
                      } else {
                        this.rescaleAndStroke(true);
                      }
                    }
                    if (consumePath) {
                      this.consumePath(this.current.getClippedPathBoundingBox());
                    }
                    ctx.globalAlpha = this.current.fillAlpha;
                  }
                }, {
                  key: "closeStroke",
                  value: function closeStroke() {
                    this.closePath();
                    this.stroke();
                  }
                }, {
                  key: "fill",
                  value: function fill(consumePath) {
                    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                    var ctx = this.ctx;
                    var fillColor = this.current.fillColor;
                    var isPatternFill = this.current.patternFill;
                    var needRestore = false;
                    if (isPatternFill) {
                      ctx.save();
                      ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
                      needRestore = true;
                    }
                    var intersect = this.current.getClippedPathBoundingBox();
                    if (this.contentVisible && intersect !== null) {
                      if (this.pendingEOFill) {
                        ctx.fill("evenodd");
                        this.pendingEOFill = false;
                      } else {
                        ctx.fill();
                      }
                    }
                    if (needRestore) {
                      ctx.restore();
                    }
                    if (consumePath) {
                      this.consumePath(intersect);
                    }
                  }
                }, {
                  key: "eoFill",
                  value: function eoFill() {
                    this.pendingEOFill = true;
                    this.fill();
                  }
                }, {
                  key: "fillStroke",
                  value: function fillStroke() {
                    this.fill(false);
                    this.stroke(false);
                    this.consumePath();
                  }
                }, {
                  key: "eoFillStroke",
                  value: function eoFillStroke() {
                    this.pendingEOFill = true;
                    this.fillStroke();
                  }
                }, {
                  key: "closeFillStroke",
                  value: function closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }
                }, {
                  key: "closeEOFillStroke",
                  value: function closeEOFillStroke() {
                    this.pendingEOFill = true;
                    this.closePath();
                    this.fillStroke();
                  }
                }, {
                  key: "endPath",
                  value: function endPath() {
                    this.consumePath();
                  }
                }, {
                  key: "clip",
                  value: function clip() {
                    this.pendingClip = NORMAL_CLIP;
                  }
                }, {
                  key: "eoClip",
                  value: function eoClip() {
                    this.pendingClip = EO_CLIP;
                  }
                }, {
                  key: "beginText",
                  value: function beginText() {
                    this.current.textMatrix = _util2.IDENTITY_MATRIX;
                    this.current.textMatrixScale = 1;
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                  }
                }, {
                  key: "endText",
                  value: function endText() {
                    var paths = this.pendingTextPaths;
                    var ctx = this.ctx;
                    if (paths === void 0) {
                      ctx.beginPath();
                      return;
                    }
                    ctx.save();
                    ctx.beginPath();
                    for (var i = 0; i < paths.length; i++) {
                      var path = paths[i];
                      ctx.setTransform.apply(ctx, path.transform);
                      ctx.translate(path.x, path.y);
                      path.addToPath(ctx, path.fontSize);
                    }
                    ctx.restore();
                    ctx.clip();
                    ctx.beginPath();
                    delete this.pendingTextPaths;
                  }
                }, {
                  key: "setCharSpacing",
                  value: function setCharSpacing(spacing) {
                    this.current.charSpacing = spacing;
                  }
                }, {
                  key: "setWordSpacing",
                  value: function setWordSpacing(spacing) {
                    this.current.wordSpacing = spacing;
                  }
                }, {
                  key: "setHScale",
                  value: function setHScale(scale) {
                    this.current.textHScale = scale / 100;
                  }
                }, {
                  key: "setLeading",
                  value: function setLeading(leading) {
                    this.current.leading = -leading;
                  }
                }, {
                  key: "setFont",
                  value: function setFont(fontRefName, size) {
                    var fontObj = this.commonObjs.get(fontRefName);
                    var current = this.current;
                    if (!fontObj) {
                      throw new Error("Can't find font for ".concat(fontRefName));
                    }
                    current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                      (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                    }
                    if (size < 0) {
                      size = -size;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    this.current.font = fontObj;
                    this.current.fontSize = size;
                    if (fontObj.isType3Font) {
                      return;
                    }
                    var name = fontObj.loadedName || "sans-serif";
                    var bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    var italic = fontObj.italic ? "italic" : "normal";
                    var typeface = '"'.concat(name, '", ').concat(fontObj.fallbackName);
                    var browserFontSize = size;
                    if (size < MIN_FONT_SIZE) {
                      browserFontSize = MIN_FONT_SIZE;
                    } else if (size > MAX_FONT_SIZE) {
                      browserFontSize = MAX_FONT_SIZE;
                    }
                    this.current.fontSizeScale = size / browserFontSize;
                    this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
                  }
                }, {
                  key: "setTextRenderingMode",
                  value: function setTextRenderingMode(mode) {
                    this.current.textRenderingMode = mode;
                  }
                }, {
                  key: "setTextRise",
                  value: function setTextRise(rise) {
                    this.current.textRise = rise;
                  }
                }, {
                  key: "moveText",
                  value: function moveText(x, y) {
                    this.current.x = this.current.lineX += x;
                    this.current.y = this.current.lineY += y;
                  }
                }, {
                  key: "setLeadingMoveText",
                  value: function setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }
                }, {
                  key: "setTextMatrix",
                  value: function setTextMatrix(a, b, c, d, e, f) {
                    this.current.textMatrix = [a, b, c, d, e, f];
                    this.current.textMatrixScale = Math.hypot(a, b);
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                  }
                }, {
                  key: "nextLine",
                  value: function nextLine() {
                    this.moveText(0, this.current.leading);
                  }
                }, {
                  key: "paintChar",
                  value: function paintChar(character, x, y, patternTransform) {
                    var ctx = this.ctx;
                    var current = this.current;
                    var font = current.font;
                    var textRenderingMode = current.textRenderingMode;
                    var fontSize = current.fontSize / current.fontSizeScale;
                    var fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    var isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                    var patternFill = current.patternFill && !font.missingFile;
                    var addToPath;
                    if (font.disableFontFace || isAddToPathSet || patternFill) {
                      addToPath = font.getPathGenerator(this.commonObjs, character);
                    }
                    if (font.disableFontFace || patternFill) {
                      ctx.save();
                      ctx.translate(x, y);
                      ctx.beginPath();
                      addToPath(ctx, fontSize);
                      if (patternTransform) {
                        ctx.setTransform.apply(ctx, patternTransform);
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.fill();
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.stroke();
                      }
                      ctx.restore();
                    } else {
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.fillText(character, x, y);
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.strokeText(character, x, y);
                      }
                    }
                    if (isAddToPathSet) {
                      var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                      paths.push({
                        transform: ctx.mozCurrentTransform,
                        x,
                        y,
                        fontSize,
                        addToPath
                      });
                    }
                  }
                }, {
                  key: "isFontSubpixelAAEnabled",
                  get: function get2() {
                    var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10, false), ctx = _this$cachedCanvases$.context;
                    ctx.scale(1.5, 1);
                    ctx.fillText("I", 0, 10);
                    var data = ctx.getImageData(0, 0, 10, 10).data;
                    var enabled = false;
                    for (var i = 3; i < data.length; i += 4) {
                      if (data[i] > 0 && data[i] < 255) {
                        enabled = true;
                        break;
                      }
                    }
                    return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                  }
                }, {
                  key: "showText",
                  value: function showText(glyphs) {
                    var current = this.current;
                    var font = current.font;
                    if (font.isType3Font) {
                      return this.showType3Text(glyphs);
                    }
                    var fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return void 0;
                    }
                    var ctx = this.ctx;
                    var fontSizeScale = current.fontSizeScale;
                    var charSpacing = current.charSpacing;
                    var wordSpacing = current.wordSpacing;
                    var fontDirection = current.fontDirection;
                    var textHScale = current.textHScale * fontDirection;
                    var glyphsLength = glyphs.length;
                    var vertical = font.vertical;
                    var spacingDir = vertical ? 1 : -1;
                    var defaultVMetrics = font.defaultVMetrics;
                    var widthAdvanceScale = fontSize * current.fontMatrix[0];
                    var simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                    ctx.save();
                    ctx.transform.apply(ctx, current.textMatrix);
                    ctx.translate(current.x, current.y + current.textRise);
                    if (fontDirection > 0) {
                      ctx.scale(textHScale, -1);
                    } else {
                      ctx.scale(textHScale, 1);
                    }
                    var patternTransform;
                    if (current.patternFill) {
                      ctx.save();
                      var pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
                      patternTransform = ctx.mozCurrentTransform;
                      ctx.restore();
                      ctx.fillStyle = pattern;
                    }
                    var lineWidth = current.lineWidth;
                    var scale = current.textMatrixScale;
                    if (scale === 0 || lineWidth === 0) {
                      var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        lineWidth = this.getSinglePixelWidth();
                      }
                    } else {
                      lineWidth /= scale;
                    }
                    if (fontSizeScale !== 1) {
                      ctx.scale(fontSizeScale, fontSizeScale);
                      lineWidth /= fontSizeScale;
                    }
                    ctx.lineWidth = lineWidth;
                    var x = 0, i;
                    for (i = 0; i < glyphsLength; ++i) {
                      var glyph = glyphs[i];
                      if (typeof glyph === "number") {
                        x += spacingDir * glyph * fontSize / 1e3;
                        continue;
                      }
                      var restoreNeeded = false;
                      var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      var character = glyph.fontChar;
                      var accent = glyph.accent;
                      var scaledX = void 0, scaledY = void 0;
                      var width = glyph.width;
                      if (vertical) {
                        var vmetric = glyph.vmetric || defaultVMetrics;
                        var vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                        var vy = vmetric[2] * widthAdvanceScale;
                        width = vmetric ? -vmetric[0] : width;
                        scaledX = vx / fontSizeScale;
                        scaledY = (x + vy) / fontSizeScale;
                      } else {
                        scaledX = x / fontSizeScale;
                        scaledY = 0;
                      }
                      if (font.remeasure && width > 0) {
                        var measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                          var characterScaleX = width / measuredWidth;
                          restoreNeeded = true;
                          ctx.save();
                          ctx.scale(characterScaleX, 1);
                          scaledX /= characterScaleX;
                        } else if (width !== measuredWidth) {
                          scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                        }
                      }
                      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                        if (simpleFillText && !accent) {
                          ctx.fillText(character, scaledX, scaledY);
                        } else {
                          this.paintChar(character, scaledX, scaledY, patternTransform);
                          if (accent) {
                            var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                            var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                          }
                        }
                      }
                      var charWidth = void 0;
                      if (vertical) {
                        charWidth = width * widthAdvanceScale - spacing * fontDirection;
                      } else {
                        charWidth = width * widthAdvanceScale + spacing * fontDirection;
                      }
                      x += charWidth;
                      if (restoreNeeded) {
                        ctx.restore();
                      }
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    ctx.restore();
                    this.compose();
                    return void 0;
                  }
                }, {
                  key: "showType3Text",
                  value: function showType3Text(glyphs) {
                    var ctx = this.ctx;
                    var current = this.current;
                    var font = current.font;
                    var fontSize = current.fontSize;
                    var fontDirection = current.fontDirection;
                    var spacingDir = font.vertical ? 1 : -1;
                    var charSpacing = current.charSpacing;
                    var wordSpacing = current.wordSpacing;
                    var textHScale = current.textHScale * fontDirection;
                    var fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    var glyphsLength = glyphs.length;
                    var isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                    var i, glyph, width, spacingLength;
                    if (isTextInvisible || fontSize === 0) {
                      return;
                    }
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                    ctx.save();
                    ctx.transform.apply(ctx, current.textMatrix);
                    ctx.translate(current.x, current.y);
                    ctx.scale(textHScale, fontDirection);
                    for (i = 0; i < glyphsLength; ++i) {
                      glyph = glyphs[i];
                      if (typeof glyph === "number") {
                        spacingLength = spacingDir * glyph * fontSize / 1e3;
                        this.ctx.translate(spacingLength, 0);
                        current.x += spacingLength * textHScale;
                        continue;
                      }
                      var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      var operatorList = font.charProcOperatorList[glyph.operatorListId];
                      if (!operatorList) {
                        (0, _util2.warn)('Type3 character "'.concat(glyph.operatorListId, '" is not available.'));
                        continue;
                      }
                      if (this.contentVisible) {
                        this.processingType3 = glyph;
                        this.save();
                        ctx.scale(fontSize, fontSize);
                        ctx.transform.apply(ctx, fontMatrix);
                        this.executeOperatorList(operatorList);
                        this.restore();
                      }
                      var transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                      width = transformed[0] * fontSize + spacing;
                      ctx.translate(width, 0);
                      current.x += width * textHScale;
                    }
                    ctx.restore();
                    this.processingType3 = null;
                  }
                }, {
                  key: "setCharWidth",
                  value: function setCharWidth(xWidth, yWidth) {
                  }
                }, {
                  key: "setCharWidthAndBounds",
                  value: function setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                    this.ctx.rect(llx, lly, urx - llx, ury - lly);
                    this.ctx.clip();
                    this.endPath();
                  }
                }, {
                  key: "getColorN_Pattern",
                  value: function getColorN_Pattern(IR) {
                    var _this = this;
                    var pattern;
                    if (IR[0] === "TilingPattern") {
                      var color = IR[1];
                      var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                      var canvasGraphicsFactory = {
                        createCanvasGraphics: function createCanvasGraphics(ctx) {
                          return new CanvasGraphics2(ctx, _this.commonObjs, _this.objs, _this.canvasFactory);
                        }
                      };
                      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                    } else {
                      pattern = this._getPattern(IR[1], IR[2]);
                    }
                    return pattern;
                  }
                }, {
                  key: "setStrokeColorN",
                  value: function setStrokeColorN() {
                    this.current.strokeColor = this.getColorN_Pattern(arguments);
                  }
                }, {
                  key: "setFillColorN",
                  value: function setFillColorN() {
                    this.current.fillColor = this.getColorN_Pattern(arguments);
                    this.current.patternFill = true;
                  }
                }, {
                  key: "setStrokeRGBColor",
                  value: function setStrokeRGBColor(r, g, b) {
                    var _this$selectColor;
                    var color = ((_this$selectColor = this.selectColor) === null || _this$selectColor === void 0 ? void 0 : _this$selectColor.call(this, r, g, b)) || _util2.Util.makeHexColor(r, g, b);
                    this.ctx.strokeStyle = color;
                    this.current.strokeColor = color;
                  }
                }, {
                  key: "setFillRGBColor",
                  value: function setFillRGBColor(r, g, b) {
                    var _this$selectColor2;
                    var color = ((_this$selectColor2 = this.selectColor) === null || _this$selectColor2 === void 0 ? void 0 : _this$selectColor2.call(this, r, g, b)) || _util2.Util.makeHexColor(r, g, b);
                    this.ctx.fillStyle = color;
                    this.current.fillColor = color;
                    this.current.patternFill = false;
                  }
                }, {
                  key: "_getPattern",
                  value: function _getPattern(objId) {
                    var matrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    var pattern;
                    if (this.cachedPatterns.has(objId)) {
                      pattern = this.cachedPatterns.get(objId);
                    } else {
                      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
                      this.cachedPatterns.set(objId, pattern);
                    }
                    if (matrix) {
                      pattern.matrix = matrix;
                    }
                    return pattern;
                  }
                }, {
                  key: "shadingFill",
                  value: function shadingFill(objId) {
                    if (!this.contentVisible) {
                      return;
                    }
                    var ctx = this.ctx;
                    this.save();
                    var pattern = this._getPattern(objId);
                    ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);
                    var inv = ctx.mozCurrentTransformInverse;
                    if (inv) {
                      var canvas = ctx.canvas;
                      var width = canvas.width;
                      var height = canvas.height;
                      var bl = _util2.Util.applyTransform([0, 0], inv);
                      var br = _util2.Util.applyTransform([0, height], inv);
                      var ul = _util2.Util.applyTransform([width, 0], inv);
                      var ur = _util2.Util.applyTransform([width, height], inv);
                      var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                      var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                      var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                      var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                    } else {
                      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                    }
                    this.compose(this.current.getClippedPathBoundingBox());
                    this.restore();
                  }
                }, {
                  key: "beginInlineImage",
                  value: function beginInlineImage() {
                    (0, _util2.unreachable)("Should not call beginInlineImage");
                  }
                }, {
                  key: "beginImageData",
                  value: function beginImageData() {
                    (0, _util2.unreachable)("Should not call beginImageData");
                  }
                }, {
                  key: "paintFormXObjectBegin",
                  value: function paintFormXObjectBegin(matrix, bbox) {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.save();
                    this.baseTransformStack.push(this.baseTransform);
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform.apply(this, matrix);
                    }
                    this.baseTransform = this.ctx.mozCurrentTransform;
                    if (bbox) {
                      var width = bbox[2] - bbox[0];
                      var height = bbox[3] - bbox[1];
                      this.ctx.rect(bbox[0], bbox[1], width, height);
                      this.current.updateRectMinMax(this.ctx.mozCurrentTransform, bbox);
                      this.clip();
                      this.endPath();
                    }
                  }
                }, {
                  key: "paintFormXObjectEnd",
                  value: function paintFormXObjectEnd() {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.restore();
                    this.baseTransform = this.baseTransformStack.pop();
                  }
                }, {
                  key: "beginGroup",
                  value: function beginGroup(group) {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.save();
                    if (this.inSMaskMode) {
                      this.endSMaskMode();
                      this.current.activeSMask = null;
                    }
                    var currentCtx = this.ctx;
                    if (!group.isolated) {
                      (0, _util2.info)("TODO: Support non-isolated groups.");
                    }
                    if (group.knockout) {
                      (0, _util2.warn)("Knockout groups not supported.");
                    }
                    var currentTransform = currentCtx.mozCurrentTransform;
                    if (group.matrix) {
                      currentCtx.transform.apply(currentCtx, group.matrix);
                    }
                    if (!group.bbox) {
                      throw new Error("Bounding box is required.");
                    }
                    var bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                    var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                    bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                    var offsetX = Math.floor(bounds[0]);
                    var offsetY = Math.floor(bounds[1]);
                    var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                    var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                    var scaleX = 1, scaleY = 1;
                    if (drawnWidth > MAX_GROUP_SIZE) {
                      scaleX = drawnWidth / MAX_GROUP_SIZE;
                      drawnWidth = MAX_GROUP_SIZE;
                    }
                    if (drawnHeight > MAX_GROUP_SIZE) {
                      scaleY = drawnHeight / MAX_GROUP_SIZE;
                      drawnHeight = MAX_GROUP_SIZE;
                    }
                    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                    var cacheId = "groupAt" + this.groupLevel;
                    if (group.smask) {
                      cacheId += "_smask_" + this.smaskCounter++ % 2;
                    }
                    var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                    var groupCtx = scratchCanvas.context;
                    groupCtx.scale(1 / scaleX, 1 / scaleY);
                    groupCtx.translate(-offsetX, -offsetY);
                    groupCtx.transform.apply(groupCtx, currentTransform);
                    if (group.smask) {
                      this.smaskStack.push({
                        canvas: scratchCanvas.canvas,
                        context: groupCtx,
                        offsetX,
                        offsetY,
                        scaleX,
                        scaleY,
                        subtype: group.smask.subtype,
                        backdrop: group.smask.backdrop,
                        transferMap: group.smask.transferMap || null,
                        startTransformInverse: null
                      });
                    } else {
                      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                      currentCtx.translate(offsetX, offsetY);
                      currentCtx.scale(scaleX, scaleY);
                      currentCtx.save();
                    }
                    copyCtxState(currentCtx, groupCtx);
                    this.ctx = groupCtx;
                    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                    this.groupStack.push(currentCtx);
                    this.groupLevel++;
                  }
                }, {
                  key: "endGroup",
                  value: function endGroup(group) {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.groupLevel--;
                    var groupCtx = this.ctx;
                    var ctx = this.groupStack.pop();
                    this.ctx = ctx;
                    this.ctx.imageSmoothingEnabled = false;
                    if (group.smask) {
                      this.tempSMask = this.smaskStack.pop();
                      this.restore();
                    } else {
                      this.ctx.restore();
                      var currentMtx = this.ctx.mozCurrentTransform;
                      this.restore();
                      this.ctx.save();
                      this.ctx.setTransform.apply(this.ctx, currentMtx);
                      var dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                      this.ctx.drawImage(groupCtx.canvas, 0, 0);
                      this.ctx.restore();
                      this.compose(dirtyBox);
                    }
                  }
                }, {
                  key: "beginAnnotations",
                  value: function beginAnnotations() {
                    this.save();
                    if (this.baseTransform) {
                      this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                    }
                  }
                }, {
                  key: "endAnnotations",
                  value: function endAnnotations() {
                    this.restore();
                  }
                }, {
                  key: "beginAnnotation",
                  value: function beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
                    this.save();
                    if (Array.isArray(rect) && rect.length === 4) {
                      var width = rect[2] - rect[0];
                      var height = rect[3] - rect[1];
                      if (hasOwnCanvas && this.annotationCanvasMap) {
                        transform = transform.slice();
                        transform[4] -= rect[0];
                        transform[5] -= rect[1];
                        rect = rect.slice();
                        rect[0] = rect[1] = 0;
                        rect[2] = width;
                        rect[3] = height;
                        var _Util$singularValueDe = _util2.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform), _Util$singularValueDe2 = _slicedToArray2(_Util$singularValueDe, 2), scaleX = _Util$singularValueDe2[0], scaleY = _Util$singularValueDe2[1];
                        var viewportScale = this.viewportScale;
                        var canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                        var canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                        var _this$annotationCanva = this.annotationCanvas, canvas = _this$annotationCanva.canvas, context = _this$annotationCanva.context;
                        var viewportScaleFactorStr = "var(--zoom-factor) * ".concat(_display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                        canvas.style.width = "calc(".concat(width, "px * ").concat(viewportScaleFactorStr, ")");
                        canvas.style.height = "calc(".concat(height, "px * ").concat(viewportScaleFactorStr, ")");
                        this.annotationCanvasMap.set(id, canvas);
                        this.annotationCanvas.savedCtx = this.ctx;
                        this.ctx = context;
                        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                        addContextCurrentTransform(this.ctx);
                        resetCtxToDefault(this.ctx, this.foregroundColor);
                      } else {
                        resetCtxToDefault(this.ctx, this.foregroundColor);
                        this.ctx.rect(rect[0], rect[1], width, height);
                        this.ctx.clip();
                        this.endPath();
                      }
                    }
                    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                    this.transform.apply(this, transform);
                    this.transform.apply(this, matrix);
                  }
                }, {
                  key: "endAnnotation",
                  value: function endAnnotation() {
                    if (this.annotationCanvas) {
                      this.ctx = this.annotationCanvas.savedCtx;
                      delete this.annotationCanvas.savedCtx;
                      delete this.annotationCanvas;
                    }
                    this.restore();
                  }
                }, {
                  key: "paintImageMaskXObject",
                  value: function paintImageMaskXObject(img) {
                    if (!this.contentVisible) {
                      return;
                    }
                    var count = img.count;
                    img = this.getObject(img.data, img);
                    img.count = count;
                    var ctx = this.ctx;
                    var glyph = this.processingType3;
                    if (glyph) {
                      if (glyph.compiled === void 0) {
                        glyph.compiled = compileType3Glyph(img);
                      }
                      if (glyph.compiled) {
                        glyph.compiled(ctx);
                        return;
                      }
                    }
                    var mask = this._createMaskCanvas(img);
                    var maskCanvas = mask.canvas;
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                    ctx.restore();
                    this.compose();
                  }
                }, {
                  key: "paintImageMaskXObjectRepeat",
                  value: function paintImageMaskXObjectRepeat(img, scaleX) {
                    var skewX = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                    var skewY = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                    var scaleY = arguments.length > 4 ? arguments[4] : void 0;
                    var positions = arguments.length > 5 ? arguments[5] : void 0;
                    if (!this.contentVisible) {
                      return;
                    }
                    img = this.getObject(img.data, img);
                    var ctx = this.ctx;
                    ctx.save();
                    var currentTransform = ctx.mozCurrentTransform;
                    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                    var mask = this._createMaskCanvas(img);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    for (var i = 0, ii = positions.length; i < ii; i += 2) {
                      var trans = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
                      var _Util$applyTransform3 = _util2.Util.applyTransform([0, 0], trans), _Util$applyTransform4 = _slicedToArray2(_Util$applyTransform3, 2), x = _Util$applyTransform4[0], y = _Util$applyTransform4[1];
                      ctx.drawImage(mask.canvas, x, y);
                    }
                    ctx.restore();
                    this.compose();
                  }
                }, {
                  key: "paintImageMaskXObjectGroup",
                  value: function paintImageMaskXObjectGroup(images) {
                    if (!this.contentVisible) {
                      return;
                    }
                    var ctx = this.ctx;
                    var fillColor = this.current.fillColor;
                    var isPatternFill = this.current.patternFill;
                    for (var i = 0, ii = images.length; i < ii; i++) {
                      var image = images[i];
                      var width = image.width, height = image.height;
                      var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
                      var maskCtx = maskCanvas.context;
                      maskCtx.save();
                      putBinaryImageMask(maskCtx, image);
                      maskCtx.globalCompositeOperation = "source-in";
                      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;
                      maskCtx.fillRect(0, 0, width, height);
                      maskCtx.restore();
                      ctx.save();
                      ctx.transform.apply(ctx, image.transform);
                      ctx.scale(1, -1);
                      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                      ctx.restore();
                    }
                    this.compose();
                  }
                }, {
                  key: "paintImageXObject",
                  value: function paintImageXObject(objId) {
                    if (!this.contentVisible) {
                      return;
                    }
                    var imgData = this.getObject(objId);
                    if (!imgData) {
                      (0, _util2.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }
                }, {
                  key: "paintImageXObjectRepeat",
                  value: function paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                    if (!this.contentVisible) {
                      return;
                    }
                    var imgData = this.getObject(objId);
                    if (!imgData) {
                      (0, _util2.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    var width = imgData.width;
                    var height = imgData.height;
                    var map = [];
                    for (var i = 0, ii = positions.length; i < ii; i += 2) {
                      map.push({
                        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                        x: 0,
                        y: 0,
                        w: width,
                        h: height
                      });
                    }
                    this.paintInlineImageXObjectGroup(imgData, map);
                  }
                }, {
                  key: "paintInlineImageXObject",
                  value: function paintInlineImageXObject(imgData) {
                    if (!this.contentVisible) {
                      return;
                    }
                    var width = imgData.width;
                    var height = imgData.height;
                    var ctx = this.ctx;
                    this.save();
                    ctx.scale(1 / width, -1 / height);
                    var imgToPaint;
                    if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                      imgToPaint = imgData;
                    } else {
                      var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height, false);
                      var tmpCtx = tmpCanvas.context;
                      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                      imgToPaint = tmpCanvas.canvas;
                    }
                    var scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);
                    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);
                    var _drawImageAtIntegerCo = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height), _drawImageAtIntegerCo2 = _slicedToArray2(_drawImageAtIntegerCo, 2), rWidth = _drawImageAtIntegerCo2[0], rHeight = _drawImageAtIntegerCo2[1];
                    if (this.imageLayer) {
                      var position = this.getCanvasPosition(0, -height);
                      this.imageLayer.appendImage({
                        imgData,
                        left: position[0],
                        top: position[1],
                        width: rWidth,
                        height: rHeight
                      });
                    }
                    this.compose();
                    this.restore();
                  }
                }, {
                  key: "paintInlineImageXObjectGroup",
                  value: function paintInlineImageXObjectGroup(imgData, map) {
                    if (!this.contentVisible) {
                      return;
                    }
                    var ctx = this.ctx;
                    var w = imgData.width;
                    var h = imgData.height;
                    var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h, false);
                    var tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    for (var i = 0, ii = map.length; i < ii; i++) {
                      var entry = map[i];
                      ctx.save();
                      ctx.transform.apply(ctx, entry.transform);
                      ctx.scale(1, -1);
                      drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                      if (this.imageLayer) {
                        var position = this.getCanvasPosition(entry.x, entry.y);
                        this.imageLayer.appendImage({
                          imgData,
                          left: position[0],
                          top: position[1],
                          width: w,
                          height: h
                        });
                      }
                      ctx.restore();
                    }
                    this.compose();
                  }
                }, {
                  key: "paintSolidColorImageMask",
                  value: function paintSolidColorImageMask() {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.ctx.fillRect(0, 0, 1, 1);
                    this.compose();
                  }
                }, {
                  key: "markPoint",
                  value: function markPoint(tag) {
                  }
                }, {
                  key: "markPointProps",
                  value: function markPointProps(tag, properties) {
                  }
                }, {
                  key: "beginMarkedContent",
                  value: function beginMarkedContent(tag) {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                }, {
                  key: "beginMarkedContentProps",
                  value: function beginMarkedContentProps(tag, properties) {
                    if (tag === "OC") {
                      this.markedContentStack.push({
                        visible: this.optionalContentConfig.isVisible(properties)
                      });
                    } else {
                      this.markedContentStack.push({
                        visible: true
                      });
                    }
                    this.contentVisible = this.isContentVisible();
                  }
                }, {
                  key: "endMarkedContent",
                  value: function endMarkedContent() {
                    this.markedContentStack.pop();
                    this.contentVisible = this.isContentVisible();
                  }
                }, {
                  key: "beginCompat",
                  value: function beginCompat() {
                  }
                }, {
                  key: "endCompat",
                  value: function endCompat() {
                  }
                }, {
                  key: "consumePath",
                  value: function consumePath(clipBox) {
                    var isEmpty = this.current.isEmptyClip();
                    if (this.pendingClip) {
                      this.current.updateClipFromPath();
                    }
                    if (!this.pendingClip) {
                      this.compose(clipBox);
                    }
                    var ctx = this.ctx;
                    if (this.pendingClip) {
                      if (!isEmpty) {
                        if (this.pendingClip === EO_CLIP) {
                          ctx.clip("evenodd");
                        } else {
                          ctx.clip();
                        }
                      }
                      this.pendingClip = null;
                    }
                    this.current.startNewPathAndClipBox(this.current.clipBox);
                    ctx.beginPath();
                  }
                }, {
                  key: "getSinglePixelWidth",
                  value: function getSinglePixelWidth() {
                    if (!this._cachedGetSinglePixelWidth) {
                      var m = this.ctx.mozCurrentTransform;
                      if (m[1] === 0 && m[2] === 0) {
                        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                      } else {
                        var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                        var normX = Math.hypot(m[0], m[2]);
                        var normY = Math.hypot(m[1], m[3]);
                        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                      }
                    }
                    return this._cachedGetSinglePixelWidth;
                  }
                }, {
                  key: "getScaleForStroking",
                  value: function getScaleForStroking() {
                    if (!this._cachedScaleForStroking) {
                      var lineWidth = this.current.lineWidth;
                      var m = this.ctx.mozCurrentTransform;
                      var scaleX, scaleY;
                      if (m[1] === 0 && m[2] === 0) {
                        var normX = Math.abs(m[0]);
                        var normY = Math.abs(m[3]);
                        if (lineWidth === 0) {
                          scaleX = 1 / normX;
                          scaleY = 1 / normY;
                        } else {
                          var scaledXLineWidth = normX * lineWidth;
                          var scaledYLineWidth = normY * lineWidth;
                          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                        }
                      } else {
                        var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                        var _normX = Math.hypot(m[0], m[1]);
                        var _normY = Math.hypot(m[2], m[3]);
                        if (lineWidth === 0) {
                          scaleX = _normY / absDet;
                          scaleY = _normX / absDet;
                        } else {
                          var baseArea = lineWidth * absDet;
                          scaleX = _normY > baseArea ? _normY / baseArea : 1;
                          scaleY = _normX > baseArea ? _normX / baseArea : 1;
                        }
                      }
                      this._cachedScaleForStroking = [scaleX, scaleY];
                    }
                    return this._cachedScaleForStroking;
                  }
                }, {
                  key: "rescaleAndStroke",
                  value: function rescaleAndStroke(saveRestore) {
                    var ctx = this.ctx;
                    var lineWidth = this.current.lineWidth;
                    var _this$getScaleForStro = this.getScaleForStroking(), _this$getScaleForStro2 = _slicedToArray2(_this$getScaleForStro, 2), scaleX = _this$getScaleForStro2[0], scaleY = _this$getScaleForStro2[1];
                    ctx.lineWidth = lineWidth || 1;
                    if (scaleX === 1 && scaleY === 1) {
                      ctx.stroke();
                      return;
                    }
                    var savedMatrix, savedDashes, savedDashOffset;
                    if (saveRestore) {
                      savedMatrix = ctx.mozCurrentTransform.slice();
                      savedDashes = ctx.getLineDash().slice();
                      savedDashOffset = ctx.lineDashOffset;
                    }
                    ctx.scale(scaleX, scaleY);
                    var scale = Math.max(scaleX, scaleY);
                    ctx.setLineDash(ctx.getLineDash().map(function(x) {
                      return x / scale;
                    }));
                    ctx.lineDashOffset /= scale;
                    ctx.stroke();
                    if (saveRestore) {
                      ctx.setTransform.apply(ctx, _toConsumableArray2(savedMatrix));
                      ctx.setLineDash(savedDashes);
                      ctx.lineDashOffset = savedDashOffset;
                    }
                  }
                }, {
                  key: "getCanvasPosition",
                  value: function getCanvasPosition(x, y) {
                    var transform = this.ctx.mozCurrentTransform;
                    return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                  }
                }, {
                  key: "isContentVisible",
                  value: function isContentVisible() {
                    for (var i = this.markedContentStack.length - 1; i >= 0; i--) {
                      if (!this.markedContentStack[i].visible) {
                        return false;
                      }
                    }
                    return true;
                  }
                }]);
                return CanvasGraphics2;
              }();
              exports2.CanvasGraphics = CanvasGraphics;
              for (var op in _util2.OPS) {
                if (CanvasGraphics.prototype[op] !== void 0) {
                  CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                }
              }
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TilingPattern = exports2.PathType = void 0;
              exports2.getShadingPattern = getShadingPattern;
              var _util2 = __w_pdfjs_require__2(1);
              var _is_node2 = __w_pdfjs_require__2(3);
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var PathType = {
                FILL: "Fill",
                STROKE: "Stroke",
                SHADING: "Shading"
              };
              exports2.PathType = PathType;
              function applyBoundingBox(ctx, bbox) {
                if (!bbox || _is_node2.isNodeJS) {
                  return;
                }
                var width = bbox[2] - bbox[0];
                var height = bbox[3] - bbox[1];
                var region = new Path2D();
                region.rect(bbox[0], bbox[1], width, height);
                ctx.clip(region);
              }
              var BaseShadingPattern = /* @__PURE__ */ function() {
                function BaseShadingPattern2() {
                  _classCallCheck2(this, BaseShadingPattern2);
                  if (this.constructor === BaseShadingPattern2) {
                    (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                  }
                }
                _createClass2(BaseShadingPattern2, [{
                  key: "getPattern",
                  value: function getPattern() {
                    (0, _util2.unreachable)("Abstract method `getPattern` called.");
                  }
                }]);
                return BaseShadingPattern2;
              }();
              var RadialAxialShadingPattern = /* @__PURE__ */ function(_BaseShadingPattern) {
                _inherits(RadialAxialShadingPattern2, _BaseShadingPattern);
                var _super = _createSuper(RadialAxialShadingPattern2);
                function RadialAxialShadingPattern2(IR) {
                  var _this;
                  _classCallCheck2(this, RadialAxialShadingPattern2);
                  _this = _super.call(this);
                  _this._type = IR[1];
                  _this._bbox = IR[2];
                  _this._colorStops = IR[3];
                  _this._p0 = IR[4];
                  _this._p1 = IR[5];
                  _this._r0 = IR[6];
                  _this._r1 = IR[7];
                  _this.matrix = null;
                  return _this;
                }
                _createClass2(RadialAxialShadingPattern2, [{
                  key: "_createGradient",
                  value: function _createGradient(ctx) {
                    var grad;
                    if (this._type === "axial") {
                      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                    } else if (this._type === "radial") {
                      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                    }
                    var _iterator = _createForOfIteratorHelper2(this._colorStops), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var colorStop = _step.value;
                        grad.addColorStop(colorStop[0], colorStop[1]);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    return grad;
                  }
                }, {
                  key: "getPattern",
                  value: function getPattern(ctx, owner, inverse, pathType) {
                    var pattern;
                    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                      var ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];
                      var width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                      var height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                      var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                      var tmpCtx = tmpCanvas.context;
                      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                      tmpCtx.beginPath();
                      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                      inverse = _util2.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                      tmpCtx.transform.apply(tmpCtx, owner.baseTransform);
                      if (this.matrix) {
                        tmpCtx.transform.apply(tmpCtx, this.matrix);
                      }
                      applyBoundingBox(tmpCtx, this._bbox);
                      tmpCtx.fillStyle = this._createGradient(tmpCtx);
                      tmpCtx.fill();
                      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                      var domMatrix = new DOMMatrix(inverse);
                      try {
                        pattern.setTransform(domMatrix);
                      } catch (ex) {
                        (0, _util2.warn)('RadialAxialShadingPattern.getPattern: "'.concat(ex === null || ex === void 0 ? void 0 : ex.message, '".'));
                      }
                    } else {
                      applyBoundingBox(ctx, this._bbox);
                      pattern = this._createGradient(ctx);
                    }
                    return pattern;
                  }
                }]);
                return RadialAxialShadingPattern2;
              }(BaseShadingPattern);
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                var coords = context.coords, colors = context.colors;
                var bytes = data.data, rowSize = data.width * 4;
                var tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                var x1 = (coords[p1] + context.offsetX) * context.scaleX;
                var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                var x2 = (coords[p2] + context.offsetX) * context.scaleX;
                var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                var x3 = (coords[p3] + context.offsetX) * context.scaleX;
                var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                var minY = Math.round(y1), maxY = Math.round(y3);
                var xa, car, cag, cab;
                var xb, cbr, cbg, cbb;
                for (var y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    var _k = void 0;
                    if (y < y1) {
                      _k = 0;
                    } else {
                      _k = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * _k;
                    car = c1r - (c1r - c2r) * _k;
                    cag = c1g - (c1g - c2g) * _k;
                    cab = c1b - (c1b - c2b) * _k;
                  } else {
                    var _k2 = void 0;
                    if (y > y3) {
                      _k2 = 1;
                    } else if (y2 === y3) {
                      _k2 = 0;
                    } else {
                      _k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * _k2;
                    car = c2r - (c2r - c3r) * _k2;
                    cag = c2g - (c2g - c3g) * _k2;
                    cab = c2b - (c2b - c3b) * _k2;
                  }
                  var k = void 0;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  var x1_ = Math.round(Math.min(xa, xb));
                  var x2_ = Math.round(Math.max(xa, xb));
                  var j = rowSize * y + x1_ * 4;
                  for (var x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                var ps = figure.coords;
                var cs = figure.colors;
                var i, ii;
                switch (figure.type) {
                  case "lattice":
                    var verticesPerRow = figure.verticesPerRow;
                    var rows = Math.floor(ps.length / verticesPerRow) - 1;
                    var cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      var q = i * verticesPerRow;
                      for (var j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              var MeshShadingPattern = /* @__PURE__ */ function(_BaseShadingPattern2) {
                _inherits(MeshShadingPattern2, _BaseShadingPattern2);
                var _super2 = _createSuper(MeshShadingPattern2);
                function MeshShadingPattern2(IR) {
                  var _this2;
                  _classCallCheck2(this, MeshShadingPattern2);
                  _this2 = _super2.call(this);
                  _this2._coords = IR[2];
                  _this2._colors = IR[3];
                  _this2._figures = IR[4];
                  _this2._bounds = IR[5];
                  _this2._bbox = IR[7];
                  _this2._background = IR[8];
                  _this2.matrix = null;
                  return _this2;
                }
                _createClass2(MeshShadingPattern2, [{
                  key: "_createMeshCanvas",
                  value: function _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                    var EXPECTED_SCALE = 1.1;
                    var MAX_PATTERN_SIZE = 3e3;
                    var BORDER_SIZE = 2;
                    var offsetX = Math.floor(this._bounds[0]);
                    var offsetY = Math.floor(this._bounds[1]);
                    var boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                    var boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    var scaleX = boundsWidth / width;
                    var scaleY = boundsHeight / height;
                    var context = {
                      coords: this._coords,
                      colors: this._colors,
                      offsetX: -offsetX,
                      offsetY: -offsetY,
                      scaleX: 1 / scaleX,
                      scaleY: 1 / scaleY
                    };
                    var paddedWidth = width + BORDER_SIZE * 2;
                    var paddedHeight = height + BORDER_SIZE * 2;
                    var tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                    var tmpCtx = tmpCanvas.context;
                    var data = tmpCtx.createImageData(width, height);
                    if (backgroundColor) {
                      var bytes = data.data;
                      for (var i = 0, ii = bytes.length; i < ii; i += 4) {
                        bytes[i] = backgroundColor[0];
                        bytes[i + 1] = backgroundColor[1];
                        bytes[i + 2] = backgroundColor[2];
                        bytes[i + 3] = 255;
                      }
                    }
                    var _iterator2 = _createForOfIteratorHelper2(this._figures), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var figure = _step2.value;
                        drawFigure(data, figure, context);
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                    var canvas = tmpCanvas.canvas;
                    return {
                      canvas,
                      offsetX: offsetX - BORDER_SIZE * scaleX,
                      offsetY: offsetY - BORDER_SIZE * scaleY,
                      scaleX,
                      scaleY
                    };
                  }
                }, {
                  key: "getPattern",
                  value: function getPattern(ctx, owner, inverse, pathType) {
                    applyBoundingBox(ctx, this._bbox);
                    var scale;
                    if (pathType === PathType.SHADING) {
                      scale = _util2.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (this.matrix) {
                        var matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    var temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                    if (pathType !== PathType.SHADING) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (this.matrix) {
                        ctx.transform.apply(ctx, this.matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  }
                }]);
                return MeshShadingPattern2;
              }(BaseShadingPattern);
              var DummyShadingPattern = /* @__PURE__ */ function(_BaseShadingPattern3) {
                _inherits(DummyShadingPattern2, _BaseShadingPattern3);
                var _super3 = _createSuper(DummyShadingPattern2);
                function DummyShadingPattern2() {
                  _classCallCheck2(this, DummyShadingPattern2);
                  return _super3.apply(this, arguments);
                }
                _createClass2(DummyShadingPattern2, [{
                  key: "getPattern",
                  value: function getPattern() {
                    return "hotpink";
                  }
                }]);
                return DummyShadingPattern2;
              }(BaseShadingPattern);
              function getShadingPattern(IR) {
                switch (IR[0]) {
                  case "RadialAxial":
                    return new RadialAxialShadingPattern(IR);
                  case "Mesh":
                    return new MeshShadingPattern(IR);
                  case "Dummy":
                    return new DummyShadingPattern();
                }
                throw new Error("Unknown IR type: ".concat(IR[0]));
              }
              var PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              var TilingPattern = /* @__PURE__ */ function() {
                function TilingPattern2(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                  _classCallCheck2(this, TilingPattern2);
                  this.operatorList = IR[2];
                  this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                  this.bbox = IR[4];
                  this.xstep = IR[5];
                  this.ystep = IR[6];
                  this.paintType = IR[7];
                  this.tilingType = IR[8];
                  this.color = color;
                  this.ctx = ctx;
                  this.canvasGraphicsFactory = canvasGraphicsFactory;
                  this.baseTransform = baseTransform;
                }
                _createClass2(TilingPattern2, [{
                  key: "createPatternCanvas",
                  value: function createPatternCanvas(owner) {
                    var operatorList = this.operatorList;
                    var bbox = this.bbox;
                    var xstep = this.xstep;
                    var ystep = this.ystep;
                    var paintType = this.paintType;
                    var tilingType = this.tilingType;
                    var color = this.color;
                    var canvasGraphicsFactory = this.canvasGraphicsFactory;
                    (0, _util2.info)("TilingType: " + tilingType);
                    var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                    var matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                    var curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                    var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                    var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                    var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                    var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                    var tmpCtx = tmpCanvas.context;
                    var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                    graphics.groupLevel = owner.groupLevel;
                    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                    var adjustedX0 = x0;
                    var adjustedY0 = y0;
                    var adjustedX1 = x1;
                    var adjustedY1 = y1;
                    if (x0 < 0) {
                      adjustedX0 = 0;
                      adjustedX1 += Math.abs(x0);
                    }
                    if (y0 < 0) {
                      adjustedY0 = 0;
                      adjustedY1 += Math.abs(y0);
                    }
                    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                    tmpCtx.save();
                    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                    graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
                    graphics.executeOperatorList(operatorList);
                    graphics.endDrawing();
                    return {
                      canvas: tmpCanvas.canvas,
                      scaleX: dimx.scale,
                      scaleY: dimy.scale,
                      offsetX: adjustedX0,
                      offsetY: adjustedY0
                    };
                  }
                }, {
                  key: "getSizeAndScale",
                  value: function getSizeAndScale(step, realOutputSize, scale) {
                    step = Math.abs(step);
                    var maxSize = Math.max(TilingPattern2.MAX_PATTERN_SIZE, realOutputSize);
                    var size = Math.ceil(step * scale);
                    if (size >= maxSize) {
                      size = maxSize;
                    } else {
                      scale = size / step;
                    }
                    return {
                      scale,
                      size
                    };
                  }
                }, {
                  key: "clipBbox",
                  value: function clipBbox(graphics, x0, y0, x1, y1) {
                    var bboxWidth = x1 - x0;
                    var bboxHeight = y1 - y0;
                    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                    graphics.current.updateRectMinMax(graphics.ctx.mozCurrentTransform, [x0, y0, x1, y1]);
                    graphics.clip();
                    graphics.endPath();
                  }
                }, {
                  key: "setFillAndStrokeStyleToContext",
                  value: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                    var context = graphics.ctx, current = graphics.current;
                    switch (paintType) {
                      case PaintType.COLORED:
                        var ctx = this.ctx;
                        context.fillStyle = ctx.fillStyle;
                        context.strokeStyle = ctx.strokeStyle;
                        current.fillColor = ctx.fillStyle;
                        current.strokeColor = ctx.strokeStyle;
                        break;
                      case PaintType.UNCOLORED:
                        var cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                        context.fillStyle = cssColor;
                        context.strokeStyle = cssColor;
                        current.fillColor = cssColor;
                        current.strokeColor = cssColor;
                        break;
                      default:
                        throw new _util2.FormatError("Unsupported paint type: ".concat(paintType));
                    }
                  }
                }, {
                  key: "getPattern",
                  value: function getPattern(ctx, owner, inverse, pathType) {
                    var matrix = inverse;
                    if (pathType !== PathType.SHADING) {
                      matrix = _util2.Util.transform(matrix, owner.baseTransform);
                      if (this.matrix) {
                        matrix = _util2.Util.transform(matrix, this.matrix);
                      }
                    }
                    var temporaryPatternCanvas = this.createPatternCanvas(owner);
                    var domMatrix = new DOMMatrix(matrix);
                    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                    var pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                    try {
                      pattern.setTransform(domMatrix);
                    } catch (ex) {
                      (0, _util2.warn)('TilingPattern.getPattern: "'.concat(ex === null || ex === void 0 ? void 0 : ex.message, '".'));
                    }
                    return pattern;
                  }
                }], [{
                  key: "MAX_PATTERN_SIZE",
                  get: function get2() {
                    return (0, _util2.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
                  }
                }]);
                return TilingPattern2;
              }();
              exports2.TilingPattern = TilingPattern;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.applyMaskImageData = applyMaskImageData;
              var _util2 = __w_pdfjs_require__2(1);
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function applyMaskImageData(_ref) {
                var src = _ref.src, _ref$srcPos = _ref.srcPos, srcPos = _ref$srcPos === void 0 ? 0 : _ref$srcPos, dest = _ref.dest, _ref$destPos = _ref.destPos, destPos = _ref$destPos === void 0 ? 0 : _ref$destPos, width = _ref.width, height = _ref.height, _ref$inverseDecode = _ref.inverseDecode, inverseDecode = _ref$inverseDecode === void 0 ? false : _ref$inverseDecode;
                var opaque = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                var _ref2 = !inverseDecode ? [opaque, 0] : [0, opaque], _ref3 = _slicedToArray2(_ref2, 2), zeroMapping = _ref3[0], oneMapping = _ref3[1];
                var widthInSource = width >> 3;
                var widthRemainder = width & 7;
                var srcLength = src.length;
                dest = new Uint32Array(dest.buffer);
                for (var i = 0; i < height; i++) {
                  for (var max = srcPos + widthInSource; srcPos < max; srcPos++) {
                    var _elem = srcPos < srcLength ? src[srcPos] : 255;
                    dest[destPos++] = _elem & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = _elem & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = _elem & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = _elem & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = _elem & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = _elem & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = _elem & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = _elem & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  var elem = srcPos < srcLength ? src[srcPos++] : 255;
                  for (var j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
            },
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlobalWorkerOptions = void 0;
              var GlobalWorkerOptions2 = /* @__PURE__ */ Object.create(null);
              exports2.GlobalWorkerOptions = GlobalWorkerOptions2;
              GlobalWorkerOptions2.workerPort = GlobalWorkerOptions2.workerPort === void 0 ? null : GlobalWorkerOptions2.workerPort;
              GlobalWorkerOptions2.workerSrc = GlobalWorkerOptions2.workerSrc === void 0 ? "" : GlobalWorkerOptions2.workerSrc;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _util2 = __w_pdfjs_require__2(1);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              var CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              var StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || _typeof2(reason) === "object" && reason !== null)) {
                  (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util2.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util2.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util2.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util2.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util2.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util2.UnknownErrorException(reason.message, reason.toString());
                }
              }
              var MessageHandler = /* @__PURE__ */ function() {
                function MessageHandler2(sourceName, targetName, comObj) {
                  var _this = this;
                  _classCallCheck2(this, MessageHandler2);
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = function(event) {
                    var data = event.data;
                    if (data.targetName !== _this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      _this._processStreamMessage(data);
                      return;
                    }
                    if (data.callback) {
                      var callbackId = data.callbackId;
                      var capability = _this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error("Cannot resolve callback ".concat(callbackId));
                      }
                      delete _this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    var action = _this.actionHandler[data.action];
                    if (!action) {
                      throw new Error("Unknown action from worker: ".concat(data.action));
                    }
                    if (data.callbackId) {
                      var cbSourceName = _this.sourceName;
                      var cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      _this._createStreamSink(data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                _createClass2(MessageHandler2, [{
                  key: "on",
                  value: function on(actionName, handler) {
                    var ah = this.actionHandler;
                    if (ah[actionName]) {
                      throw new Error('There is already an actionName called "'.concat(actionName, '"'));
                    }
                    ah[actionName] = handler;
                  }
                }, {
                  key: "send",
                  value: function send(actionName, data, transfers) {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      data
                    }, transfers);
                  }
                }, {
                  key: "sendWithPromise",
                  value: function sendWithPromise(actionName, data, transfers) {
                    var callbackId = this.callbackId++;
                    var capability = (0, _util2.createPromiseCapability)();
                    this.callbackCapabilities[callbackId] = capability;
                    try {
                      this.comObj.postMessage({
                        sourceName: this.sourceName,
                        targetName: this.targetName,
                        action: actionName,
                        callbackId,
                        data
                      }, transfers);
                    } catch (ex) {
                      capability.reject(ex);
                    }
                    return capability.promise;
                  }
                }, {
                  key: "sendWithStream",
                  value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                    var _this2 = this;
                    var streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                    return new ReadableStream({
                      start: function start(controller) {
                        var startCapability = (0, _util2.createPromiseCapability)();
                        _this2.streamControllers[streamId] = {
                          controller,
                          startCall: startCapability,
                          pullCall: null,
                          cancelCall: null,
                          isClosed: false
                        };
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          action: actionName,
                          streamId,
                          data,
                          desiredSize: controller.desiredSize
                        }, transfers);
                        return startCapability.promise;
                      },
                      pull: function pull(controller) {
                        var pullCapability = (0, _util2.createPromiseCapability)();
                        _this2.streamControllers[streamId].pullCall = pullCapability;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL,
                          streamId,
                          desiredSize: controller.desiredSize
                        });
                        return pullCapability.promise;
                      },
                      cancel: function cancel(reason) {
                        (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                        var cancelCapability = (0, _util2.createPromiseCapability)();
                        _this2.streamControllers[streamId].cancelCall = cancelCapability;
                        _this2.streamControllers[streamId].isClosed = true;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL,
                          streamId,
                          reason: wrapReason(reason)
                        });
                        return cancelCapability.promise;
                      }
                    }, queueingStrategy);
                  }
                }, {
                  key: "_createStreamSink",
                  value: function _createStreamSink(data) {
                    var streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                    var self2 = this, action = this.actionHandler[data.action];
                    var streamSink = {
                      enqueue: function enqueue(chunk) {
                        var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                        var transfers = arguments.length > 2 ? arguments[2] : void 0;
                        if (this.isCancelled) {
                          return;
                        }
                        var lastDesiredSize = this.desiredSize;
                        this.desiredSize -= size;
                        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                          this.sinkCapability = (0, _util2.createPromiseCapability)();
                          this.ready = this.sinkCapability.promise;
                        }
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.ENQUEUE,
                          streamId,
                          chunk
                        }, transfers);
                      },
                      close: function close() {
                        if (this.isCancelled) {
                          return;
                        }
                        this.isCancelled = true;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CLOSE,
                          streamId
                        });
                        delete self2.streamSinks[streamId];
                      },
                      error: function error(reason) {
                        (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                        if (this.isCancelled) {
                          return;
                        }
                        this.isCancelled = true;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.ERROR,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      },
                      sinkCapability: (0, _util2.createPromiseCapability)(),
                      onPull: null,
                      onCancel: null,
                      isCancelled: false,
                      desiredSize: data.desiredSize,
                      ready: null
                    };
                    streamSink.sinkCapability.resolve();
                    streamSink.ready = streamSink.sinkCapability.promise;
                    this.streamSinks[streamId] = streamSink;
                    new Promise(function(resolve) {
                      resolve(action(data.data, streamSink));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.START_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.START_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                  }
                }, {
                  key: "_processStreamMessage",
                  value: function _processStreamMessage(data) {
                    var streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                    var streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                    switch (data.stream) {
                      case StreamKind.START_COMPLETE:
                        if (data.success) {
                          streamController.startCall.resolve();
                        } else {
                          streamController.startCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL_COMPLETE:
                        if (data.success) {
                          streamController.pullCall.resolve();
                        } else {
                          streamController.pullCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL:
                        if (!streamSink) {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.PULL_COMPLETE,
                            streamId,
                            success: true
                          });
                          break;
                        }
                        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                          streamSink.sinkCapability.resolve();
                        }
                        streamSink.desiredSize = data.desiredSize;
                        new Promise(function(resolve) {
                          resolve(streamSink.onPull && streamSink.onPull());
                        }).then(function() {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.PULL_COMPLETE,
                            streamId,
                            success: true
                          });
                        }, function(reason) {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.PULL_COMPLETE,
                            streamId,
                            reason: wrapReason(reason)
                          });
                        });
                        break;
                      case StreamKind.ENQUEUE:
                        (0, _util2.assert)(streamController, "enqueue should have stream controller");
                        if (streamController.isClosed) {
                          break;
                        }
                        streamController.controller.enqueue(data.chunk);
                        break;
                      case StreamKind.CLOSE:
                        (0, _util2.assert)(streamController, "close should have stream controller");
                        if (streamController.isClosed) {
                          break;
                        }
                        streamController.isClosed = true;
                        streamController.controller.close();
                        this._deleteStreamController(streamController, streamId);
                        break;
                      case StreamKind.ERROR:
                        (0, _util2.assert)(streamController, "error should have stream controller");
                        streamController.controller.error(wrapReason(data.reason));
                        this._deleteStreamController(streamController, streamId);
                        break;
                      case StreamKind.CANCEL_COMPLETE:
                        if (data.success) {
                          streamController.cancelCall.resolve();
                        } else {
                          streamController.cancelCall.reject(wrapReason(data.reason));
                        }
                        this._deleteStreamController(streamController, streamId);
                        break;
                      case StreamKind.CANCEL:
                        if (!streamSink) {
                          break;
                        }
                        new Promise(function(resolve) {
                          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                        }).then(function() {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.CANCEL_COMPLETE,
                            streamId,
                            success: true
                          });
                        }, function(reason) {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.CANCEL_COMPLETE,
                            streamId,
                            reason: wrapReason(reason)
                          });
                        });
                        streamSink.sinkCapability.reject(wrapReason(data.reason));
                        streamSink.isCancelled = true;
                        delete this.streamSinks[streamId];
                        break;
                      default:
                        throw new Error("Unexpected stream case");
                    }
                  }
                }, {
                  key: "_deleteStreamController",
                  value: function() {
                    var _deleteStreamController2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee(streamController, streamId) {
                      return _regenerator2["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _context.next = 2;
                              return Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
                            case 2:
                              delete this.streamControllers[streamId];
                            case 3:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this);
                    }));
                    function _deleteStreamController(_x, _x2) {
                      return _deleteStreamController2.apply(this, arguments);
                    }
                    return _deleteStreamController;
                  }()
                }, {
                  key: "destroy",
                  value: function destroy() {
                    this.comObj.removeEventListener("message", this._onComObjOnMessage);
                  }
                }]);
                return MessageHandler2;
              }();
              exports2.MessageHandler = MessageHandler;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Metadata = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              var _metadataMap = /* @__PURE__ */ new WeakMap();
              var _data = /* @__PURE__ */ new WeakMap();
              var Metadata = /* @__PURE__ */ function() {
                function Metadata2(_ref) {
                  var parsedData = _ref.parsedData, rawData = _ref.rawData;
                  _classCallCheck2(this, Metadata2);
                  _classPrivateFieldInitSpec2(this, _metadataMap, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldInitSpec2(this, _data, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldSet2(this, _metadataMap, parsedData);
                  _classPrivateFieldSet2(this, _data, rawData);
                }
                _createClass2(Metadata2, [{
                  key: "getRaw",
                  value: function getRaw() {
                    return _classPrivateFieldGet2(this, _data);
                  }
                }, {
                  key: "get",
                  value: function get2(name) {
                    var _classPrivateFieldGet22;
                    return (_classPrivateFieldGet22 = _classPrivateFieldGet2(this, _metadataMap).get(name)) !== null && _classPrivateFieldGet22 !== void 0 ? _classPrivateFieldGet22 : null;
                  }
                }, {
                  key: "getAll",
                  value: function getAll() {
                    return (0, _util2.objectFromMap)(_classPrivateFieldGet2(this, _metadataMap));
                  }
                }, {
                  key: "has",
                  value: function has(name) {
                    return _classPrivateFieldGet2(this, _metadataMap).has(name);
                  }
                }]);
                return Metadata2;
              }();
              exports2.Metadata = Metadata;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OptionalContentConfig = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var OptionalContentGroup = /* @__PURE__ */ _createClass2(function OptionalContentGroup2(name, intent) {
                _classCallCheck2(this, OptionalContentGroup2);
                this.visible = true;
                this.name = name;
                this.intent = intent;
              });
              var OptionalContentConfig = /* @__PURE__ */ function() {
                function OptionalContentConfig2(data) {
                  _classCallCheck2(this, OptionalContentConfig2);
                  this.name = null;
                  this.creator = null;
                  this._order = null;
                  this._groups = /* @__PURE__ */ new Map();
                  if (data === null) {
                    return;
                  }
                  this.name = data.name;
                  this.creator = data.creator;
                  this._order = data.order;
                  var _iterator = _createForOfIteratorHelper2(data.groups), _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var _group = _step.value;
                      this._groups.set(_group.id, new OptionalContentGroup(_group.name, _group.intent));
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  if (data.baseState === "OFF") {
                    var _iterator2 = _createForOfIteratorHelper2(this._groups), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var group = _step2.value;
                        group.visible = false;
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                  }
                  var _iterator3 = _createForOfIteratorHelper2(data.on), _step3;
                  try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                      var on = _step3.value;
                      this._groups.get(on).visible = true;
                    }
                  } catch (err) {
                    _iterator3.e(err);
                  } finally {
                    _iterator3.f();
                  }
                  var _iterator4 = _createForOfIteratorHelper2(data.off), _step4;
                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                      var off = _step4.value;
                      this._groups.get(off).visible = false;
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                }
                _createClass2(OptionalContentConfig2, [{
                  key: "_evaluateVisibilityExpression",
                  value: function _evaluateVisibilityExpression(array) {
                    var length = array.length;
                    if (length < 2) {
                      return true;
                    }
                    var operator = array[0];
                    for (var i = 1; i < length; i++) {
                      var element = array[i];
                      var state = void 0;
                      if (Array.isArray(element)) {
                        state = this._evaluateVisibilityExpression(element);
                      } else if (this._groups.has(element)) {
                        state = this._groups.get(element).visible;
                      } else {
                        (0, _util2.warn)("Optional content group not found: ".concat(element));
                        return true;
                      }
                      switch (operator) {
                        case "And":
                          if (!state) {
                            return false;
                          }
                          break;
                        case "Or":
                          if (state) {
                            return true;
                          }
                          break;
                        case "Not":
                          return !state;
                        default:
                          return true;
                      }
                    }
                    return operator === "And";
                  }
                }, {
                  key: "isVisible",
                  value: function isVisible(group) {
                    if (this._groups.size === 0) {
                      return true;
                    }
                    if (!group) {
                      (0, _util2.warn)("Optional content group not defined.");
                      return true;
                    }
                    if (group.type === "OCG") {
                      if (!this._groups.has(group.id)) {
                        (0, _util2.warn)("Optional content group not found: ".concat(group.id));
                        return true;
                      }
                      return this._groups.get(group.id).visible;
                    } else if (group.type === "OCMD") {
                      if (group.expression) {
                        return this._evaluateVisibilityExpression(group.expression);
                      }
                      if (!group.policy || group.policy === "AnyOn") {
                        var _iterator5 = _createForOfIteratorHelper2(group.ids), _step5;
                        try {
                          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                            var id = _step5.value;
                            if (!this._groups.has(id)) {
                              (0, _util2.warn)("Optional content group not found: ".concat(id));
                              return true;
                            }
                            if (this._groups.get(id).visible) {
                              return true;
                            }
                          }
                        } catch (err) {
                          _iterator5.e(err);
                        } finally {
                          _iterator5.f();
                        }
                        return false;
                      } else if (group.policy === "AllOn") {
                        var _iterator6 = _createForOfIteratorHelper2(group.ids), _step6;
                        try {
                          for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                            var _id = _step6.value;
                            if (!this._groups.has(_id)) {
                              (0, _util2.warn)("Optional content group not found: ".concat(_id));
                              return true;
                            }
                            if (!this._groups.get(_id).visible) {
                              return false;
                            }
                          }
                        } catch (err) {
                          _iterator6.e(err);
                        } finally {
                          _iterator6.f();
                        }
                        return true;
                      } else if (group.policy === "AnyOff") {
                        var _iterator7 = _createForOfIteratorHelper2(group.ids), _step7;
                        try {
                          for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                            var _id2 = _step7.value;
                            if (!this._groups.has(_id2)) {
                              (0, _util2.warn)("Optional content group not found: ".concat(_id2));
                              return true;
                            }
                            if (!this._groups.get(_id2).visible) {
                              return true;
                            }
                          }
                        } catch (err) {
                          _iterator7.e(err);
                        } finally {
                          _iterator7.f();
                        }
                        return false;
                      } else if (group.policy === "AllOff") {
                        var _iterator8 = _createForOfIteratorHelper2(group.ids), _step8;
                        try {
                          for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                            var _id3 = _step8.value;
                            if (!this._groups.has(_id3)) {
                              (0, _util2.warn)("Optional content group not found: ".concat(_id3));
                              return true;
                            }
                            if (this._groups.get(_id3).visible) {
                              return false;
                            }
                          }
                        } catch (err) {
                          _iterator8.e(err);
                        } finally {
                          _iterator8.f();
                        }
                        return true;
                      }
                      (0, _util2.warn)("Unknown optional content policy ".concat(group.policy, "."));
                      return true;
                    }
                    (0, _util2.warn)("Unknown group type ".concat(group.type, "."));
                    return true;
                  }
                }, {
                  key: "setVisibility",
                  value: function setVisibility(id) {
                    var visible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                    if (!this._groups.has(id)) {
                      (0, _util2.warn)("Optional content group not found: ".concat(id));
                      return;
                    }
                    this._groups.get(id).visible = !!visible;
                  }
                }, {
                  key: "getOrder",
                  value: function getOrder() {
                    if (!this._groups.size) {
                      return null;
                    }
                    if (this._order) {
                      return this._order.slice();
                    }
                    return Array.from(this._groups.keys());
                  }
                }, {
                  key: "getGroups",
                  value: function getGroups() {
                    return this._groups.size > 0 ? (0, _util2.objectFromMap)(this._groups) : null;
                  }
                }, {
                  key: "getGroup",
                  value: function getGroup(id) {
                    return this._groups.get(id) || null;
                  }
                }]);
                return OptionalContentConfig2;
              }();
              exports2.OptionalContentConfig = OptionalContentConfig;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFDataTransportStream = void 0;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(158);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var PDFDataTransportStream = /* @__PURE__ */ function() {
                function PDFDataTransportStream2(params, pdfDataRangeTransport) {
                  var _this = this;
                  _classCallCheck2(this, PDFDataTransportStream2);
                  (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                  this._queuedChunks = [];
                  this._progressiveDone = params.progressiveDone || false;
                  this._contentDispositionFilename = params.contentDispositionFilename || null;
                  var initialData = params.initialData;
                  if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
                    var buffer = new Uint8Array(initialData).buffer;
                    this._queuedChunks.push(buffer);
                  }
                  this._pdfDataRangeTransport = pdfDataRangeTransport;
                  this._isStreamingSupported = !params.disableStream;
                  this._isRangeSupported = !params.disableRange;
                  this._contentLength = params.length;
                  this._fullRequestReader = null;
                  this._rangeReaders = [];
                  this._pdfDataRangeTransport.addRangeListener(function(begin, chunk) {
                    _this._onReceiveData({
                      begin,
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressListener(function(loaded, total) {
                    _this._onProgress({
                      loaded,
                      total
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveReadListener(function(chunk) {
                    _this._onReceiveData({
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveDoneListener(function() {
                    _this._onProgressiveDone();
                  });
                  this._pdfDataRangeTransport.transportReady();
                }
                _createClass2(PDFDataTransportStream2, [{
                  key: "_onReceiveData",
                  value: function _onReceiveData(args) {
                    var buffer = new Uint8Array(args.chunk).buffer;
                    if (args.begin === void 0) {
                      if (this._fullRequestReader) {
                        this._fullRequestReader._enqueue(buffer);
                      } else {
                        this._queuedChunks.push(buffer);
                      }
                    } else {
                      var found = this._rangeReaders.some(function(rangeReader) {
                        if (rangeReader._begin !== args.begin) {
                          return false;
                        }
                        rangeReader._enqueue(buffer);
                        return true;
                      });
                      (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                    }
                  }
                }, {
                  key: "_progressiveDataLength",
                  get: function get2() {
                    var _this$_fullRequestRea, _this$_fullRequestRea2;
                    return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                  }
                }, {
                  key: "_onProgress",
                  value: function _onProgress(evt) {
                    if (evt.total === void 0) {
                      var firstReader = this._rangeReaders[0];
                      if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
                        firstReader.onProgress({
                          loaded: evt.loaded
                        });
                      }
                    } else {
                      var fullReader = this._fullRequestReader;
                      if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
                        fullReader.onProgress({
                          loaded: evt.loaded,
                          total: evt.total
                        });
                      }
                    }
                  }
                }, {
                  key: "_onProgressiveDone",
                  value: function _onProgressiveDone() {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.progressiveDone();
                    }
                    this._progressiveDone = true;
                  }
                }, {
                  key: "_removeRangeReader",
                  value: function _removeRangeReader(reader) {
                    var i = this._rangeReaders.indexOf(reader);
                    if (i >= 0) {
                      this._rangeReaders.splice(i, 1);
                    }
                  }
                }, {
                  key: "getFullReader",
                  value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                    var queuedChunks = this._queuedChunks;
                    this._queuedChunks = null;
                    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                  }
                }, {
                  key: "getRangeReader",
                  value: function getRangeReader(begin, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    var reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                    this._pdfDataRangeTransport.requestDataRange(begin, end);
                    this._rangeReaders.push(reader);
                    return reader;
                  }
                }, {
                  key: "cancelAllRequests",
                  value: function cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    var _iterator = _createForOfIteratorHelper2(this._rangeReaders.slice(0)), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var reader = _step.value;
                        reader.cancel(reason);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    this._pdfDataRangeTransport.abort();
                  }
                }]);
                return PDFDataTransportStream2;
              }();
              exports2.PDFDataTransportStream = PDFDataTransportStream;
              var PDFDataTransportStreamReader = /* @__PURE__ */ function() {
                function PDFDataTransportStreamReader2(stream, queuedChunks) {
                  var progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var contentDispositionFilename = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                  _classCallCheck2(this, PDFDataTransportStreamReader2);
                  this._stream = stream;
                  this._done = progressiveDone || false;
                  this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                  this._queuedChunks = queuedChunks || [];
                  this._loaded = 0;
                  var _iterator2 = _createForOfIteratorHelper2(this._queuedChunks), _step2;
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var chunk = _step2.value;
                      this._loaded += chunk.byteLength;
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                  this._requests = [];
                  this._headersReady = Promise.resolve();
                  stream._fullRequestReader = this;
                  this.onProgress = null;
                }
                _createClass2(PDFDataTransportStreamReader2, [{
                  key: "_enqueue",
                  value: function _enqueue(chunk) {
                    if (this._done) {
                      return;
                    }
                    if (this._requests.length > 0) {
                      var requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: chunk,
                        done: false
                      });
                    } else {
                      this._queuedChunks.push(chunk);
                    }
                    this._loaded += chunk.byteLength;
                  }
                }, {
                  key: "headersReady",
                  get: function get2() {
                    return this._headersReady;
                  }
                }, {
                  key: "filename",
                  get: function get2() {
                    return this._filename;
                  }
                }, {
                  key: "isRangeSupported",
                  get: function get2() {
                    return this._stream._isRangeSupported;
                  }
                }, {
                  key: "isStreamingSupported",
                  get: function get2() {
                    return this._stream._isStreamingSupported;
                  }
                }, {
                  key: "contentLength",
                  get: function get2() {
                    return this._stream._contentLength;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              if (!(this._queuedChunks.length > 0)) {
                                _context.next = 3;
                                break;
                              }
                              chunk = this._queuedChunks.shift();
                              return _context.abrupt("return", {
                                value: chunk,
                                done: false
                              });
                            case 3:
                              if (!this._done) {
                                _context.next = 5;
                                break;
                              }
                              return _context.abrupt("return", {
                                value: void 0,
                                done: true
                              });
                            case 5:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context.abrupt("return", requestCapability.promise);
                            case 8:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    this._done = true;
                    var _iterator3 = _createForOfIteratorHelper2(this._requests), _step3;
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                        var requestCapability = _step3.value;
                        requestCapability.resolve({
                          value: void 0,
                          done: true
                        });
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                    this._requests.length = 0;
                  }
                }, {
                  key: "progressiveDone",
                  value: function progressiveDone() {
                    if (this._done) {
                      return;
                    }
                    this._done = true;
                  }
                }]);
                return PDFDataTransportStreamReader2;
              }();
              var PDFDataTransportStreamRangeReader = /* @__PURE__ */ function() {
                function PDFDataTransportStreamRangeReader2(stream, begin, end) {
                  _classCallCheck2(this, PDFDataTransportStreamRangeReader2);
                  this._stream = stream;
                  this._begin = begin;
                  this._end = end;
                  this._queuedChunk = null;
                  this._requests = [];
                  this._done = false;
                  this.onProgress = null;
                }
                _createClass2(PDFDataTransportStreamRangeReader2, [{
                  key: "_enqueue",
                  value: function _enqueue(chunk) {
                    if (this._done) {
                      return;
                    }
                    if (this._requests.length === 0) {
                      this._queuedChunk = chunk;
                    } else {
                      var requestsCapability = this._requests.shift();
                      requestsCapability.resolve({
                        value: chunk,
                        done: false
                      });
                      var _iterator4 = _createForOfIteratorHelper2(this._requests), _step4;
                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                          var requestCapability = _step4.value;
                          requestCapability.resolve({
                            value: void 0,
                            done: true
                          });
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }
                      this._requests.length = 0;
                    }
                    this._done = true;
                    this._stream._removeRangeReader(this);
                  }
                }, {
                  key: "isStreamingSupported",
                  get: function get2() {
                    return false;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!this._queuedChunk) {
                                _context2.next = 4;
                                break;
                              }
                              chunk = this._queuedChunk;
                              this._queuedChunk = null;
                              return _context2.abrupt("return", {
                                value: chunk,
                                done: false
                              });
                            case 4:
                              if (!this._done) {
                                _context2.next = 6;
                                break;
                              }
                              return _context2.abrupt("return", {
                                value: void 0,
                                done: true
                              });
                            case 6:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context2.abrupt("return", requestCapability.promise);
                            case 9:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    this._done = true;
                    var _iterator5 = _createForOfIteratorHelper2(this._requests), _step5;
                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                        var requestCapability = _step5.value;
                        requestCapability.resolve({
                          value: void 0,
                          done: true
                        });
                      }
                    } catch (err) {
                      _iterator5.e(err);
                    } finally {
                      _iterator5.f();
                    }
                    this._requests.length = 0;
                    this._stream._removeRangeReader(this);
                  }
                }]);
                return PDFDataTransportStreamRangeReader2;
              }();
            },
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaText = void 0;
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var XfaText = /* @__PURE__ */ function() {
                function XfaText2() {
                  _classCallCheck2(this, XfaText2);
                }
                _createClass2(XfaText2, null, [{
                  key: "textContent",
                  value: function textContent(xfa) {
                    var items = [];
                    var output = {
                      items,
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    function walk(node) {
                      var _node$attributes;
                      if (!node) {
                        return;
                      }
                      var str = null;
                      var name = node.name;
                      if (name === "#text") {
                        str = node.value;
                      } else if (!XfaText2.shouldBuildText(name)) {
                        return;
                      } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
                        str = node.attributes.textContent;
                      } else if (node.value) {
                        str = node.value;
                      }
                      if (str !== null) {
                        items.push({
                          str
                        });
                      }
                      if (!node.children) {
                        return;
                      }
                      var _iterator = _createForOfIteratorHelper2(node.children), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var child = _step.value;
                          walk(child);
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                    }
                    walk(xfa);
                    return output;
                  }
                }, {
                  key: "shouldBuildText",
                  value: function shouldBuildText(name) {
                    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
                  }
                }]);
                return XfaText2;
              }();
              exports2.XfaText = XfaText;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NodeStandardFontDataFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
              var _base_factory = __w_pdfjs_require__2(159);
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              ;
              var fetchData = function fetchData2(url) {
                return new Promise(function(resolve, reject) {
                  var fs = require_fs();
                  fs.readFile(url, function(error, data) {
                    if (error || !data) {
                      reject(new Error(error));
                      return;
                    }
                    resolve(new Uint8Array(data));
                  });
                });
              };
              var NodeCanvasFactory2 = /* @__PURE__ */ function(_BaseCanvasFactory) {
                _inherits(NodeCanvasFactory3, _BaseCanvasFactory);
                var _super = _createSuper(NodeCanvasFactory3);
                function NodeCanvasFactory3() {
                  _classCallCheck2(this, NodeCanvasFactory3);
                  return _super.apply(this, arguments);
                }
                _createClass2(NodeCanvasFactory3, [{
                  key: "_createCanvas",
                  value: function _createCanvas(width, height) {
                    var Canvas = require_canvas();
                    return Canvas.createCanvas(width, height);
                  }
                }]);
                return NodeCanvasFactory3;
              }(_base_factory.BaseCanvasFactory);
              exports2.NodeCanvasFactory = NodeCanvasFactory2;
              var NodeCMapReaderFactory2 = /* @__PURE__ */ function(_BaseCMapReaderFactor) {
                _inherits(NodeCMapReaderFactory3, _BaseCMapReaderFactor);
                var _super2 = _createSuper(NodeCMapReaderFactory3);
                function NodeCMapReaderFactory3() {
                  _classCallCheck2(this, NodeCMapReaderFactory3);
                  return _super2.apply(this, arguments);
                }
                _createClass2(NodeCMapReaderFactory3, [{
                  key: "_fetchData",
                  value: function _fetchData(url, compressionType) {
                    return fetchData(url).then(function(data) {
                      return {
                        cMapData: data,
                        compressionType
                      };
                    });
                  }
                }]);
                return NodeCMapReaderFactory3;
              }(_base_factory.BaseCMapReaderFactory);
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory2;
              var NodeStandardFontDataFactory2 = /* @__PURE__ */ function(_BaseStandardFontData) {
                _inherits(NodeStandardFontDataFactory3, _BaseStandardFontData);
                var _super3 = _createSuper(NodeStandardFontDataFactory3);
                function NodeStandardFontDataFactory3() {
                  _classCallCheck2(this, NodeStandardFontDataFactory3);
                  return _super3.apply(this, arguments);
                }
                _createClass2(NodeStandardFontDataFactory3, [{
                  key: "_fetchData",
                  value: function _fetchData(url) {
                    return fetchData(url);
                  }
                }]);
                return NodeStandardFontDataFactory3;
              }(_base_factory.BaseStandardFontDataFactory);
              exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory2;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(158);
              var _annotation_storage2 = __w_pdfjs_require__2(161);
              var _scripting_utils = __w_pdfjs_require__2(174);
              var _xfa_layer = __w_pdfjs_require__2(175);
              function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
                _classCheckPrivateStaticAccess2(receiver, classConstructor);
                return method;
              }
              function _classCheckPrivateStaticAccess2(receiver, classConstructor) {
                if (receiver !== classConstructor) {
                  throw new TypeError("Private static access of wrong provenance");
                }
              }
              function _get() {
                if (typeof Reflect !== "undefined" && Reflect.get) {
                  _get = Reflect.get;
                } else {
                  _get = function _get2(target, property, receiver) {
                    var base = _superPropBase(target, property);
                    if (!base)
                      return;
                    var desc = Object.getOwnPropertyDescriptor(base, property);
                    if (desc.get) {
                      return desc.get.call(arguments.length < 3 ? target : receiver);
                    }
                    return desc.value;
                  };
                }
                return _get.apply(this, arguments);
              }
              function _superPropBase(object, property) {
                while (!Object.prototype.hasOwnProperty.call(object, property)) {
                  object = _getPrototypeOf(object);
                  if (object === null)
                    break;
                }
                return object;
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _toConsumableArray2(arr) {
                return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
              }
              function _nonIterableSpread2() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArray2(iter) {
                if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                  return Array.from(iter);
              }
              function _arrayWithoutHoles2(arr) {
                if (Array.isArray(arr))
                  return _arrayLikeToArray2(arr);
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e2) {
                      throw _e2;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e3) {
                  didErr = true;
                  err = _e3;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var DEFAULT_TAB_INDEX = 1e3;
              var GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
              function getRectDims(rect) {
                return {
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              }
              var AnnotationElementFactory = /* @__PURE__ */ function() {
                function AnnotationElementFactory2() {
                  _classCallCheck2(this, AnnotationElementFactory2);
                }
                _createClass2(AnnotationElementFactory2, null, [{
                  key: "create",
                  value: function create(parameters) {
                    var subtype = parameters.data.annotationType;
                    switch (subtype) {
                      case _util2.AnnotationType.LINK:
                        return new LinkAnnotationElement(parameters);
                      case _util2.AnnotationType.TEXT:
                        return new TextAnnotationElement(parameters);
                      case _util2.AnnotationType.WIDGET:
                        var fieldType = parameters.data.fieldType;
                        switch (fieldType) {
                          case "Tx":
                            return new TextWidgetAnnotationElement(parameters);
                          case "Btn":
                            if (parameters.data.radioButton) {
                              return new RadioButtonWidgetAnnotationElement(parameters);
                            } else if (parameters.data.checkBox) {
                              return new CheckboxWidgetAnnotationElement(parameters);
                            }
                            return new PushButtonWidgetAnnotationElement(parameters);
                          case "Ch":
                            return new ChoiceWidgetAnnotationElement(parameters);
                        }
                        return new WidgetAnnotationElement(parameters);
                      case _util2.AnnotationType.POPUP:
                        return new PopupAnnotationElement(parameters);
                      case _util2.AnnotationType.FREETEXT:
                        return new FreeTextAnnotationElement(parameters);
                      case _util2.AnnotationType.LINE:
                        return new LineAnnotationElement(parameters);
                      case _util2.AnnotationType.SQUARE:
                        return new SquareAnnotationElement(parameters);
                      case _util2.AnnotationType.CIRCLE:
                        return new CircleAnnotationElement(parameters);
                      case _util2.AnnotationType.POLYLINE:
                        return new PolylineAnnotationElement(parameters);
                      case _util2.AnnotationType.CARET:
                        return new CaretAnnotationElement(parameters);
                      case _util2.AnnotationType.INK:
                        return new InkAnnotationElement(parameters);
                      case _util2.AnnotationType.POLYGON:
                        return new PolygonAnnotationElement(parameters);
                      case _util2.AnnotationType.HIGHLIGHT:
                        return new HighlightAnnotationElement(parameters);
                      case _util2.AnnotationType.UNDERLINE:
                        return new UnderlineAnnotationElement(parameters);
                      case _util2.AnnotationType.SQUIGGLY:
                        return new SquigglyAnnotationElement(parameters);
                      case _util2.AnnotationType.STRIKEOUT:
                        return new StrikeOutAnnotationElement(parameters);
                      case _util2.AnnotationType.STAMP:
                        return new StampAnnotationElement(parameters);
                      case _util2.AnnotationType.FILEATTACHMENT:
                        return new FileAttachmentAnnotationElement(parameters);
                      default:
                        return new AnnotationElement(parameters);
                    }
                  }
                }]);
                return AnnotationElementFactory2;
              }();
              var AnnotationElement = /* @__PURE__ */ function() {
                function AnnotationElement2(parameters) {
                  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$isRenderable = _ref.isRenderable, isRenderable = _ref$isRenderable === void 0 ? false : _ref$isRenderable, _ref$ignoreBorder = _ref.ignoreBorder, ignoreBorder = _ref$ignoreBorder === void 0 ? false : _ref$ignoreBorder, _ref$createQuadrilate = _ref.createQuadrilaterals, createQuadrilaterals = _ref$createQuadrilate === void 0 ? false : _ref$createQuadrilate;
                  _classCallCheck2(this, AnnotationElement2);
                  this.isRenderable = isRenderable;
                  this.data = parameters.data;
                  this.layer = parameters.layer;
                  this.page = parameters.page;
                  this.viewport = parameters.viewport;
                  this.linkService = parameters.linkService;
                  this.downloadManager = parameters.downloadManager;
                  this.imageResourcesPath = parameters.imageResourcesPath;
                  this.renderForms = parameters.renderForms;
                  this.svgFactory = parameters.svgFactory;
                  this.annotationStorage = parameters.annotationStorage;
                  this.enableScripting = parameters.enableScripting;
                  this.hasJSActions = parameters.hasJSActions;
                  this._fieldObjects = parameters.fieldObjects;
                  this._mouseState = parameters.mouseState;
                  if (isRenderable) {
                    this.container = this._createContainer(ignoreBorder);
                  }
                  if (createQuadrilaterals) {
                    this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                  }
                }
                _createClass2(AnnotationElement2, [{
                  key: "_createContainer",
                  value: function _createContainer() {
                    var ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    var data = this.data, page = this.page, viewport = this.viewport;
                    var container = document.createElement("section");
                    var _getRectDims = getRectDims(data.rect), width = _getRectDims.width, height = _getRectDims.height;
                    container.setAttribute("data-annotation-id", data.id);
                    var rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                    if (data.hasOwnCanvas) {
                      var transform = viewport.transform.slice();
                      var _Util$singularValueDe = _util2.Util.singularValueDecompose2dScale(transform), _Util$singularValueDe2 = _slicedToArray2(_Util$singularValueDe, 2), scaleX = _Util$singularValueDe2[0], scaleY = _Util$singularValueDe2[1];
                      width = Math.ceil(width * scaleX);
                      height = Math.ceil(height * scaleY);
                      rect[0] *= scaleX;
                      rect[1] *= scaleY;
                      for (var i = 0; i < 4; i++) {
                        transform[i] = Math.sign(transform[i]);
                      }
                      container.style.transform = "matrix(".concat(transform.join(","), ")");
                    } else {
                      container.style.transform = "matrix(".concat(viewport.transform.join(","), ")");
                    }
                    container.style.transformOrigin = "".concat(-rect[0], "px ").concat(-rect[1], "px");
                    if (!ignoreBorder && data.borderStyle.width > 0) {
                      container.style.borderWidth = "".concat(data.borderStyle.width, "px");
                      if (data.borderStyle.style !== _util2.AnnotationBorderStyleType.UNDERLINE) {
                        width -= 2 * data.borderStyle.width;
                        height -= 2 * data.borderStyle.width;
                      }
                      var horizontalRadius = data.borderStyle.horizontalCornerRadius;
                      var verticalRadius = data.borderStyle.verticalCornerRadius;
                      if (horizontalRadius > 0 || verticalRadius > 0) {
                        var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px");
                        container.style.borderRadius = radius;
                      }
                      switch (data.borderStyle.style) {
                        case _util2.AnnotationBorderStyleType.SOLID:
                          container.style.borderStyle = "solid";
                          break;
                        case _util2.AnnotationBorderStyleType.DASHED:
                          container.style.borderStyle = "dashed";
                          break;
                        case _util2.AnnotationBorderStyleType.BEVELED:
                          (0, _util2.warn)("Unimplemented border style: beveled");
                          break;
                        case _util2.AnnotationBorderStyleType.INSET:
                          (0, _util2.warn)("Unimplemented border style: inset");
                          break;
                        case _util2.AnnotationBorderStyleType.UNDERLINE:
                          container.style.borderBottomStyle = "solid";
                          break;
                        default:
                          break;
                      }
                      var borderColor = data.borderColor || data.color || null;
                      if (borderColor) {
                        container.style.borderColor = _util2.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                      } else {
                        container.style.borderWidth = 0;
                      }
                    }
                    container.style.left = "".concat(rect[0], "px");
                    container.style.top = "".concat(rect[1], "px");
                    if (data.hasOwnCanvas) {
                      container.style.width = container.style.height = "auto";
                    } else {
                      container.style.width = "".concat(width, "px");
                      container.style.height = "".concat(height, "px");
                    }
                    return container;
                  }
                }, {
                  key: "_commonActions",
                  get: function get2() {
                    var _this = this;
                    var setColor = function setColor2(jsName, styleName, event) {
                      var color = event.detail[jsName];
                      event.target.style[styleName] = _scripting_utils.ColorConverters["".concat(color[0], "_HTML")](color.slice(1));
                    };
                    return (0, _util2.shadow)(this, "_commonActions", {
                      display: function display(event) {
                        var hidden = event.detail.display % 2 === 1;
                        event.target.style.visibility = hidden ? "hidden" : "visible";
                        _this.annotationStorage.setValue(_this.data.id, {
                          hidden,
                          print: event.detail.display === 0 || event.detail.display === 3
                        });
                      },
                      print: function print(event) {
                        _this.annotationStorage.setValue(_this.data.id, {
                          print: event.detail.print
                        });
                      },
                      hidden: function hidden(event) {
                        event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";
                        _this.annotationStorage.setValue(_this.data.id, {
                          hidden: event.detail.hidden
                        });
                      },
                      focus: function focus(event) {
                        setTimeout(function() {
                          return event.target.focus({
                            preventScroll: false
                          });
                        }, 0);
                      },
                      userName: function userName(event) {
                        event.target.title = event.detail.userName;
                      },
                      readonly: function readonly(event) {
                        if (event.detail.readonly) {
                          event.target.setAttribute("readonly", "");
                        } else {
                          event.target.removeAttribute("readonly");
                        }
                      },
                      required: function required(event) {
                        if (event.detail.required) {
                          event.target.setAttribute("required", "");
                        } else {
                          event.target.removeAttribute("required");
                        }
                      },
                      bgColor: function bgColor(event) {
                        setColor("bgColor", "backgroundColor", event);
                      },
                      fillColor: function fillColor(event) {
                        setColor("fillColor", "backgroundColor", event);
                      },
                      fgColor: function fgColor(event) {
                        setColor("fgColor", "color", event);
                      },
                      textColor: function textColor(event) {
                        setColor("textColor", "color", event);
                      },
                      borderColor: function borderColor(event) {
                        setColor("borderColor", "borderColor", event);
                      },
                      strokeColor: function strokeColor(event) {
                        setColor("strokeColor", "borderColor", event);
                      }
                    });
                  }
                }, {
                  key: "_dispatchEventFromSandbox",
                  value: function _dispatchEventFromSandbox(actions, jsEvent) {
                    var commonActions = this._commonActions;
                    for (var _i2 = 0, _Object$keys = Object.keys(jsEvent.detail); _i2 < _Object$keys.length; _i2++) {
                      var name = _Object$keys[_i2];
                      var action = actions[name] || commonActions[name];
                      if (action) {
                        action(jsEvent);
                      }
                    }
                  }
                }, {
                  key: "_setDefaultPropertiesFromJS",
                  value: function _setDefaultPropertiesFromJS(element) {
                    if (!this.enableScripting) {
                      return;
                    }
                    var storedData = this.annotationStorage.getRawValue(this.data.id);
                    if (!storedData) {
                      return;
                    }
                    var commonActions = this._commonActions;
                    for (var _i3 = 0, _Object$entries = Object.entries(storedData); _i3 < _Object$entries.length; _i3++) {
                      var _Object$entries$_i = _slicedToArray2(_Object$entries[_i3], 2), actionName = _Object$entries$_i[0], detail = _Object$entries$_i[1];
                      var action = commonActions[actionName];
                      if (action) {
                        action({
                          detail,
                          target: element
                        });
                        delete storedData[actionName];
                      }
                    }
                  }
                }, {
                  key: "_createQuadrilaterals",
                  value: function _createQuadrilaterals() {
                    var ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (!this.data.quadPoints) {
                      return null;
                    }
                    var quadrilaterals = [];
                    var savedRect = this.data.rect;
                    var _iterator = _createForOfIteratorHelper2(this.data.quadPoints), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var quadPoint = _step.value;
                        this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                        quadrilaterals.push(this._createContainer(ignoreBorder));
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    this.data.rect = savedRect;
                    return quadrilaterals;
                  }
                }, {
                  key: "_createPopup",
                  value: function _createPopup(trigger, data) {
                    var container = this.container;
                    if (this.quadrilaterals) {
                      trigger = trigger || this.quadrilaterals;
                      container = this.quadrilaterals[0];
                    }
                    if (!trigger) {
                      trigger = document.createElement("div");
                      trigger.style.height = container.style.height;
                      trigger.style.width = container.style.width;
                      container.appendChild(trigger);
                    }
                    var popupElement = new PopupElement({
                      container,
                      trigger,
                      color: data.color,
                      titleObj: data.titleObj,
                      modificationDate: data.modificationDate,
                      contentsObj: data.contentsObj,
                      richText: data.richText,
                      hideWrapper: true
                    });
                    var popup = popupElement.render();
                    popup.style.left = container.style.width;
                    container.appendChild(popup);
                  }
                }, {
                  key: "_renderQuadrilaterals",
                  value: function _renderQuadrilaterals(className) {
                    var _iterator2 = _createForOfIteratorHelper2(this.quadrilaterals), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var quadrilateral = _step2.value;
                        quadrilateral.className = className;
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    return this.quadrilaterals;
                  }
                }, {
                  key: "render",
                  value: function render() {
                    (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                  }
                }, {
                  key: "_getElementsByName",
                  value: function _getElementsByName(name) {
                    var skipId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    var fields = [];
                    if (this._fieldObjects) {
                      var fieldObj = this._fieldObjects[name];
                      if (fieldObj) {
                        var _iterator3 = _createForOfIteratorHelper2(fieldObj), _step3;
                        try {
                          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                            var _step3$value = _step3.value, page = _step3$value.page, id = _step3$value.id, exportValues = _step3$value.exportValues;
                            if (page === -1) {
                              continue;
                            }
                            if (id === skipId) {
                              continue;
                            }
                            var exportValue = typeof exportValues === "string" ? exportValues : null;
                            var domElement = document.getElementById(id);
                            if (domElement && !GetElementsByNameSet.has(domElement)) {
                              (0, _util2.warn)("_getElementsByName - element not allowed: ".concat(id));
                              continue;
                            }
                            fields.push({
                              id,
                              exportValue,
                              domElement
                            });
                          }
                        } catch (err) {
                          _iterator3.e(err);
                        } finally {
                          _iterator3.f();
                        }
                      }
                      return fields;
                    }
                    var _iterator4 = _createForOfIteratorHelper2(document.getElementsByName(name)), _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                        var _domElement = _step4.value;
                        var _id = _domElement.id, _exportValue = _domElement.exportValue;
                        if (_id === skipId) {
                          continue;
                        }
                        if (!GetElementsByNameSet.has(_domElement)) {
                          continue;
                        }
                        fields.push({
                          id: _id,
                          exportValue: _exportValue,
                          domElement: _domElement
                        });
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    return fields;
                  }
                }], [{
                  key: "platform",
                  get: function get2() {
                    var platform = typeof navigator !== "undefined" ? navigator.platform : "";
                    return (0, _util2.shadow)(this, "platform", {
                      isWin: platform.includes("Win"),
                      isMac: platform.includes("Mac")
                    });
                  }
                }]);
                return AnnotationElement2;
              }();
              var LinkAnnotationElement = /* @__PURE__ */ function(_AnnotationElement) {
                _inherits(LinkAnnotationElement2, _AnnotationElement);
                var _super = _createSuper(LinkAnnotationElement2);
                function LinkAnnotationElement2(parameters) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  _classCallCheck2(this, LinkAnnotationElement2);
                  var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
                  return _super.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),
                    createQuadrilaterals: true
                  });
                }
                _createClass2(LinkAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    var data = this.data, linkService = this.linkService;
                    var link = document.createElement("a");
                    if (data.url) {
                      linkService.addLinkAttributes(link, data.url, data.newWindow);
                    } else if (data.action) {
                      this._bindNamedAction(link, data.action);
                    } else if (data.dest) {
                      this._bindLink(link, data.dest);
                    } else {
                      var hasClickAction = false;
                      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                        hasClickAction = true;
                        this._bindJSAction(link, data);
                      }
                      if (data.resetForm) {
                        this._bindResetFormAction(link, data.resetForm);
                      } else if (!hasClickAction) {
                        this._bindLink(link, "");
                      }
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("linkAnnotation").map(function(quadrilateral, index) {
                        var linkElement = index === 0 ? link : link.cloneNode();
                        quadrilateral.appendChild(linkElement);
                        return quadrilateral;
                      });
                    }
                    this.container.className = "linkAnnotation";
                    this.container.appendChild(link);
                    return this.container;
                  }
                }, {
                  key: "_bindLink",
                  value: function _bindLink(link, destination) {
                    var _this2 = this;
                    link.href = this.linkService.getDestinationHash(destination);
                    link.onclick = function() {
                      if (destination) {
                        _this2.linkService.goToDestination(destination);
                      }
                      return false;
                    };
                    if (destination || destination === "") {
                      link.className = "internalLink";
                    }
                  }
                }, {
                  key: "_bindNamedAction",
                  value: function _bindNamedAction(link, action) {
                    var _this3 = this;
                    link.href = this.linkService.getAnchorUrl("");
                    link.onclick = function() {
                      _this3.linkService.executeNamedAction(action);
                      return false;
                    };
                    link.className = "internalLink";
                  }
                }, {
                  key: "_bindJSAction",
                  value: function _bindJSAction(link, data) {
                    var _this4 = this;
                    link.href = this.linkService.getAnchorUrl("");
                    var map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                    var _loop = function _loop2() {
                      var name = _Object$keys2[_i4];
                      var jsName = map.get(name);
                      if (!jsName) {
                        return "continue";
                      }
                      link[jsName] = function() {
                        var _this4$linkService$ev;
                        (_this4$linkService$ev = _this4.linkService.eventBus) === null || _this4$linkService$ev === void 0 ? void 0 : _this4$linkService$ev.dispatch("dispatcheventinsandbox", {
                          source: _this4,
                          detail: {
                            id: data.id,
                            name
                          }
                        });
                        return false;
                      };
                    };
                    for (var _i4 = 0, _Object$keys2 = Object.keys(data.actions); _i4 < _Object$keys2.length; _i4++) {
                      var _ret = _loop();
                      if (_ret === "continue")
                        continue;
                    }
                    if (!link.onclick) {
                      link.onclick = function() {
                        return false;
                      };
                    }
                    link.className = "internalLink";
                  }
                }, {
                  key: "_bindResetFormAction",
                  value: function _bindResetFormAction(link, resetForm) {
                    var _this5 = this;
                    var otherClickAction = link.onclick;
                    if (!otherClickAction) {
                      link.href = this.linkService.getAnchorUrl("");
                    }
                    link.className = "internalLink";
                    if (!this._fieldObjects) {
                      (0, _util2.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.');
                      if (!otherClickAction) {
                        link.onclick = function() {
                          return false;
                        };
                      }
                      return;
                    }
                    link.onclick = function() {
                      if (otherClickAction) {
                        otherClickAction();
                      }
                      var resetFormFields = resetForm.fields, resetFormRefs = resetForm.refs, include = resetForm.include;
                      var allFields = [];
                      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                        var fieldIds = new Set(resetFormRefs);
                        var _iterator5 = _createForOfIteratorHelper2(resetFormFields), _step5;
                        try {
                          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                            var fieldName = _step5.value;
                            var _fields = _this5._fieldObjects[fieldName] || [];
                            var _iterator7 = _createForOfIteratorHelper2(_fields), _step7;
                            try {
                              for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                                var id = _step7.value.id;
                                fieldIds.add(id);
                              }
                            } catch (err) {
                              _iterator7.e(err);
                            } finally {
                              _iterator7.f();
                            }
                          }
                        } catch (err) {
                          _iterator5.e(err);
                        } finally {
                          _iterator5.f();
                        }
                        for (var _i5 = 0, _Object$values = Object.values(_this5._fieldObjects); _i5 < _Object$values.length; _i5++) {
                          var fields = _Object$values[_i5];
                          var _iterator6 = _createForOfIteratorHelper2(fields), _step6;
                          try {
                            for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                              var field = _step6.value;
                              if (fieldIds.has(field.id) === include) {
                                allFields.push(field);
                              }
                            }
                          } catch (err) {
                            _iterator6.e(err);
                          } finally {
                            _iterator6.f();
                          }
                        }
                      } else {
                        for (var _i6 = 0, _Object$values2 = Object.values(_this5._fieldObjects); _i6 < _Object$values2.length; _i6++) {
                          var _fields2 = _Object$values2[_i6];
                          allFields.push.apply(allFields, _toConsumableArray2(_fields2));
                        }
                      }
                      var storage = _this5.annotationStorage;
                      var allIds = [];
                      for (var _i7 = 0, _allFields = allFields; _i7 < _allFields.length; _i7++) {
                        var _field = _allFields[_i7];
                        var _id2 = _field.id;
                        allIds.push(_id2);
                        switch (_field.type) {
                          case "text": {
                            var value = _field.defaultValue || "";
                            storage.setValue(_id2, {
                              value
                            });
                            break;
                          }
                          case "checkbox":
                          case "radiobutton": {
                            var _value = _field.defaultValue === _field.exportValues;
                            storage.setValue(_id2, {
                              value: _value
                            });
                            break;
                          }
                          case "combobox":
                          case "listbox": {
                            var _value2 = _field.defaultValue || "";
                            storage.setValue(_id2, {
                              value: _value2
                            });
                            break;
                          }
                          default:
                            continue;
                        }
                        var domElement = document.getElementById(_id2);
                        if (!domElement || !GetElementsByNameSet.has(domElement)) {
                          continue;
                        }
                        domElement.dispatchEvent(new Event("resetform"));
                      }
                      if (_this5.enableScripting) {
                        var _this5$linkService$ev;
                        (_this5$linkService$ev = _this5.linkService.eventBus) === null || _this5$linkService$ev === void 0 ? void 0 : _this5$linkService$ev.dispatch("dispatcheventinsandbox", {
                          source: _this5,
                          detail: {
                            id: "app",
                            ids: allIds,
                            name: "ResetForm"
                          }
                        });
                      }
                      return false;
                    };
                  }
                }]);
                return LinkAnnotationElement2;
              }(AnnotationElement);
              var TextAnnotationElement = /* @__PURE__ */ function(_AnnotationElement2) {
                _inherits(TextAnnotationElement2, _AnnotationElement2);
                var _super2 = _createSuper(TextAnnotationElement2);
                function TextAnnotationElement2(parameters) {
                  var _parameters$data$titl, _parameters$data$cont, _parameters$data$rich;
                  _classCallCheck2(this, TextAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str || (_parameters$data$rich = parameters.data.richText) !== null && _parameters$data$rich !== void 0 && _parameters$data$rich.str);
                  return _super2.call(this, parameters, {
                    isRenderable
                  });
                }
                _createClass2(TextAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = "textAnnotation";
                    var image = document.createElement("img");
                    image.style.height = this.container.style.height;
                    image.style.width = this.container.style.width;
                    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                    image.alt = "[{{type}} Annotation]";
                    image.dataset.l10nId = "text_annotation_type";
                    image.dataset.l10nArgs = JSON.stringify({
                      type: this.data.name
                    });
                    if (!this.data.hasPopup) {
                      this._createPopup(image, this.data);
                    }
                    this.container.appendChild(image);
                    return this.container;
                  }
                }]);
                return TextAnnotationElement2;
              }(AnnotationElement);
              var WidgetAnnotationElement = /* @__PURE__ */ function(_AnnotationElement3) {
                _inherits(WidgetAnnotationElement2, _AnnotationElement3);
                var _super3 = _createSuper(WidgetAnnotationElement2);
                function WidgetAnnotationElement2() {
                  _classCallCheck2(this, WidgetAnnotationElement2);
                  return _super3.apply(this, arguments);
                }
                _createClass2(WidgetAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    if (this.data.alternativeText) {
                      this.container.title = this.data.alternativeText;
                    }
                    return this.container;
                  }
                }, {
                  key: "_getKeyModifier",
                  value: function _getKeyModifier(event) {
                    var _AnnotationElement$pl = AnnotationElement.platform, isWin = _AnnotationElement$pl.isWin, isMac = _AnnotationElement$pl.isMac;
                    return isWin && event.ctrlKey || isMac && event.metaKey;
                  }
                }, {
                  key: "_setEventListener",
                  value: function _setEventListener(element, baseName, eventName, valueGetter) {
                    var _this6 = this;
                    if (baseName.includes("mouse")) {
                      element.addEventListener(baseName, function(event) {
                        var _this6$linkService$ev;
                        (_this6$linkService$ev = _this6.linkService.eventBus) === null || _this6$linkService$ev === void 0 ? void 0 : _this6$linkService$ev.dispatch("dispatcheventinsandbox", {
                          source: _this6,
                          detail: {
                            id: _this6.data.id,
                            name: eventName,
                            value: valueGetter(event),
                            shift: event.shiftKey,
                            modifier: _this6._getKeyModifier(event)
                          }
                        });
                      });
                    } else {
                      element.addEventListener(baseName, function(event) {
                        var _this6$linkService$ev2;
                        (_this6$linkService$ev2 = _this6.linkService.eventBus) === null || _this6$linkService$ev2 === void 0 ? void 0 : _this6$linkService$ev2.dispatch("dispatcheventinsandbox", {
                          source: _this6,
                          detail: {
                            id: _this6.data.id,
                            name: eventName,
                            value: valueGetter(event)
                          }
                        });
                      });
                    }
                  }
                }, {
                  key: "_setEventListeners",
                  value: function _setEventListeners(element, names, getter) {
                    var _iterator8 = _createForOfIteratorHelper2(names), _step8;
                    try {
                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                        var _this$data$actions;
                        var _step8$value = _slicedToArray2(_step8.value, 2), baseName = _step8$value[0], eventName = _step8$value[1];
                        if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
                          this._setEventListener(element, baseName, eventName, getter);
                        }
                      }
                    } catch (err) {
                      _iterator8.e(err);
                    } finally {
                      _iterator8.f();
                    }
                  }
                }, {
                  key: "_setBackgroundColor",
                  value: function _setBackgroundColor(element) {
                    var color = this.data.backgroundColor || null;
                    element.style.backgroundColor = color === null ? "transparent" : _util2.Util.makeHexColor(color[0], color[1], color[2]);
                  }
                }]);
                return WidgetAnnotationElement2;
              }(AnnotationElement);
              var TextWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem) {
                _inherits(TextWidgetAnnotationElement2, _WidgetAnnotationElem);
                var _super4 = _createSuper(TextWidgetAnnotationElement2);
                function TextWidgetAnnotationElement2(parameters) {
                  _classCallCheck2(this, TextWidgetAnnotationElement2);
                  var isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                  return _super4.call(this, parameters, {
                    isRenderable
                  });
                }
                _createClass2(TextWidgetAnnotationElement2, [{
                  key: "setPropertyOnSiblings",
                  value: function setPropertyOnSiblings(base, key, value, keyInStorage) {
                    var storage = this.annotationStorage;
                    var _iterator9 = _createForOfIteratorHelper2(this._getElementsByName(base.name, base.id)), _step9;
                    try {
                      for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                        var element = _step9.value;
                        if (element.domElement) {
                          element.domElement[key] = value;
                        }
                        storage.setValue(element.id, _defineProperty({}, keyInStorage, value));
                      }
                    } catch (err) {
                      _iterator9.e(err);
                    } finally {
                      _iterator9.f();
                    }
                  }
                }, {
                  key: "render",
                  value: function render() {
                    var _this7 = this;
                    var storage = this.annotationStorage;
                    var id = this.data.id;
                    this.container.className = "textWidgetAnnotation";
                    var element = null;
                    if (this.renderForms) {
                      var storedData = storage.getValue(id, {
                        value: this.data.fieldValue
                      });
                      var textContent = storedData.formattedValue || storedData.value || "";
                      var elementData = {
                        userValue: null,
                        formattedValue: null,
                        valueOnFocus: ""
                      };
                      if (this.data.multiLine) {
                        element = document.createElement("textarea");
                        element.textContent = textContent;
                      } else {
                        element = document.createElement("input");
                        element.type = "text";
                        element.setAttribute("value", textContent);
                      }
                      GetElementsByNameSet.add(element);
                      element.disabled = this.data.readOnly;
                      element.name = this.data.fieldName;
                      element.tabIndex = DEFAULT_TAB_INDEX;
                      elementData.userValue = textContent;
                      element.setAttribute("id", id);
                      element.addEventListener("input", function(event) {
                        storage.setValue(id, {
                          value: event.target.value
                        });
                        _this7.setPropertyOnSiblings(element, "value", event.target.value, "value");
                      });
                      element.addEventListener("resetform", function(event) {
                        var _this7$data$defaultFi;
                        var defaultValue = (_this7$data$defaultFi = _this7.data.defaultFieldValue) !== null && _this7$data$defaultFi !== void 0 ? _this7$data$defaultFi : "";
                        element.value = elementData.userValue = defaultValue;
                        elementData.formattedValue = null;
                      });
                      var blurListener = function blurListener2(event) {
                        var formattedValue = elementData.formattedValue;
                        if (formattedValue !== null && formattedValue !== void 0) {
                          event.target.value = formattedValue;
                        }
                        event.target.scrollLeft = 0;
                      };
                      if (this.enableScripting && this.hasJSActions) {
                        var _this$data$actions2;
                        element.addEventListener("focus", function(event) {
                          if (elementData.userValue) {
                            event.target.value = elementData.userValue;
                          }
                          elementData.valueOnFocus = event.target.value;
                        });
                        element.addEventListener("updatefromsandbox", function(jsEvent) {
                          var actions = {
                            value: function value(event) {
                              var _event$detail$value;
                              elementData.userValue = (_event$detail$value = event.detail.value) !== null && _event$detail$value !== void 0 ? _event$detail$value : "";
                              storage.setValue(id, {
                                value: elementData.userValue.toString()
                              });
                              event.target.value = elementData.userValue;
                            },
                            formattedValue: function formattedValue(event) {
                              var formattedValue2 = event.detail.formattedValue;
                              elementData.formattedValue = formattedValue2;
                              if (formattedValue2 !== null && formattedValue2 !== void 0 && event.target !== document.activeElement) {
                                event.target.value = formattedValue2;
                              }
                              storage.setValue(id, {
                                formattedValue: formattedValue2
                              });
                            },
                            selRange: function selRange(event) {
                              var _event$target;
                              (_event$target = event.target).setSelectionRange.apply(_event$target, _toConsumableArray2(event.detail.selRange));
                            }
                          };
                          _this7._dispatchEventFromSandbox(actions, jsEvent);
                        });
                        element.addEventListener("keydown", function(event) {
                          var _this7$linkService$ev;
                          var commitKey = -1;
                          if (event.key === "Escape") {
                            commitKey = 0;
                          } else if (event.key === "Enter") {
                            commitKey = 2;
                          } else if (event.key === "Tab") {
                            commitKey = 3;
                          }
                          if (commitKey === -1) {
                            return;
                          }
                          var value = event.target.value;
                          if (elementData.valueOnFocus === value) {
                            return;
                          }
                          elementData.userValue = value;
                          (_this7$linkService$ev = _this7.linkService.eventBus) === null || _this7$linkService$ev === void 0 ? void 0 : _this7$linkService$ev.dispatch("dispatcheventinsandbox", {
                            source: _this7,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              willCommit: true,
                              commitKey,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        });
                        var _blurListener = blurListener;
                        blurListener = null;
                        element.addEventListener("blur", function(event) {
                          var value = event.target.value;
                          elementData.userValue = value;
                          if (_this7._mouseState.isDown && elementData.valueOnFocus !== value) {
                            var _this7$linkService$ev2;
                            (_this7$linkService$ev2 = _this7.linkService.eventBus) === null || _this7$linkService$ev2 === void 0 ? void 0 : _this7$linkService$ev2.dispatch("dispatcheventinsandbox", {
                              source: _this7,
                              detail: {
                                id,
                                name: "Keystroke",
                                value,
                                willCommit: true,
                                commitKey: 1,
                                selStart: event.target.selectionStart,
                                selEnd: event.target.selectionEnd
                              }
                            });
                          }
                          _blurListener(event);
                        });
                        if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
                          element.addEventListener("beforeinput", function(event) {
                            var _this7$linkService$ev3;
                            var data = event.data, target = event.target;
                            var value = target.value, selectionStart = target.selectionStart, selectionEnd = target.selectionEnd;
                            var selStart = selectionStart, selEnd = selectionEnd;
                            switch (event.inputType) {
                              case "deleteWordBackward": {
                                var match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                                if (match) {
                                  selStart -= match[0].length;
                                }
                                break;
                              }
                              case "deleteWordForward": {
                                var _match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                                if (_match) {
                                  selEnd += _match[0].length;
                                }
                                break;
                              }
                              case "deleteContentBackward":
                                if (selectionStart === selectionEnd) {
                                  selStart -= 1;
                                }
                                break;
                              case "deleteContentForward":
                                if (selectionStart === selectionEnd) {
                                  selEnd += 1;
                                }
                                break;
                            }
                            event.preventDefault();
                            (_this7$linkService$ev3 = _this7.linkService.eventBus) === null || _this7$linkService$ev3 === void 0 ? void 0 : _this7$linkService$ev3.dispatch("dispatcheventinsandbox", {
                              source: _this7,
                              detail: {
                                id,
                                name: "Keystroke",
                                value,
                                change: data || "",
                                willCommit: false,
                                selStart,
                                selEnd
                              }
                            });
                          });
                        }
                        this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function(event) {
                          return event.target.value;
                        });
                      }
                      if (blurListener) {
                        element.addEventListener("blur", blurListener);
                      }
                      if (this.data.maxLen !== null) {
                        element.maxLength = this.data.maxLen;
                      }
                      if (this.data.comb) {
                        var fieldWidth = this.data.rect[2] - this.data.rect[0];
                        var combWidth = fieldWidth / this.data.maxLen;
                        element.classList.add("comb");
                        element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)");
                      }
                    } else {
                      element = document.createElement("div");
                      element.textContent = this.data.fieldValue;
                      element.style.verticalAlign = "middle";
                      element.style.display = "table-cell";
                    }
                    this._setTextStyle(element);
                    this._setBackgroundColor(element);
                    this._setDefaultPropertiesFromJS(element);
                    this.container.appendChild(element);
                    return this.container;
                  }
                }, {
                  key: "_setTextStyle",
                  value: function _setTextStyle(element) {
                    var TEXT_ALIGNMENT = ["left", "center", "right"];
                    var _this$data$defaultApp = this.data.defaultAppearanceData, fontSize = _this$data$defaultApp.fontSize, fontColor = _this$data$defaultApp.fontColor;
                    var style = element.style;
                    if (fontSize) {
                      style.fontSize = "".concat(fontSize, "px");
                    }
                    style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                    if (this.data.textAlignment !== null) {
                      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                    }
                  }
                }]);
                return TextWidgetAnnotationElement2;
              }(WidgetAnnotationElement);
              var CheckboxWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem2) {
                _inherits(CheckboxWidgetAnnotationElement2, _WidgetAnnotationElem2);
                var _super5 = _createSuper(CheckboxWidgetAnnotationElement2);
                function CheckboxWidgetAnnotationElement2(parameters) {
                  _classCallCheck2(this, CheckboxWidgetAnnotationElement2);
                  return _super5.call(this, parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                _createClass2(CheckboxWidgetAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    var _this8 = this;
                    var storage = this.annotationStorage;
                    var data = this.data;
                    var id = data.id;
                    var value = storage.getValue(id, {
                      value: data.exportValue === data.fieldValue
                    }).value;
                    if (typeof value === "string") {
                      value = value !== "Off";
                      storage.setValue(id, {
                        value
                      });
                    }
                    this.container.className = "buttonWidgetAnnotation checkBox";
                    var element = document.createElement("input");
                    GetElementsByNameSet.add(element);
                    element.disabled = data.readOnly;
                    element.type = "checkbox";
                    element.name = data.fieldName;
                    if (value) {
                      element.setAttribute("checked", true);
                    }
                    element.setAttribute("id", id);
                    element.setAttribute("exportValue", data.exportValue);
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    element.addEventListener("change", function(event) {
                      var _event$target2 = event.target, name = _event$target2.name, checked = _event$target2.checked;
                      var _iterator10 = _createForOfIteratorHelper2(_this8._getElementsByName(name, id)), _step10;
                      try {
                        for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                          var checkbox = _step10.value;
                          var curChecked = checked && checkbox.exportValue === data.exportValue;
                          if (checkbox.domElement) {
                            checkbox.domElement.checked = curChecked;
                          }
                          storage.setValue(checkbox.id, {
                            value: curChecked
                          });
                        }
                      } catch (err) {
                        _iterator10.e(err);
                      } finally {
                        _iterator10.f();
                      }
                      storage.setValue(id, {
                        value: checked
                      });
                    });
                    element.addEventListener("resetform", function(event) {
                      var defaultValue = data.defaultFieldValue || "Off";
                      event.target.checked = defaultValue === data.exportValue;
                    });
                    if (this.enableScripting && this.hasJSActions) {
                      element.addEventListener("updatefromsandbox", function(jsEvent) {
                        var actions = {
                          value: function value2(event) {
                            event.target.checked = event.detail.value !== "Off";
                            storage.setValue(id, {
                              value: event.target.checked
                            });
                          }
                        };
                        _this8._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function(event) {
                        return event.target.checked;
                      });
                    }
                    this._setBackgroundColor(element);
                    this._setDefaultPropertiesFromJS(element);
                    this.container.appendChild(element);
                    return this.container;
                  }
                }]);
                return CheckboxWidgetAnnotationElement2;
              }(WidgetAnnotationElement);
              var RadioButtonWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem3) {
                _inherits(RadioButtonWidgetAnnotationElement2, _WidgetAnnotationElem3);
                var _super6 = _createSuper(RadioButtonWidgetAnnotationElement2);
                function RadioButtonWidgetAnnotationElement2(parameters) {
                  _classCallCheck2(this, RadioButtonWidgetAnnotationElement2);
                  return _super6.call(this, parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                _createClass2(RadioButtonWidgetAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    var _this9 = this;
                    this.container.className = "buttonWidgetAnnotation radioButton";
                    var storage = this.annotationStorage;
                    var data = this.data;
                    var id = data.id;
                    var value = storage.getValue(id, {
                      value: data.fieldValue === data.buttonValue
                    }).value;
                    if (typeof value === "string") {
                      value = value !== data.buttonValue;
                      storage.setValue(id, {
                        value
                      });
                    }
                    var element = document.createElement("input");
                    GetElementsByNameSet.add(element);
                    element.disabled = data.readOnly;
                    element.type = "radio";
                    element.name = data.fieldName;
                    if (value) {
                      element.setAttribute("checked", true);
                    }
                    element.setAttribute("id", id);
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    element.addEventListener("change", function(event) {
                      var _event$target3 = event.target, name = _event$target3.name, checked = _event$target3.checked;
                      var _iterator11 = _createForOfIteratorHelper2(_this9._getElementsByName(name, id)), _step11;
                      try {
                        for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                          var radio = _step11.value;
                          storage.setValue(radio.id, {
                            value: false
                          });
                        }
                      } catch (err) {
                        _iterator11.e(err);
                      } finally {
                        _iterator11.f();
                      }
                      storage.setValue(id, {
                        value: checked
                      });
                    });
                    element.addEventListener("resetform", function(event) {
                      var defaultValue = data.defaultFieldValue;
                      event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                    });
                    if (this.enableScripting && this.hasJSActions) {
                      var pdfButtonValue = data.buttonValue;
                      element.addEventListener("updatefromsandbox", function(jsEvent) {
                        var actions = {
                          value: function value2(event) {
                            var checked = pdfButtonValue === event.detail.value;
                            var _iterator12 = _createForOfIteratorHelper2(_this9._getElementsByName(event.target.name)), _step12;
                            try {
                              for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                                var radio = _step12.value;
                                var curChecked = checked && radio.id === id;
                                if (radio.domElement) {
                                  radio.domElement.checked = curChecked;
                                }
                                storage.setValue(radio.id, {
                                  value: curChecked
                                });
                              }
                            } catch (err) {
                              _iterator12.e(err);
                            } finally {
                              _iterator12.f();
                            }
                          }
                        };
                        _this9._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function(event) {
                        return event.target.checked;
                      });
                    }
                    this._setBackgroundColor(element);
                    this._setDefaultPropertiesFromJS(element);
                    this.container.appendChild(element);
                    return this.container;
                  }
                }]);
                return RadioButtonWidgetAnnotationElement2;
              }(WidgetAnnotationElement);
              var PushButtonWidgetAnnotationElement = /* @__PURE__ */ function(_LinkAnnotationElemen) {
                _inherits(PushButtonWidgetAnnotationElement2, _LinkAnnotationElemen);
                var _super7 = _createSuper(PushButtonWidgetAnnotationElement2);
                function PushButtonWidgetAnnotationElement2(parameters) {
                  _classCallCheck2(this, PushButtonWidgetAnnotationElement2);
                  return _super7.call(this, parameters, {
                    ignoreBorder: parameters.data.hasAppearance
                  });
                }
                _createClass2(PushButtonWidgetAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement2.prototype), "render", this).call(this);
                    container.className = "buttonWidgetAnnotation pushButton";
                    if (this.data.alternativeText) {
                      container.title = this.data.alternativeText;
                    }
                    this._setDefaultPropertiesFromJS(container);
                    return container;
                  }
                }]);
                return PushButtonWidgetAnnotationElement2;
              }(LinkAnnotationElement);
              var ChoiceWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem4) {
                _inherits(ChoiceWidgetAnnotationElement2, _WidgetAnnotationElem4);
                var _super8 = _createSuper(ChoiceWidgetAnnotationElement2);
                function ChoiceWidgetAnnotationElement2(parameters) {
                  _classCallCheck2(this, ChoiceWidgetAnnotationElement2);
                  return _super8.call(this, parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                _createClass2(ChoiceWidgetAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    var _this10 = this;
                    this.container.className = "choiceWidgetAnnotation";
                    var storage = this.annotationStorage;
                    var id = this.data.id;
                    var storedData = storage.getValue(id, {
                      value: this.data.fieldValue
                    });
                    var fontSize = this.data.defaultAppearanceData.fontSize;
                    if (!fontSize) {
                      fontSize = 9;
                    }
                    var fontSizeStyle = "calc(".concat(fontSize, "px * var(--zoom-factor))");
                    var selectElement = document.createElement("select");
                    GetElementsByNameSet.add(selectElement);
                    selectElement.disabled = this.data.readOnly;
                    selectElement.name = this.data.fieldName;
                    selectElement.setAttribute("id", id);
                    selectElement.tabIndex = DEFAULT_TAB_INDEX;
                    selectElement.style.fontSize = "".concat(fontSize, "px");
                    if (!this.data.combo) {
                      selectElement.size = this.data.options.length;
                      if (this.data.multiSelect) {
                        selectElement.multiple = true;
                      }
                    }
                    selectElement.addEventListener("resetform", function(event) {
                      var defaultValue = _this10.data.defaultFieldValue;
                      var _iterator13 = _createForOfIteratorHelper2(selectElement.options), _step13;
                      try {
                        for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
                          var option2 = _step13.value;
                          option2.selected = option2.value === defaultValue;
                        }
                      } catch (err) {
                        _iterator13.e(err);
                      } finally {
                        _iterator13.f();
                      }
                    });
                    var _iterator14 = _createForOfIteratorHelper2(this.data.options), _step14;
                    try {
                      for (_iterator14.s(); !(_step14 = _iterator14.n()).done; ) {
                        var option = _step14.value;
                        var optionElement = document.createElement("option");
                        optionElement.textContent = option.displayValue;
                        optionElement.value = option.exportValue;
                        if (this.data.combo) {
                          optionElement.style.fontSize = fontSizeStyle;
                        }
                        if (storedData.value.includes(option.exportValue)) {
                          optionElement.setAttribute("selected", true);
                        }
                        selectElement.appendChild(optionElement);
                      }
                    } catch (err) {
                      _iterator14.e(err);
                    } finally {
                      _iterator14.f();
                    }
                    var getValue = function getValue2(event, isExport) {
                      var name = isExport ? "value" : "textContent";
                      var options = event.target.options;
                      if (!event.target.multiple) {
                        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                      }
                      return Array.prototype.filter.call(options, function(option2) {
                        return option2.selected;
                      }).map(function(option2) {
                        return option2[name];
                      });
                    };
                    var getItems = function getItems2(event) {
                      var options = event.target.options;
                      return Array.prototype.map.call(options, function(option2) {
                        return {
                          displayValue: option2.textContent,
                          exportValue: option2.value
                        };
                      });
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      selectElement.addEventListener("updatefromsandbox", function(jsEvent) {
                        var actions = {
                          value: function value(event) {
                            var value2 = event.detail.value;
                            var values = new Set(Array.isArray(value2) ? value2 : [value2]);
                            var _iterator15 = _createForOfIteratorHelper2(selectElement.options), _step15;
                            try {
                              for (_iterator15.s(); !(_step15 = _iterator15.n()).done; ) {
                                var option2 = _step15.value;
                                option2.selected = values.has(option2.value);
                              }
                            } catch (err) {
                              _iterator15.e(err);
                            } finally {
                              _iterator15.f();
                            }
                            storage.setValue(id, {
                              value: getValue(event, true)
                            });
                          },
                          multipleSelection: function multipleSelection(event) {
                            selectElement.multiple = true;
                          },
                          remove: function remove(event) {
                            var options = selectElement.options;
                            var index = event.detail.remove;
                            options[index].selected = false;
                            selectElement.remove(index);
                            if (options.length > 0) {
                              var i = Array.prototype.findIndex.call(options, function(option2) {
                                return option2.selected;
                              });
                              if (i === -1) {
                                options[0].selected = true;
                              }
                            }
                            storage.setValue(id, {
                              value: getValue(event, true),
                              items: getItems(event)
                            });
                          },
                          clear: function clear(event) {
                            while (selectElement.length !== 0) {
                              selectElement.remove(0);
                            }
                            storage.setValue(id, {
                              value: null,
                              items: []
                            });
                          },
                          insert: function insert(event) {
                            var _event$detail$insert = event.detail.insert, index = _event$detail$insert.index, displayValue = _event$detail$insert.displayValue, exportValue = _event$detail$insert.exportValue;
                            var optionElement2 = document.createElement("option");
                            optionElement2.textContent = displayValue;
                            optionElement2.value = exportValue;
                            selectElement.insertBefore(optionElement2, selectElement.children[index]);
                            storage.setValue(id, {
                              value: getValue(event, true),
                              items: getItems(event)
                            });
                          },
                          items: function items(event) {
                            var items2 = event.detail.items;
                            while (selectElement.length !== 0) {
                              selectElement.remove(0);
                            }
                            var _iterator16 = _createForOfIteratorHelper2(items2), _step16;
                            try {
                              for (_iterator16.s(); !(_step16 = _iterator16.n()).done; ) {
                                var item = _step16.value;
                                var displayValue = item.displayValue, exportValue = item.exportValue;
                                var optionElement2 = document.createElement("option");
                                optionElement2.textContent = displayValue;
                                optionElement2.value = exportValue;
                                selectElement.appendChild(optionElement2);
                              }
                            } catch (err) {
                              _iterator16.e(err);
                            } finally {
                              _iterator16.f();
                            }
                            if (selectElement.options.length > 0) {
                              selectElement.options[0].selected = true;
                            }
                            storage.setValue(id, {
                              value: getValue(event, true),
                              items: getItems(event)
                            });
                          },
                          indices: function indices(event) {
                            var indices2 = new Set(event.detail.indices);
                            var _iterator17 = _createForOfIteratorHelper2(event.target.options), _step17;
                            try {
                              for (_iterator17.s(); !(_step17 = _iterator17.n()).done; ) {
                                var option2 = _step17.value;
                                option2.selected = indices2.has(option2.index);
                              }
                            } catch (err) {
                              _iterator17.e(err);
                            } finally {
                              _iterator17.f();
                            }
                            storage.setValue(id, {
                              value: getValue(event, true)
                            });
                          },
                          editable: function editable(event) {
                            event.target.disabled = !event.detail.editable;
                          }
                        };
                        _this10._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      selectElement.addEventListener("input", function(event) {
                        var _this10$linkService$e;
                        var exportValue = getValue(event, true);
                        var value = getValue(event, false);
                        storage.setValue(id, {
                          value: exportValue
                        });
                        (_this10$linkService$e = _this10.linkService.eventBus) === null || _this10$linkService$e === void 0 ? void 0 : _this10$linkService$e.dispatch("dispatcheventinsandbox", {
                          source: _this10,
                          detail: {
                            id,
                            name: "Keystroke",
                            value,
                            changeEx: exportValue,
                            willCommit: true,
                            commitKey: 1,
                            keyDown: false
                          }
                        });
                      });
                      this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], function(event) {
                        return event.target.checked;
                      });
                    } else {
                      selectElement.addEventListener("input", function(event) {
                        storage.setValue(id, {
                          value: getValue(event, true)
                        });
                      });
                    }
                    this._setBackgroundColor(selectElement);
                    this._setDefaultPropertiesFromJS(selectElement);
                    this.container.appendChild(selectElement);
                    return this.container;
                  }
                }]);
                return ChoiceWidgetAnnotationElement2;
              }(WidgetAnnotationElement);
              var PopupAnnotationElement = /* @__PURE__ */ function(_AnnotationElement4) {
                _inherits(PopupAnnotationElement2, _AnnotationElement4);
                var _super9 = _createSuper(PopupAnnotationElement2);
                function PopupAnnotationElement2(parameters) {
                  var _parameters$data$titl2, _parameters$data$cont2, _parameters$data$rich2;
                  _classCallCheck2(this, PopupAnnotationElement2);
                  var isRenderable = !!((_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str || (_parameters$data$rich2 = parameters.data.richText) !== null && _parameters$data$rich2 !== void 0 && _parameters$data$rich2.str);
                  return _super9.call(this, parameters, {
                    isRenderable
                  });
                }
                _createClass2(PopupAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                    this.container.className = "popupAnnotation";
                    if (IGNORE_TYPES.includes(this.data.parentType)) {
                      return this.container;
                    }
                    var selector = '[data-annotation-id="'.concat(this.data.parentId, '"]');
                    var parentElements = this.layer.querySelectorAll(selector);
                    if (parentElements.length === 0) {
                      return this.container;
                    }
                    var popup = new PopupElement({
                      container: this.container,
                      trigger: Array.from(parentElements),
                      color: this.data.color,
                      titleObj: this.data.titleObj,
                      modificationDate: this.data.modificationDate,
                      contentsObj: this.data.contentsObj,
                      richText: this.data.richText
                    });
                    var page = this.page;
                    var rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                    var popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                    var popupTop = rect[1];
                    this.container.style.transformOrigin = "".concat(-popupLeft, "px ").concat(-popupTop, "px");
                    this.container.style.left = "".concat(popupLeft, "px");
                    this.container.style.top = "".concat(popupTop, "px");
                    this.container.appendChild(popup.render());
                    return this.container;
                  }
                }]);
                return PopupAnnotationElement2;
              }(AnnotationElement);
              var PopupElement = /* @__PURE__ */ function() {
                function PopupElement2(parameters) {
                  _classCallCheck2(this, PopupElement2);
                  this.container = parameters.container;
                  this.trigger = parameters.trigger;
                  this.color = parameters.color;
                  this.titleObj = parameters.titleObj;
                  this.modificationDate = parameters.modificationDate;
                  this.contentsObj = parameters.contentsObj;
                  this.richText = parameters.richText;
                  this.hideWrapper = parameters.hideWrapper || false;
                  this.pinned = false;
                }
                _createClass2(PopupElement2, [{
                  key: "render",
                  value: function render() {
                    var _this$richText, _this$contentsObj;
                    var BACKGROUND_ENLIGHT = 0.7;
                    var wrapper = document.createElement("div");
                    wrapper.className = "popupWrapper";
                    this.hideElement = this.hideWrapper ? wrapper : this.container;
                    this.hideElement.hidden = true;
                    var popup = document.createElement("div");
                    popup.className = "popup";
                    var color = this.color;
                    if (color) {
                      var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                      var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                      var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                      popup.style.backgroundColor = _util2.Util.makeHexColor(r | 0, g | 0, b | 0);
                    }
                    var title = document.createElement("h1");
                    title.dir = this.titleObj.dir;
                    title.textContent = this.titleObj.str;
                    popup.appendChild(title);
                    var dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                    if (dateObject) {
                      var modificationDate = document.createElement("span");
                      modificationDate.className = "popupDate";
                      modificationDate.textContent = "{{date}}, {{time}}";
                      modificationDate.dataset.l10nId = "annotation_date_string";
                      modificationDate.dataset.l10nArgs = JSON.stringify({
                        date: dateObject.toLocaleDateString(),
                        time: dateObject.toLocaleTimeString()
                      });
                      popup.appendChild(modificationDate);
                    }
                    if ((_this$richText = this.richText) !== null && _this$richText !== void 0 && _this$richText.str && (!((_this$contentsObj = this.contentsObj) !== null && _this$contentsObj !== void 0 && _this$contentsObj.str) || this.contentsObj.str === this.richText.str)) {
                      _xfa_layer.XfaLayer.render({
                        xfaHtml: this.richText.html,
                        intent: "richText",
                        div: popup
                      });
                      popup.lastChild.className = "richText popupContent";
                    } else {
                      var contents = this._formatContents(this.contentsObj);
                      popup.appendChild(contents);
                    }
                    if (!Array.isArray(this.trigger)) {
                      this.trigger = [this.trigger];
                    }
                    var _iterator18 = _createForOfIteratorHelper2(this.trigger), _step18;
                    try {
                      for (_iterator18.s(); !(_step18 = _iterator18.n()).done; ) {
                        var element = _step18.value;
                        element.addEventListener("click", this._toggle.bind(this));
                        element.addEventListener("mouseover", this._show.bind(this, false));
                        element.addEventListener("mouseout", this._hide.bind(this, false));
                      }
                    } catch (err) {
                      _iterator18.e(err);
                    } finally {
                      _iterator18.f();
                    }
                    popup.addEventListener("click", this._hide.bind(this, true));
                    wrapper.appendChild(popup);
                    return wrapper;
                  }
                }, {
                  key: "_formatContents",
                  value: function _formatContents(_ref2) {
                    var str = _ref2.str, dir = _ref2.dir;
                    var p = document.createElement("p");
                    p.className = "popupContent";
                    p.dir = dir;
                    var lines = str.split(/(?:\r\n?|\n)/);
                    for (var i = 0, ii = lines.length; i < ii; ++i) {
                      var line = lines[i];
                      p.appendChild(document.createTextNode(line));
                      if (i < ii - 1) {
                        p.appendChild(document.createElement("br"));
                      }
                    }
                    return p;
                  }
                }, {
                  key: "_toggle",
                  value: function _toggle() {
                    if (this.pinned) {
                      this._hide(true);
                    } else {
                      this._show(true);
                    }
                  }
                }, {
                  key: "_show",
                  value: function _show() {
                    var pin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (pin) {
                      this.pinned = true;
                    }
                    if (this.hideElement.hidden) {
                      this.hideElement.hidden = false;
                      this.container.style.zIndex += 1;
                    }
                  }
                }, {
                  key: "_hide",
                  value: function _hide() {
                    var unpin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                    if (unpin) {
                      this.pinned = false;
                    }
                    if (!this.hideElement.hidden && !this.pinned) {
                      this.hideElement.hidden = true;
                      this.container.style.zIndex -= 1;
                    }
                  }
                }]);
                return PopupElement2;
              }();
              var FreeTextAnnotationElement = /* @__PURE__ */ function(_AnnotationElement5) {
                _inherits(FreeTextAnnotationElement2, _AnnotationElement5);
                var _super10 = _createSuper(FreeTextAnnotationElement2);
                function FreeTextAnnotationElement2(parameters) {
                  var _parameters$data$titl3, _parameters$data$cont3, _parameters$data$rich3;
                  _classCallCheck2(this, FreeTextAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str || (_parameters$data$rich3 = parameters.data.richText) !== null && _parameters$data$rich3 !== void 0 && _parameters$data$rich3.str);
                  return _super10.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                _createClass2(FreeTextAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = "freeTextAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    return this.container;
                  }
                }]);
                return FreeTextAnnotationElement2;
              }(AnnotationElement);
              var LineAnnotationElement = /* @__PURE__ */ function(_AnnotationElement6) {
                _inherits(LineAnnotationElement2, _AnnotationElement6);
                var _super11 = _createSuper(LineAnnotationElement2);
                function LineAnnotationElement2(parameters) {
                  var _parameters$data$titl4, _parameters$data$cont4, _parameters$data$rich4;
                  _classCallCheck2(this, LineAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str || (_parameters$data$rich4 = parameters.data.richText) !== null && _parameters$data$rich4 !== void 0 && _parameters$data$rich4.str);
                  return _super11.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                _createClass2(LineAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = "lineAnnotation";
                    var data = this.data;
                    var _getRectDims2 = getRectDims(data.rect), width = _getRectDims2.width, height = _getRectDims2.height;
                    var svg = this.svgFactory.create(width, height);
                    var line = this.svgFactory.createElement("svg:line");
                    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                    line.setAttribute("stroke-width", data.borderStyle.width || 1);
                    line.setAttribute("stroke", "transparent");
                    line.setAttribute("fill", "transparent");
                    svg.appendChild(line);
                    this.container.append(svg);
                    this._createPopup(line, data);
                    return this.container;
                  }
                }]);
                return LineAnnotationElement2;
              }(AnnotationElement);
              var SquareAnnotationElement = /* @__PURE__ */ function(_AnnotationElement7) {
                _inherits(SquareAnnotationElement2, _AnnotationElement7);
                var _super12 = _createSuper(SquareAnnotationElement2);
                function SquareAnnotationElement2(parameters) {
                  var _parameters$data$titl5, _parameters$data$cont5, _parameters$data$rich5;
                  _classCallCheck2(this, SquareAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str || (_parameters$data$rich5 = parameters.data.richText) !== null && _parameters$data$rich5 !== void 0 && _parameters$data$rich5.str);
                  return _super12.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                _createClass2(SquareAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = "squareAnnotation";
                    var data = this.data;
                    var _getRectDims3 = getRectDims(data.rect), width = _getRectDims3.width, height = _getRectDims3.height;
                    var svg = this.svgFactory.create(width, height);
                    var borderWidth = data.borderStyle.width;
                    var square = this.svgFactory.createElement("svg:rect");
                    square.setAttribute("x", borderWidth / 2);
                    square.setAttribute("y", borderWidth / 2);
                    square.setAttribute("width", width - borderWidth);
                    square.setAttribute("height", height - borderWidth);
                    square.setAttribute("stroke-width", borderWidth || 1);
                    square.setAttribute("stroke", "transparent");
                    square.setAttribute("fill", "transparent");
                    svg.appendChild(square);
                    this.container.append(svg);
                    this._createPopup(square, data);
                    return this.container;
                  }
                }]);
                return SquareAnnotationElement2;
              }(AnnotationElement);
              var CircleAnnotationElement = /* @__PURE__ */ function(_AnnotationElement8) {
                _inherits(CircleAnnotationElement2, _AnnotationElement8);
                var _super13 = _createSuper(CircleAnnotationElement2);
                function CircleAnnotationElement2(parameters) {
                  var _parameters$data$titl6, _parameters$data$cont6, _parameters$data$rich6;
                  _classCallCheck2(this, CircleAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str || (_parameters$data$rich6 = parameters.data.richText) !== null && _parameters$data$rich6 !== void 0 && _parameters$data$rich6.str);
                  return _super13.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                _createClass2(CircleAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = "circleAnnotation";
                    var data = this.data;
                    var _getRectDims4 = getRectDims(data.rect), width = _getRectDims4.width, height = _getRectDims4.height;
                    var svg = this.svgFactory.create(width, height);
                    var borderWidth = data.borderStyle.width;
                    var circle = this.svgFactory.createElement("svg:ellipse");
                    circle.setAttribute("cx", width / 2);
                    circle.setAttribute("cy", height / 2);
                    circle.setAttribute("rx", width / 2 - borderWidth / 2);
                    circle.setAttribute("ry", height / 2 - borderWidth / 2);
                    circle.setAttribute("stroke-width", borderWidth || 1);
                    circle.setAttribute("stroke", "transparent");
                    circle.setAttribute("fill", "transparent");
                    svg.appendChild(circle);
                    this.container.append(svg);
                    this._createPopup(circle, data);
                    return this.container;
                  }
                }]);
                return CircleAnnotationElement2;
              }(AnnotationElement);
              var PolylineAnnotationElement = /* @__PURE__ */ function(_AnnotationElement9) {
                _inherits(PolylineAnnotationElement2, _AnnotationElement9);
                var _super14 = _createSuper(PolylineAnnotationElement2);
                function PolylineAnnotationElement2(parameters) {
                  var _parameters$data$titl7, _parameters$data$cont7, _parameters$data$rich7;
                  var _this112;
                  _classCallCheck2(this, PolylineAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str || (_parameters$data$rich7 = parameters.data.richText) !== null && _parameters$data$rich7 !== void 0 && _parameters$data$rich7.str);
                  _this112 = _super14.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  _this112.containerClassName = "polylineAnnotation";
                  _this112.svgElementName = "svg:polyline";
                  return _this112;
                }
                _createClass2(PolylineAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = this.containerClassName;
                    var data = this.data;
                    var _getRectDims5 = getRectDims(data.rect), width = _getRectDims5.width, height = _getRectDims5.height;
                    var svg = this.svgFactory.create(width, height);
                    var points = [];
                    var _iterator19 = _createForOfIteratorHelper2(data.vertices), _step19;
                    try {
                      for (_iterator19.s(); !(_step19 = _iterator19.n()).done; ) {
                        var coordinate = _step19.value;
                        var x = coordinate.x - data.rect[0];
                        var y = data.rect[3] - coordinate.y;
                        points.push(x + "," + y);
                      }
                    } catch (err) {
                      _iterator19.e(err);
                    } finally {
                      _iterator19.f();
                    }
                    points = points.join(" ");
                    var polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    svg.appendChild(polyline);
                    this.container.append(svg);
                    this._createPopup(polyline, data);
                    return this.container;
                  }
                }]);
                return PolylineAnnotationElement2;
              }(AnnotationElement);
              var PolygonAnnotationElement = /* @__PURE__ */ function(_PolylineAnnotationEl) {
                _inherits(PolygonAnnotationElement2, _PolylineAnnotationEl);
                var _super15 = _createSuper(PolygonAnnotationElement2);
                function PolygonAnnotationElement2(parameters) {
                  var _this12;
                  _classCallCheck2(this, PolygonAnnotationElement2);
                  _this12 = _super15.call(this, parameters);
                  _this12.containerClassName = "polygonAnnotation";
                  _this12.svgElementName = "svg:polygon";
                  return _this12;
                }
                return _createClass2(PolygonAnnotationElement2);
              }(PolylineAnnotationElement);
              var CaretAnnotationElement = /* @__PURE__ */ function(_AnnotationElement10) {
                _inherits(CaretAnnotationElement2, _AnnotationElement10);
                var _super16 = _createSuper(CaretAnnotationElement2);
                function CaretAnnotationElement2(parameters) {
                  var _parameters$data$titl8, _parameters$data$cont8, _parameters$data$rich8;
                  _classCallCheck2(this, CaretAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str || (_parameters$data$rich8 = parameters.data.richText) !== null && _parameters$data$rich8 !== void 0 && _parameters$data$rich8.str);
                  return _super16.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                _createClass2(CaretAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = "caretAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    return this.container;
                  }
                }]);
                return CaretAnnotationElement2;
              }(AnnotationElement);
              var InkAnnotationElement = /* @__PURE__ */ function(_AnnotationElement11) {
                _inherits(InkAnnotationElement2, _AnnotationElement11);
                var _super17 = _createSuper(InkAnnotationElement2);
                function InkAnnotationElement2(parameters) {
                  var _parameters$data$titl9, _parameters$data$cont9, _parameters$data$rich9;
                  var _this13;
                  _classCallCheck2(this, InkAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str || (_parameters$data$rich9 = parameters.data.richText) !== null && _parameters$data$rich9 !== void 0 && _parameters$data$rich9.str);
                  _this13 = _super17.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  _this13.containerClassName = "inkAnnotation";
                  _this13.svgElementName = "svg:polyline";
                  return _this13;
                }
                _createClass2(InkAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = this.containerClassName;
                    var data = this.data;
                    var _getRectDims6 = getRectDims(data.rect), width = _getRectDims6.width, height = _getRectDims6.height;
                    var svg = this.svgFactory.create(width, height);
                    var _iterator20 = _createForOfIteratorHelper2(data.inkLists), _step20;
                    try {
                      for (_iterator20.s(); !(_step20 = _iterator20.n()).done; ) {
                        var inkList = _step20.value;
                        var points = [];
                        var _iterator21 = _createForOfIteratorHelper2(inkList), _step21;
                        try {
                          for (_iterator21.s(); !(_step21 = _iterator21.n()).done; ) {
                            var coordinate = _step21.value;
                            var x = coordinate.x - data.rect[0];
                            var y = data.rect[3] - coordinate.y;
                            points.push("".concat(x, ",").concat(y));
                          }
                        } catch (err) {
                          _iterator21.e(err);
                        } finally {
                          _iterator21.f();
                        }
                        points = points.join(" ");
                        var polyline = this.svgFactory.createElement(this.svgElementName);
                        polyline.setAttribute("points", points);
                        polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                        polyline.setAttribute("stroke", "transparent");
                        polyline.setAttribute("fill", "transparent");
                        this._createPopup(polyline, data);
                        svg.appendChild(polyline);
                      }
                    } catch (err) {
                      _iterator20.e(err);
                    } finally {
                      _iterator20.f();
                    }
                    this.container.append(svg);
                    return this.container;
                  }
                }]);
                return InkAnnotationElement2;
              }(AnnotationElement);
              var HighlightAnnotationElement = /* @__PURE__ */ function(_AnnotationElement12) {
                _inherits(HighlightAnnotationElement2, _AnnotationElement12);
                var _super18 = _createSuper(HighlightAnnotationElement2);
                function HighlightAnnotationElement2(parameters) {
                  var _parameters$data$titl10, _parameters$data$cont10, _parameters$data$rich10;
                  _classCallCheck2(this, HighlightAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str || (_parameters$data$rich10 = parameters.data.richText) !== null && _parameters$data$rich10 !== void 0 && _parameters$data$rich10.str);
                  return _super18.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                _createClass2(HighlightAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("highlightAnnotation");
                    }
                    this.container.className = "highlightAnnotation";
                    return this.container;
                  }
                }]);
                return HighlightAnnotationElement2;
              }(AnnotationElement);
              var UnderlineAnnotationElement = /* @__PURE__ */ function(_AnnotationElement13) {
                _inherits(UnderlineAnnotationElement2, _AnnotationElement13);
                var _super19 = _createSuper(UnderlineAnnotationElement2);
                function UnderlineAnnotationElement2(parameters) {
                  var _parameters$data$titl11, _parameters$data$cont11, _parameters$data$rich11;
                  _classCallCheck2(this, UnderlineAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str || (_parameters$data$rich11 = parameters.data.richText) !== null && _parameters$data$rich11 !== void 0 && _parameters$data$rich11.str);
                  return _super19.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                _createClass2(UnderlineAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("underlineAnnotation");
                    }
                    this.container.className = "underlineAnnotation";
                    return this.container;
                  }
                }]);
                return UnderlineAnnotationElement2;
              }(AnnotationElement);
              var SquigglyAnnotationElement = /* @__PURE__ */ function(_AnnotationElement14) {
                _inherits(SquigglyAnnotationElement2, _AnnotationElement14);
                var _super20 = _createSuper(SquigglyAnnotationElement2);
                function SquigglyAnnotationElement2(parameters) {
                  var _parameters$data$titl12, _parameters$data$cont12, _parameters$data$rich12;
                  _classCallCheck2(this, SquigglyAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str || (_parameters$data$rich12 = parameters.data.richText) !== null && _parameters$data$rich12 !== void 0 && _parameters$data$rich12.str);
                  return _super20.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                _createClass2(SquigglyAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("squigglyAnnotation");
                    }
                    this.container.className = "squigglyAnnotation";
                    return this.container;
                  }
                }]);
                return SquigglyAnnotationElement2;
              }(AnnotationElement);
              var StrikeOutAnnotationElement = /* @__PURE__ */ function(_AnnotationElement15) {
                _inherits(StrikeOutAnnotationElement2, _AnnotationElement15);
                var _super21 = _createSuper(StrikeOutAnnotationElement2);
                function StrikeOutAnnotationElement2(parameters) {
                  var _parameters$data$titl13, _parameters$data$cont13, _parameters$data$rich13;
                  _classCallCheck2(this, StrikeOutAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str || (_parameters$data$rich13 = parameters.data.richText) !== null && _parameters$data$rich13 !== void 0 && _parameters$data$rich13.str);
                  return _super21.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                _createClass2(StrikeOutAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("strikeoutAnnotation");
                    }
                    this.container.className = "strikeoutAnnotation";
                    return this.container;
                  }
                }]);
                return StrikeOutAnnotationElement2;
              }(AnnotationElement);
              var StampAnnotationElement = /* @__PURE__ */ function(_AnnotationElement16) {
                _inherits(StampAnnotationElement2, _AnnotationElement16);
                var _super22 = _createSuper(StampAnnotationElement2);
                function StampAnnotationElement2(parameters) {
                  var _parameters$data$titl14, _parameters$data$cont14, _parameters$data$rich14;
                  _classCallCheck2(this, StampAnnotationElement2);
                  var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl14 = parameters.data.titleObj) !== null && _parameters$data$titl14 !== void 0 && _parameters$data$titl14.str || (_parameters$data$cont14 = parameters.data.contentsObj) !== null && _parameters$data$cont14 !== void 0 && _parameters$data$cont14.str || (_parameters$data$rich14 = parameters.data.richText) !== null && _parameters$data$rich14 !== void 0 && _parameters$data$rich14.str);
                  return _super22.call(this, parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                _createClass2(StampAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    this.container.className = "stampAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    return this.container;
                  }
                }]);
                return StampAnnotationElement2;
              }(AnnotationElement);
              var FileAttachmentAnnotationElement = /* @__PURE__ */ function(_AnnotationElement17) {
                _inherits(FileAttachmentAnnotationElement2, _AnnotationElement17);
                var _super23 = _createSuper(FileAttachmentAnnotationElement2);
                function FileAttachmentAnnotationElement2(parameters) {
                  var _this14$linkService$e;
                  var _this14;
                  _classCallCheck2(this, FileAttachmentAnnotationElement2);
                  _this14 = _super23.call(this, parameters, {
                    isRenderable: true
                  });
                  var _this14$data$file = _this14.data.file, filename = _this14$data$file.filename, content = _this14$data$file.content;
                  _this14.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                  _this14.content = content;
                  (_this14$linkService$e = _this14.linkService.eventBus) === null || _this14$linkService$e === void 0 ? void 0 : _this14$linkService$e.dispatch("fileattachmentannotation", {
                    source: _assertThisInitialized(_this14),
                    filename,
                    content
                  });
                  return _this14;
                }
                _createClass2(FileAttachmentAnnotationElement2, [{
                  key: "render",
                  value: function render() {
                    var _this$data$titleObj, _this$data$contentsOb;
                    this.container.className = "fileAttachmentAnnotation";
                    var trigger = document.createElement("div");
                    trigger.style.height = this.container.style.height;
                    trigger.style.width = this.container.style.width;
                    trigger.addEventListener("dblclick", this._download.bind(this));
                    if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str || this.data.richText)) {
                      this._createPopup(trigger, this.data);
                    }
                    this.container.appendChild(trigger);
                    return this.container;
                  }
                }, {
                  key: "_download",
                  value: function _download() {
                    var _this$downloadManager;
                    (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
                  }
                }]);
                return FileAttachmentAnnotationElement2;
              }(AnnotationElement);
              var AnnotationLayer = /* @__PURE__ */ function() {
                function AnnotationLayer2() {
                  _classCallCheck2(this, AnnotationLayer2);
                }
                _createClass2(AnnotationLayer2, null, [{
                  key: "render",
                  value: function render(parameters) {
                    var sortedAnnotations = [], popupAnnotations = [];
                    var _iterator22 = _createForOfIteratorHelper2(parameters.annotations), _step22;
                    try {
                      for (_iterator22.s(); !(_step22 = _iterator22.n()).done; ) {
                        var _data = _step22.value;
                        if (!_data) {
                          continue;
                        }
                        var _getRectDims7 = getRectDims(_data.rect), width = _getRectDims7.width, height = _getRectDims7.height;
                        if (width <= 0 || height <= 0) {
                          continue;
                        }
                        if (_data.annotationType === _util2.AnnotationType.POPUP) {
                          popupAnnotations.push(_data);
                          continue;
                        }
                        sortedAnnotations.push(_data);
                      }
                    } catch (err) {
                      _iterator22.e(err);
                    } finally {
                      _iterator22.f();
                    }
                    if (popupAnnotations.length) {
                      sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);
                    }
                    var div = parameters.div;
                    for (var _i8 = 0, _sortedAnnotations = sortedAnnotations; _i8 < _sortedAnnotations.length; _i8++) {
                      var data = _sortedAnnotations[_i8];
                      var element = AnnotationElementFactory.create({
                        data,
                        layer: div,
                        page: parameters.page,
                        viewport: parameters.viewport,
                        linkService: parameters.linkService,
                        downloadManager: parameters.downloadManager,
                        imageResourcesPath: parameters.imageResourcesPath || "",
                        renderForms: parameters.renderForms !== false,
                        svgFactory: new _display_utils2.DOMSVGFactory(),
                        annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                        enableScripting: parameters.enableScripting,
                        hasJSActions: parameters.hasJSActions,
                        fieldObjects: parameters.fieldObjects,
                        mouseState: parameters.mouseState || {
                          isDown: false
                        }
                      });
                      if (element.isRenderable) {
                        var rendered = element.render();
                        if (data.hidden) {
                          rendered.style.visibility = "hidden";
                        }
                        if (Array.isArray(rendered)) {
                          var _iterator23 = _createForOfIteratorHelper2(rendered), _step23;
                          try {
                            for (_iterator23.s(); !(_step23 = _iterator23.n()).done; ) {
                              var renderedElement = _step23.value;
                              div.appendChild(renderedElement);
                            }
                          } catch (err) {
                            _iterator23.e(err);
                          } finally {
                            _iterator23.f();
                          }
                        } else {
                          if (element instanceof PopupAnnotationElement) {
                            div.prepend(rendered);
                          } else {
                            div.appendChild(rendered);
                          }
                        }
                      }
                    }
                    _classStaticPrivateMethodGet(this, AnnotationLayer2, _setAnnotationCanvasMap).call(this, div, parameters.annotationCanvasMap);
                  }
                }, {
                  key: "update",
                  value: function update(parameters) {
                    var page = parameters.page, viewport = parameters.viewport, annotations = parameters.annotations, annotationCanvasMap = parameters.annotationCanvasMap, div = parameters.div;
                    var transform = viewport.transform;
                    var matrix = "matrix(".concat(transform.join(","), ")");
                    var scale, ownMatrix;
                    var _iterator24 = _createForOfIteratorHelper2(annotations), _step24;
                    try {
                      for (_iterator24.s(); !(_step24 = _iterator24.n()).done; ) {
                        var data = _step24.value;
                        var elements = div.querySelectorAll('[data-annotation-id="'.concat(data.id, '"]'));
                        if (elements) {
                          var _iterator25 = _createForOfIteratorHelper2(elements), _step25;
                          try {
                            for (_iterator25.s(); !(_step25 = _iterator25.n()).done; ) {
                              var element = _step25.value;
                              if (data.hasOwnCanvas) {
                                var rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                                if (!ownMatrix) {
                                  scale = Math.abs(transform[0] || transform[1]);
                                  var ownTransform = transform.slice();
                                  for (var i = 0; i < 4; i++) {
                                    ownTransform[i] = Math.sign(ownTransform[i]);
                                  }
                                  ownMatrix = "matrix(".concat(ownTransform.join(","), ")");
                                }
                                var left = rect[0] * scale;
                                var top = rect[1] * scale;
                                element.style.left = "".concat(left, "px");
                                element.style.top = "".concat(top, "px");
                                element.style.transformOrigin = "".concat(-left, "px ").concat(-top, "px");
                                element.style.transform = ownMatrix;
                              } else {
                                element.style.transform = matrix;
                              }
                            }
                          } catch (err) {
                            _iterator25.e(err);
                          } finally {
                            _iterator25.f();
                          }
                        }
                      }
                    } catch (err) {
                      _iterator24.e(err);
                    } finally {
                      _iterator24.f();
                    }
                    _classStaticPrivateMethodGet(this, AnnotationLayer2, _setAnnotationCanvasMap).call(this, div, annotationCanvasMap);
                    div.hidden = false;
                  }
                }]);
                return AnnotationLayer2;
              }();
              exports2.AnnotationLayer = AnnotationLayer;
              function _setAnnotationCanvasMap(div, annotationCanvasMap) {
                if (!annotationCanvasMap) {
                  return;
                }
                var _iterator26 = _createForOfIteratorHelper2(annotationCanvasMap), _step26;
                try {
                  for (_iterator26.s(); !(_step26 = _iterator26.n()).done; ) {
                    var _step26$value = _slicedToArray2(_step26.value, 2), id = _step26$value[0], canvas = _step26$value[1];
                    var element = div.querySelector('[data-annotation-id="'.concat(id, '"]'));
                    if (!element) {
                      continue;
                    }
                    var firstChild = element.firstChild;
                    if (firstChild.nodeName === "CANVAS") {
                      element.replaceChild(canvas, firstChild);
                    } else {
                      element.insertBefore(canvas, firstChild);
                    }
                  }
                } catch (err) {
                  _iterator26.e(err);
                } finally {
                  _iterator26.f();
                }
                annotationCanvasMap.clear();
              }
            },
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorConverters = void 0;
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function makeColorComp(n) {
                return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
              }
              var ColorConverters = /* @__PURE__ */ function() {
                function ColorConverters2() {
                  _classCallCheck2(this, ColorConverters2);
                }
                _createClass2(ColorConverters2, null, [{
                  key: "CMYK_G",
                  value: function CMYK_G(_ref) {
                    var _ref2 = _slicedToArray2(_ref, 4), c = _ref2[0], y = _ref2[1], m = _ref2[2], k = _ref2[3];
                    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                  }
                }, {
                  key: "G_CMYK",
                  value: function G_CMYK(_ref3) {
                    var _ref4 = _slicedToArray2(_ref3, 1), g = _ref4[0];
                    return ["CMYK", 0, 0, 0, 1 - g];
                  }
                }, {
                  key: "G_RGB",
                  value: function G_RGB(_ref5) {
                    var _ref6 = _slicedToArray2(_ref5, 1), g = _ref6[0];
                    return ["RGB", g, g, g];
                  }
                }, {
                  key: "G_HTML",
                  value: function G_HTML(_ref7) {
                    var _ref8 = _slicedToArray2(_ref7, 1), g = _ref8[0];
                    var G = makeColorComp(g);
                    return "#".concat(G).concat(G).concat(G);
                  }
                }, {
                  key: "RGB_G",
                  value: function RGB_G(_ref9) {
                    var _ref10 = _slicedToArray2(_ref9, 3), r = _ref10[0], g = _ref10[1], b = _ref10[2];
                    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
                  }
                }, {
                  key: "RGB_HTML",
                  value: function RGB_HTML(_ref11) {
                    var _ref12 = _slicedToArray2(_ref11, 3), r = _ref12[0], g = _ref12[1], b = _ref12[2];
                    var R = makeColorComp(r);
                    var G = makeColorComp(g);
                    var B = makeColorComp(b);
                    return "#".concat(R).concat(G).concat(B);
                  }
                }, {
                  key: "T_HTML",
                  value: function T_HTML() {
                    return "#00000000";
                  }
                }, {
                  key: "CMYK_RGB",
                  value: function CMYK_RGB(_ref13) {
                    var _ref14 = _slicedToArray2(_ref13, 4), c = _ref14[0], y = _ref14[1], m = _ref14[2], k = _ref14[3];
                    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                  }
                }, {
                  key: "CMYK_HTML",
                  value: function CMYK_HTML(components) {
                    return this.RGB_HTML(this.CMYK_RGB(components));
                  }
                }, {
                  key: "RGB_CMYK",
                  value: function RGB_CMYK(_ref152) {
                    var _ref16 = _slicedToArray2(_ref152, 3), r = _ref16[0], g = _ref16[1], b = _ref16[2];
                    var c = 1 - r;
                    var m = 1 - g;
                    var y = 1 - b;
                    var k = Math.min(c, m, y);
                    return ["CMYK", c, m, y, k];
                  }
                }]);
                return ColorConverters2;
              }();
              exports2.ColorConverters = ColorConverters;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayer = void 0;
              var _xfa_text2 = __w_pdfjs_require__2(171);
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e2) {
                      throw _e2;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e3) {
                  didErr = true;
                  err = _e3;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              var XfaLayer = /* @__PURE__ */ function() {
                function XfaLayer2() {
                  _classCallCheck2(this, XfaLayer2);
                }
                _createClass2(XfaLayer2, null, [{
                  key: "setupStorage",
                  value: function setupStorage(html, id, element, storage, intent) {
                    var storedData = storage.getValue(id, {
                      value: null
                    });
                    switch (element.name) {
                      case "textarea":
                        if (storedData.value !== null) {
                          html.textContent = storedData.value;
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", function(event) {
                          storage.setValue(id, {
                            value: event.target.value
                          });
                        });
                        break;
                      case "input":
                        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                          if (storedData.value === element.attributes.xfaOn) {
                            html.setAttribute("checked", true);
                          } else if (storedData.value === element.attributes.xfaOff) {
                            html.removeAttribute("checked");
                          }
                          if (intent === "print") {
                            break;
                          }
                          html.addEventListener("change", function(event) {
                            storage.setValue(id, {
                              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                            });
                          });
                        } else {
                          if (storedData.value !== null) {
                            html.setAttribute("value", storedData.value);
                          }
                          if (intent === "print") {
                            break;
                          }
                          html.addEventListener("input", function(event) {
                            storage.setValue(id, {
                              value: event.target.value
                            });
                          });
                        }
                        break;
                      case "select":
                        if (storedData.value !== null) {
                          var _iterator = _createForOfIteratorHelper2(element.children), _step;
                          try {
                            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                              var option = _step.value;
                              if (option.attributes.value === storedData.value) {
                                option.attributes.selected = true;
                              }
                            }
                          } catch (err) {
                            _iterator.e(err);
                          } finally {
                            _iterator.f();
                          }
                        }
                        html.addEventListener("input", function(event) {
                          var options = event.target.options;
                          var value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                          storage.setValue(id, {
                            value
                          });
                        });
                        break;
                    }
                  }
                }, {
                  key: "setAttributes",
                  value: function setAttributes(_ref) {
                    var html = _ref.html, element = _ref.element, _ref$storage = _ref.storage, storage = _ref$storage === void 0 ? null : _ref$storage, intent = _ref.intent, linkService = _ref.linkService;
                    var attributes = element.attributes;
                    var isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                    if (attributes.type === "radio") {
                      attributes.name = "".concat(attributes.name, "-").concat(intent);
                    }
                    for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {
                      var _Object$entries$_i = _slicedToArray2(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
                      if (value === null || value === void 0 || key === "dataId") {
                        continue;
                      }
                      if (key !== "style") {
                        if (key === "textContent") {
                          html.textContent = value;
                        } else if (key === "class") {
                          if (value.length) {
                            html.setAttribute(key, value.join(" "));
                          }
                        } else {
                          if (isHTMLAnchorElement && (key === "href" || key === "newWindow")) {
                            continue;
                          }
                          html.setAttribute(key, value);
                        }
                      } else {
                        Object.assign(html.style, value);
                      }
                    }
                    if (isHTMLAnchorElement) {
                      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                    }
                    if (storage && attributes.dataId) {
                      this.setupStorage(html, attributes.dataId, element, storage);
                    }
                  }
                }, {
                  key: "render",
                  value: function render(parameters) {
                    var storage = parameters.annotationStorage;
                    var linkService = parameters.linkService;
                    var root = parameters.xfaHtml;
                    var intent = parameters.intent || "display";
                    var rootHtml = document.createElement(root.name);
                    if (root.attributes) {
                      this.setAttributes({
                        html: rootHtml,
                        element: root,
                        intent,
                        linkService
                      });
                    }
                    var stack = [[root, -1, rootHtml]];
                    var rootDiv = parameters.div;
                    rootDiv.appendChild(rootHtml);
                    if (parameters.viewport) {
                      var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
                      rootDiv.style.transform = transform;
                    }
                    if (intent !== "richText") {
                      rootDiv.setAttribute("class", "xfaLayer xfaFont");
                    }
                    var textDivs = [];
                    while (stack.length > 0) {
                      var _child$attributes;
                      var _stack = _slicedToArray2(stack[stack.length - 1], 3), parent = _stack[0], i = _stack[1], html = _stack[2];
                      if (i + 1 === parent.children.length) {
                        stack.pop();
                        continue;
                      }
                      var child = parent.children[++stack[stack.length - 1][1]];
                      if (child === null) {
                        continue;
                      }
                      var name = child.name;
                      if (name === "#text") {
                        var node = document.createTextNode(child.value);
                        textDivs.push(node);
                        html.appendChild(node);
                        continue;
                      }
                      var childHtml = void 0;
                      if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {
                        childHtml = document.createElementNS(child.attributes.xmlns, name);
                      } else {
                        childHtml = document.createElement(name);
                      }
                      html.appendChild(childHtml);
                      if (child.attributes) {
                        this.setAttributes({
                          html: childHtml,
                          element: child,
                          storage,
                          intent,
                          linkService
                        });
                      }
                      if (child.children && child.children.length > 0) {
                        stack.push([child, -1, childHtml]);
                      } else if (child.value) {
                        var _node = document.createTextNode(child.value);
                        if (_xfa_text2.XfaText.shouldBuildText(name)) {
                          textDivs.push(_node);
                        }
                        childHtml.appendChild(_node);
                      }
                    }
                    var _iterator2 = _createForOfIteratorHelper2(rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var el = _step2.value;
                        el.setAttribute("readOnly", true);
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    return {
                      textDivs
                    };
                  }
                }, {
                  key: "update",
                  value: function update(parameters) {
                    var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
                    parameters.div.style.transform = transform;
                    parameters.div.hidden = false;
                  }
                }]);
                return XfaLayer2;
              }();
              exports2.XfaLayer = XfaLayer;
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.renderTextLayer = renderTextLayer;
              var _util2 = __w_pdfjs_require__2(1);
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              var MAX_TEXT_DIVS_TO_RENDER = 1e5;
              var DEFAULT_FONT_SIZE = 30;
              var DEFAULT_FONT_ASCENT = 0.8;
              var ascentCache = /* @__PURE__ */ new Map();
              var AllWhitespaceRegexp = /^\s+$/g;
              function getAscent(fontFamily, ctx) {
                var cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                ctx.save();
                ctx.font = "".concat(DEFAULT_FONT_SIZE, "px ").concat(fontFamily);
                var metrics = ctx.measureText("");
                var ascent = metrics.fontBoundingBoxAscent;
                var descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  ctx.restore();
                  var ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                var pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (var i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (var _i = 0, ii = pixels.length; _i < ii; _i += 4) {
                  if (pixels[_i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(_i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.restore();
                if (ascent) {
                  var _ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, _ratio);
                  return _ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles, ctx) {
                var textDiv = document.createElement("span");
                var textDivProperties = task._enhanceTextSelection ? {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1
                } : {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL
                };
                task._textDivs.push(textDiv);
                var tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                var angle = Math.atan2(tx[1], tx[0]);
                var style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                var fontHeight = Math.hypot(tx[2], tx[3]);
                var fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                var left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                textDiv.style.left = "".concat(left, "px");
                textDiv.style.top = "".concat(top, "px");
                textDiv.style.fontSize = "".concat(fontHeight, "px");
                textDiv.style.fontFamily = style.fontFamily;
                textDiv.setAttribute("role", "presentation");
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                var shouldScaleText = false;
                if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
                  shouldScaleText = true;
                } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                  var absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection && textDivProperties.hasText) {
                  var angleCos = 1, angleSin = 0;
                  if (angle !== 0) {
                    angleCos = Math.cos(angle);
                    angleSin = Math.sin(angle);
                  }
                  var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  var divHeight = fontHeight;
                  var m, b;
                  if (angle !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                var textDivs = task._textDivs;
                var capability = task._capability;
                var textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (var i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function findPositiveMin(ts, offset, count) {
                var result = 0;
                for (var i = 0; i < count; i++) {
                  var t = ts[offset++];
                  if (t > 0) {
                    result = result ? Math.min(t, result) : t;
                  }
                }
                return result;
              }
              function expand(task) {
                var bounds = task._bounds;
                var viewport = task._viewport;
                var expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (var i = 0; i < expanded.length; i++) {
                  var div = bounds[i].div;
                  var divProperties = task._textDivProperties.get(div);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div, divProperties);
                    continue;
                  }
                  var e = expanded[i], b = bounds[i];
                  var m = b.m, c = m[0], s = m[1];
                  var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  var ts = new Float64Array(64);
                  for (var j = 0, jj = points.length; j < jj; j++) {
                    var t = _util2.Util.applyTransform(points[j], m);
                    ts[j + 0] = c && (e.left - t[0]) / c;
                    ts[j + 4] = s && (e.top - t[1]) / s;
                    ts[j + 8] = c && (e.right - t[0]) / c;
                    ts[j + 12] = s && (e.bottom - t[1]) / s;
                    ts[j + 16] = s && (e.left - t[0]) / -s;
                    ts[j + 20] = c && (e.top - t[1]) / c;
                    ts[j + 24] = s && (e.right - t[0]) / -s;
                    ts[j + 28] = c && (e.bottom - t[1]) / c;
                    ts[j + 32] = c && (e.left - t[0]) / -c;
                    ts[j + 36] = s && (e.top - t[1]) / -s;
                    ts[j + 40] = c && (e.right - t[0]) / -c;
                    ts[j + 44] = s && (e.bottom - t[1]) / -s;
                    ts[j + 48] = s && (e.left - t[0]) / s;
                    ts[j + 52] = c && (e.top - t[1]) / -c;
                    ts[j + 56] = s && (e.right - t[0]) / s;
                    ts[j + 60] = c && (e.bottom - t[1]) / -c;
                  }
                  var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div, divProperties);
                }
              }
              function expandBounds(width, height, boxes) {
                var bounds = boxes.map(function(box, i2) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i2,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                var expanded = new Array(boxes.length);
                var _iterator = _createForOfIteratorHelper2(bounds), _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var b = _step.value;
                    var i = b.index;
                    expanded[i] = {
                      left: b.x1New,
                      top: 0,
                      right: b.x2New,
                      bottom: 0
                    };
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                boxes.map(function(box, i2) {
                  var e = expanded[i2], b2 = bounds[i2];
                  b2.x1 = box.top;
                  b2.y1 = width - e.right;
                  b2.x2 = box.bottom;
                  b2.y2 = width - e.left;
                  b2.index = i2;
                  b2.x1New = void 0;
                  b2.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                var _iterator2 = _createForOfIteratorHelper2(bounds), _step2;
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                    var _b = _step2.value;
                    var _i2 = _b.index;
                    expanded[_i2].top = _b.x1New;
                    expanded[_i2].bottom = _b.x2New;
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                var fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                var horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                var _iterator3 = _createForOfIteratorHelper2(bounds), _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                    var boundary = _step3.value;
                    var i = 0;
                    while (i < horizon.length && horizon[i].end <= boundary.y1) {
                      i++;
                    }
                    var j = horizon.length - 1;
                    while (j >= 0 && horizon[j].start >= boundary.y2) {
                      j--;
                    }
                    var _horizonPart = void 0, _affectedBoundary = void 0;
                    var q = void 0, k = void 0, maxXNew = -Infinity;
                    for (q = i; q <= j; q++) {
                      _horizonPart = horizon[q];
                      _affectedBoundary = _horizonPart.boundary;
                      var xNew = void 0;
                      if (_affectedBoundary.x2 > boundary.x1) {
                        xNew = _affectedBoundary.index > boundary.index ? _affectedBoundary.x1New : boundary.x1;
                      } else if (_affectedBoundary.x2New === void 0) {
                        xNew = (_affectedBoundary.x2 + boundary.x1) / 2;
                      } else {
                        xNew = _affectedBoundary.x2New;
                      }
                      if (xNew > maxXNew) {
                        maxXNew = xNew;
                      }
                    }
                    boundary.x1New = maxXNew;
                    for (q = i; q <= j; q++) {
                      _horizonPart = horizon[q];
                      _affectedBoundary = _horizonPart.boundary;
                      if (_affectedBoundary.x2New === void 0) {
                        if (_affectedBoundary.x2 > boundary.x1) {
                          if (_affectedBoundary.index > boundary.index) {
                            _affectedBoundary.x2New = _affectedBoundary.x2;
                          }
                        } else {
                          _affectedBoundary.x2New = maxXNew;
                        }
                      } else if (_affectedBoundary.x2New > maxXNew) {
                        _affectedBoundary.x2New = Math.max(maxXNew, _affectedBoundary.x2);
                      }
                    }
                    var changedHorizon = [];
                    var lastBoundary = null;
                    for (q = i; q <= j; q++) {
                      _horizonPart = horizon[q];
                      _affectedBoundary = _horizonPart.boundary;
                      var useBoundary = _affectedBoundary.x2 > boundary.x2 ? _affectedBoundary : boundary;
                      if (lastBoundary === useBoundary) {
                        changedHorizon[changedHorizon.length - 1].end = _horizonPart.end;
                      } else {
                        changedHorizon.push({
                          start: _horizonPart.start,
                          end: _horizonPart.end,
                          boundary: useBoundary
                        });
                        lastBoundary = useBoundary;
                      }
                    }
                    if (horizon[i].start < boundary.y1) {
                      changedHorizon[0].start = boundary.y1;
                      changedHorizon.unshift({
                        start: horizon[i].start,
                        end: boundary.y1,
                        boundary: horizon[i].boundary
                      });
                    }
                    if (boundary.y2 < horizon[j].end) {
                      changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                      changedHorizon.push({
                        start: boundary.y2,
                        end: horizon[j].end,
                        boundary: horizon[j].boundary
                      });
                    }
                    for (q = i; q <= j; q++) {
                      _horizonPart = horizon[q];
                      _affectedBoundary = _horizonPart.boundary;
                      if (_affectedBoundary.x2New !== void 0) {
                        continue;
                      }
                      var used = false;
                      for (k = i - 1; !used && k >= 0 && horizon[k].start >= _affectedBoundary.y1; k--) {
                        used = horizon[k].boundary === _affectedBoundary;
                      }
                      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= _affectedBoundary.y2; k++) {
                        used = horizon[k].boundary === _affectedBoundary;
                      }
                      for (k = 0; !used && k < changedHorizon.length; k++) {
                        used = changedHorizon[k].boundary === _affectedBoundary;
                      }
                      if (!used) {
                        _affectedBoundary.x2New = maxXNew;
                      }
                    }
                    Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
                for (var _i3 = 0, _horizon = horizon; _i3 < _horizon.length; _i3++) {
                  var horizonPart = _horizon[_i3];
                  var affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                }
              }
              var TextLayerRenderTask = /* @__PURE__ */ function() {
                function TextLayerRenderTask2(_ref) {
                  var _globalThis$FontInspe, _this = this;
                  var textContent = _ref.textContent, textContentStream = _ref.textContentStream, container = _ref.container, viewport = _ref.viewport, textDivs = _ref.textDivs, textContentItemsStr = _ref.textContentItemsStr, enhanceTextSelection = _ref.enhanceTextSelection;
                  _classCallCheck2(this, TextLayerRenderTask2);
                  this._textContent = textContent;
                  this._textContentStream = textContentStream;
                  this._container = container;
                  this._document = container.ownerDocument;
                  this._viewport = viewport;
                  this._textDivs = textDivs || [];
                  this._textContentItemsStr = textContentItemsStr || [];
                  this._enhanceTextSelection = !!enhanceTextSelection;
                  this._fontInspectorEnabled = !!((_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled);
                  this._reader = null;
                  this._layoutTextLastFontSize = null;
                  this._layoutTextLastFontFamily = null;
                  this._layoutTextCtx = null;
                  this._textDivProperties = /* @__PURE__ */ new WeakMap();
                  this._renderingDone = false;
                  this._canceled = false;
                  this._capability = (0, _util2.createPromiseCapability)();
                  this._renderTimer = null;
                  this._bounds = [];
                  this._capability.promise["finally"](function() {
                    if (!_this._enhanceTextSelection) {
                      _this._textDivProperties = null;
                    }
                    if (_this._layoutTextCtx) {
                      _this._layoutTextCtx.canvas.width = 0;
                      _this._layoutTextCtx.canvas.height = 0;
                      _this._layoutTextCtx = null;
                    }
                  })["catch"](function() {
                  });
                }
                _createClass2(TextLayerRenderTask2, [{
                  key: "promise",
                  get: function get2() {
                    return this._capability.promise;
                  }
                }, {
                  key: "cancel",
                  value: function cancel() {
                    this._canceled = true;
                    if (this._reader) {
                      this._reader.cancel(new _util2.AbortException("TextLayer task cancelled."))["catch"](function() {
                      });
                      this._reader = null;
                    }
                    if (this._renderTimer !== null) {
                      clearTimeout(this._renderTimer);
                      this._renderTimer = null;
                    }
                    this._capability.reject(new Error("TextLayer task cancelled."));
                  }
                }, {
                  key: "_processItems",
                  value: function _processItems(items, styleCache) {
                    for (var i = 0, len = items.length; i < len; i++) {
                      if (items[i].str === void 0) {
                        if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                          var parent = this._container;
                          this._container = document.createElement("span");
                          this._container.classList.add("markedContent");
                          if (items[i].id !== null) {
                            this._container.setAttribute("id", "".concat(items[i].id));
                          }
                          parent.appendChild(this._container);
                        } else if (items[i].type === "endMarkedContent") {
                          this._container = this._container.parentNode;
                        }
                        continue;
                      }
                      this._textContentItemsStr.push(items[i].str);
                      appendText(this, items[i], styleCache, this._layoutTextCtx);
                    }
                  }
                }, {
                  key: "_layoutText",
                  value: function _layoutText(textDiv) {
                    var textDivProperties = this._textDivProperties.get(textDiv);
                    var transform = "";
                    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
                      var _textDiv$style = textDiv.style, fontSize = _textDiv$style.fontSize, fontFamily = _textDiv$style.fontFamily;
                      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                        this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily);
                        this._layoutTextLastFontSize = fontSize;
                        this._layoutTextLastFontFamily = fontFamily;
                      }
                      var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent), width = _this$_layoutTextCtx$.width;
                      if (width > 0) {
                        var scale = textDivProperties.canvasWidth / width;
                        if (this._enhanceTextSelection) {
                          textDivProperties.scale = scale;
                        }
                        transform = "scaleX(".concat(scale, ")");
                      }
                    }
                    if (textDivProperties.angle !== 0) {
                      transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
                    }
                    if (transform.length > 0) {
                      if (this._enhanceTextSelection) {
                        textDivProperties.originalTransform = transform;
                      }
                      textDiv.style.transform = transform;
                    }
                    if (textDivProperties.hasText) {
                      this._container.appendChild(textDiv);
                    }
                    if (textDivProperties.hasEOL) {
                      var br = document.createElement("br");
                      br.setAttribute("role", "presentation");
                      this._container.appendChild(br);
                    }
                  }
                }, {
                  key: "_render",
                  value: function _render() {
                    var _this2 = this;
                    var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                    var capability = (0, _util2.createPromiseCapability)();
                    var styleCache = /* @__PURE__ */ Object.create(null);
                    var canvas = this._document.createElement("canvas");
                    canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                    this._layoutTextCtx = canvas.getContext("2d", {
                      alpha: false
                    });
                    if (this._textContent) {
                      var textItems = this._textContent.items;
                      var textStyles = this._textContent.styles;
                      this._processItems(textItems, textStyles);
                      capability.resolve();
                    } else if (this._textContentStream) {
                      var pump = function pump2() {
                        _this2._reader.read().then(function(_ref2) {
                          var value = _ref2.value, done = _ref2.done;
                          if (done) {
                            capability.resolve();
                            return;
                          }
                          Object.assign(styleCache, value.styles);
                          _this2._processItems(value.items, styleCache);
                          pump2();
                        }, capability.reject);
                      };
                      this._reader = this._textContentStream.getReader();
                      pump();
                    } else {
                      throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                    }
                    capability.promise.then(function() {
                      styleCache = null;
                      if (!timeout) {
                        render(_this2);
                      } else {
                        _this2._renderTimer = setTimeout(function() {
                          render(_this2);
                          _this2._renderTimer = null;
                        }, timeout);
                      }
                    }, this._capability.reject);
                  }
                }, {
                  key: "expandTextDivs",
                  value: function expandTextDivs() {
                    var expandDivs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (!this._enhanceTextSelection || !this._renderingDone) {
                      return;
                    }
                    if (this._bounds !== null) {
                      expand(this);
                      this._bounds = null;
                    }
                    var transformBuf = [], paddingBuf = [];
                    for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
                      var div = this._textDivs[i];
                      var divProps = this._textDivProperties.get(div);
                      if (!divProps.hasText) {
                        continue;
                      }
                      if (expandDivs) {
                        transformBuf.length = 0;
                        paddingBuf.length = 0;
                        if (divProps.originalTransform) {
                          transformBuf.push(divProps.originalTransform);
                        }
                        if (divProps.paddingTop > 0) {
                          paddingBuf.push("".concat(divProps.paddingTop, "px"));
                          transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)"));
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingRight > 0) {
                          paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px"));
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingBottom > 0) {
                          paddingBuf.push("".concat(divProps.paddingBottom, "px"));
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingLeft > 0) {
                          paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px"));
                          transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)"));
                        } else {
                          paddingBuf.push(0);
                        }
                        div.style.padding = paddingBuf.join(" ");
                        if (transformBuf.length) {
                          div.style.transform = transformBuf.join(" ");
                        }
                      } else {
                        div.style.padding = null;
                        div.style.transform = divProps.originalTransform;
                      }
                    }
                  }
                }]);
                return TextLayerRenderTask2;
              }();
              function renderTextLayer(renderParameters) {
                var task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SVGGraphics = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(158);
              var _is_node2 = __w_pdfjs_require__2(3);
              function _toConsumableArray2(arr) {
                return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
              }
              function _nonIterableSpread2() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArray2(iter) {
                if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                  return Array.from(iter);
              }
              function _arrayWithoutHoles2(arr) {
                if (Array.isArray(arr))
                  return _arrayLikeToArray2(arr);
              }
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e2) {
                      throw _e2;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e3) {
                  didErr = true;
                  err = _e3;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var SVGGraphics = /* @__PURE__ */ _createClass2(function SVGGraphics2() {
                _classCallCheck2(this, SVGGraphics2);
                (0, _util2.unreachable)("Not implemented: SVGGraphics");
              });
              exports2.SVGGraphics = SVGGraphics;
              {
                var opListToTree = function opListToTree2(opList) {
                  var opTree = [];
                  var tmp = [];
                  var _iterator = _createForOfIteratorHelper2(opList), _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var opListElement = _step.value;
                      if (opListElement.fn === "save") {
                        opTree.push({
                          fnId: 92,
                          fn: "group",
                          items: []
                        });
                        tmp.push(opTree);
                        opTree = opTree[opTree.length - 1].items;
                        continue;
                      }
                      if (opListElement.fn === "restore") {
                        opTree = tmp.pop();
                      } else {
                        opTree.push(opListElement);
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  return opTree;
                };
                var pf = function pf2(value) {
                  if (Number.isInteger(value)) {
                    return value.toString();
                  }
                  var s = value.toFixed(10);
                  var i = s.length - 1;
                  if (s[i] !== "0") {
                    return s;
                  }
                  do {
                    i--;
                  } while (s[i] === "0");
                  return s.substring(0, s[i] === "." ? i : i + 1);
                };
                var pm = function pm2(m) {
                  if (m[4] === 0 && m[5] === 0) {
                    if (m[1] === 0 && m[2] === 0) {
                      if (m[0] === 1 && m[3] === 1) {
                        return "";
                      }
                      return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
                    }
                    if (m[0] === m[3] && m[1] === -m[2]) {
                      var a = Math.acos(m[0]) * 180 / Math.PI;
                      return "rotate(".concat(pf(a), ")");
                    }
                  } else {
                    if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                      return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
                    }
                  }
                  return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
                };
                var SVG_DEFAULTS = {
                  fontStyle: "normal",
                  fontWeight: "normal",
                  fillColor: "#000000"
                };
                var XML_NS = "http://www.w3.org/XML/1998/namespace";
                var XLINK_NS = "http://www.w3.org/1999/xlink";
                var LINE_CAP_STYLES = ["butt", "round", "square"];
                var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                var createObjectURL = function createObjectURL2(data) {
                  var contentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                  var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                    return URL.createObjectURL(new Blob([data], {
                      type: contentType
                    }));
                  }
                  var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  var buffer = "data:".concat(contentType, ";base64,");
                  for (var i = 0, ii = data.length; i < ii; i += 3) {
                    var b1 = data[i] & 255;
                    var b2 = data[i + 1] & 255;
                    var b3 = data[i + 2] & 255;
                    var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                    var d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                    var d4 = i + 2 < ii ? b3 & 63 : 64;
                    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                  }
                  return buffer;
                };
                var convertImgDataToPng = function() {
                  var PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                  var CHUNK_WRAPPER_SIZE = 12;
                  var crcTable = new Int32Array(256);
                  for (var i = 0; i < 256; i++) {
                    var c = i;
                    for (var h = 0; h < 8; h++) {
                      if (c & 1) {
                        c = 3988292384 ^ c >> 1 & 2147483647;
                      } else {
                        c = c >> 1 & 2147483647;
                      }
                    }
                    crcTable[i] = c;
                  }
                  function crc32(data, start, end) {
                    var crc = -1;
                    for (var _i = start; _i < end; _i++) {
                      var a = (crc ^ data[_i]) & 255;
                      var b = crcTable[a];
                      crc = crc >>> 8 ^ b;
                    }
                    return crc ^ -1;
                  }
                  function writePngChunk(type, body, data, offset) {
                    var p = offset;
                    var len = body.length;
                    data[p] = len >> 24 & 255;
                    data[p + 1] = len >> 16 & 255;
                    data[p + 2] = len >> 8 & 255;
                    data[p + 3] = len & 255;
                    p += 4;
                    data[p] = type.charCodeAt(0) & 255;
                    data[p + 1] = type.charCodeAt(1) & 255;
                    data[p + 2] = type.charCodeAt(2) & 255;
                    data[p + 3] = type.charCodeAt(3) & 255;
                    p += 4;
                    data.set(body, p);
                    p += body.length;
                    var crc = crc32(data, offset + 4, p);
                    data[p] = crc >> 24 & 255;
                    data[p + 1] = crc >> 16 & 255;
                    data[p + 2] = crc >> 8 & 255;
                    data[p + 3] = crc & 255;
                  }
                  function adler32(data, start, end) {
                    var a = 1;
                    var b = 0;
                    for (var _i2 = start; _i2 < end; ++_i2) {
                      a = (a + (data[_i2] & 255)) % 65521;
                      b = (b + a) % 65521;
                    }
                    return b << 16 | a;
                  }
                  function deflateSync(literals) {
                    if (!_is_node2.isNodeJS) {
                      return deflateSyncUncompressed(literals);
                    }
                    try {
                      var input;
                      if (parseInt(process.versions.node) >= 8) {
                        input = literals;
                      } else {
                        input = Buffer.from(literals);
                      }
                      var output = require_zlib().deflateSync(input, {
                        level: 9
                      });
                      return output instanceof Uint8Array ? output : new Uint8Array(output);
                    } catch (e) {
                      (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                    }
                    return deflateSyncUncompressed(literals);
                  }
                  function deflateSyncUncompressed(literals) {
                    var len = literals.length;
                    var maxBlockLength = 65535;
                    var deflateBlocks = Math.ceil(len / maxBlockLength);
                    var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                    var pi = 0;
                    idat[pi++] = 120;
                    idat[pi++] = 156;
                    var pos = 0;
                    while (len > maxBlockLength) {
                      idat[pi++] = 0;
                      idat[pi++] = 255;
                      idat[pi++] = 255;
                      idat[pi++] = 0;
                      idat[pi++] = 0;
                      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                      pi += maxBlockLength;
                      pos += maxBlockLength;
                      len -= maxBlockLength;
                    }
                    idat[pi++] = 1;
                    idat[pi++] = len & 255;
                    idat[pi++] = len >> 8 & 255;
                    idat[pi++] = ~len & 65535 & 255;
                    idat[pi++] = (~len & 65535) >> 8 & 255;
                    idat.set(literals.subarray(pos), pi);
                    pi += literals.length - pos;
                    var adler = adler32(literals, 0, literals.length);
                    idat[pi++] = adler >> 24 & 255;
                    idat[pi++] = adler >> 16 & 255;
                    idat[pi++] = adler >> 8 & 255;
                    idat[pi++] = adler & 255;
                    return idat;
                  }
                  function encode(imgData, kind, forceDataSchema, isMask) {
                    var width = imgData.width;
                    var height = imgData.height;
                    var bitDepth, colorType, lineSize;
                    var bytes = imgData.data;
                    switch (kind) {
                      case _util2.ImageKind.GRAYSCALE_1BPP:
                        colorType = 0;
                        bitDepth = 1;
                        lineSize = width + 7 >> 3;
                        break;
                      case _util2.ImageKind.RGB_24BPP:
                        colorType = 2;
                        bitDepth = 8;
                        lineSize = width * 3;
                        break;
                      case _util2.ImageKind.RGBA_32BPP:
                        colorType = 6;
                        bitDepth = 8;
                        lineSize = width * 4;
                        break;
                      default:
                        throw new Error("invalid format");
                    }
                    var literals = new Uint8Array((1 + lineSize) * height);
                    var offsetLiterals = 0, offsetBytes = 0;
                    for (var y = 0; y < height; ++y) {
                      literals[offsetLiterals++] = 0;
                      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                      offsetBytes += lineSize;
                      offsetLiterals += lineSize;
                    }
                    if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                      offsetLiterals = 0;
                      for (var _y = 0; _y < height; _y++) {
                        offsetLiterals++;
                        for (var _i3 = 0; _i3 < lineSize; _i3++) {
                          literals[offsetLiterals++] ^= 255;
                        }
                      }
                    }
                    var ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                    var idat = deflateSync(literals);
                    var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                    var data = new Uint8Array(pngLength);
                    var offset = 0;
                    data.set(PNG_HEADER, offset);
                    offset += PNG_HEADER.length;
                    writePngChunk("IHDR", ihdr, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                    writePngChunk("IDATA", idat, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + idat.length;
                    writePngChunk("IEND", new Uint8Array(0), data, offset);
                    return createObjectURL(data, "image/png", forceDataSchema);
                  }
                  return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                    var kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                    return encode(imgData, kind, forceDataSchema, isMask);
                  };
                }();
                var SVGExtraState = /* @__PURE__ */ function() {
                  function SVGExtraState2() {
                    _classCallCheck2(this, SVGExtraState2);
                    this.fontSizeScale = 1;
                    this.fontWeight = SVG_DEFAULTS.fontWeight;
                    this.fontSize = 0;
                    this.textMatrix = _util2.IDENTITY_MATRIX;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.textMatrixScale = 1;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                    this.fillColor = SVG_DEFAULTS.fillColor;
                    this.strokeColor = "#000000";
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.lineJoin = "";
                    this.lineCap = "";
                    this.miterLimit = 0;
                    this.dashArray = [];
                    this.dashPhase = 0;
                    this.dependencies = [];
                    this.activeClipUrl = null;
                    this.clipGroup = null;
                    this.maskId = "";
                  }
                  _createClass2(SVGExtraState2, [{
                    key: "clone",
                    value: function clone() {
                      return Object.create(this);
                    }
                  }, {
                    key: "setCurrentPoint",
                    value: function setCurrentPoint(x, y) {
                      this.x = x;
                      this.y = y;
                    }
                  }]);
                  return SVGExtraState2;
                }();
                var clipCount = 0;
                var maskCount = 0;
                var shadingCount = 0;
                exports2.SVGGraphics = SVGGraphics = /* @__PURE__ */ function() {
                  function SVGGraphics2(commonObjs, objs) {
                    var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    _classCallCheck2(this, SVGGraphics2);
                    this.svgFactory = new _display_utils2.DOMSVGFactory();
                    this.current = new SVGExtraState();
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.transformStack = [];
                    this.extraStack = [];
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.embedFonts = false;
                    this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                    this.cssStyle = null;
                    this.forceDataSchema = !!forceDataSchema;
                    this._operatorIdMapping = [];
                    for (var op in _util2.OPS) {
                      this._operatorIdMapping[_util2.OPS[op]] = op;
                    }
                  }
                  _createClass2(SVGGraphics2, [{
                    key: "save",
                    value: function save() {
                      this.transformStack.push(this.transformMatrix);
                      var old = this.current;
                      this.extraStack.push(old);
                      this.current = old.clone();
                    }
                  }, {
                    key: "restore",
                    value: function restore() {
                      this.transformMatrix = this.transformStack.pop();
                      this.current = this.extraStack.pop();
                      this.pendingClip = null;
                      this.tgrp = null;
                    }
                  }, {
                    key: "group",
                    value: function group(items) {
                      this.save();
                      this.executeOpTree(items);
                      this.restore();
                    }
                  }, {
                    key: "loadDependencies",
                    value: function loadDependencies(operatorList) {
                      var _this = this;
                      var fnArray = operatorList.fnArray;
                      var argsArray = operatorList.argsArray;
                      for (var i = 0, ii = fnArray.length; i < ii; i++) {
                        if (fnArray[i] !== _util2.OPS.dependency) {
                          continue;
                        }
                        var _iterator2 = _createForOfIteratorHelper2(argsArray[i]), _step2;
                        try {
                          var _loop = function _loop2() {
                            var obj = _step2.value;
                            var objsPool = obj.startsWith("g_") ? _this.commonObjs : _this.objs;
                            var promise = new Promise(function(resolve) {
                              objsPool.get(obj, resolve);
                            });
                            _this.current.dependencies.push(promise);
                          };
                          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                            _loop();
                          }
                        } catch (err) {
                          _iterator2.e(err);
                        } finally {
                          _iterator2.f();
                        }
                      }
                      return Promise.all(this.current.dependencies);
                    }
                  }, {
                    key: "transform",
                    value: function transform(a, b, c, d, e, f) {
                      var transformMatrix = [a, b, c, d, e, f];
                      this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                      this.tgrp = null;
                    }
                  }, {
                    key: "getSVG",
                    value: function getSVG(operatorList, viewport) {
                      var _this2 = this;
                      this.viewport = viewport;
                      var svgElement = this._initialize(viewport);
                      return this.loadDependencies(operatorList).then(function() {
                        _this2.transformMatrix = _util2.IDENTITY_MATRIX;
                        _this2.executeOpTree(_this2.convertOpList(operatorList));
                        return svgElement;
                      });
                    }
                  }, {
                    key: "convertOpList",
                    value: function convertOpList(operatorList) {
                      var operatorIdMapping = this._operatorIdMapping;
                      var argsArray = operatorList.argsArray;
                      var fnArray = operatorList.fnArray;
                      var opList = [];
                      for (var i = 0, ii = fnArray.length; i < ii; i++) {
                        var fnId = fnArray[i];
                        opList.push({
                          fnId,
                          fn: operatorIdMapping[fnId],
                          args: argsArray[i]
                        });
                      }
                      return opListToTree(opList);
                    }
                  }, {
                    key: "executeOpTree",
                    value: function executeOpTree(opTree) {
                      var _iterator3 = _createForOfIteratorHelper2(opTree), _step3;
                      try {
                        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                          var opTreeElement = _step3.value;
                          var fn = opTreeElement.fn;
                          var fnId = opTreeElement.fnId;
                          var args = opTreeElement.args;
                          switch (fnId | 0) {
                            case _util2.OPS.beginText:
                              this.beginText();
                              break;
                            case _util2.OPS.dependency:
                              break;
                            case _util2.OPS.setLeading:
                              this.setLeading(args);
                              break;
                            case _util2.OPS.setLeadingMoveText:
                              this.setLeadingMoveText(args[0], args[1]);
                              break;
                            case _util2.OPS.setFont:
                              this.setFont(args);
                              break;
                            case _util2.OPS.showText:
                              this.showText(args[0]);
                              break;
                            case _util2.OPS.showSpacedText:
                              this.showText(args[0]);
                              break;
                            case _util2.OPS.endText:
                              this.endText();
                              break;
                            case _util2.OPS.moveText:
                              this.moveText(args[0], args[1]);
                              break;
                            case _util2.OPS.setCharSpacing:
                              this.setCharSpacing(args[0]);
                              break;
                            case _util2.OPS.setWordSpacing:
                              this.setWordSpacing(args[0]);
                              break;
                            case _util2.OPS.setHScale:
                              this.setHScale(args[0]);
                              break;
                            case _util2.OPS.setTextMatrix:
                              this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                              break;
                            case _util2.OPS.setTextRise:
                              this.setTextRise(args[0]);
                              break;
                            case _util2.OPS.setTextRenderingMode:
                              this.setTextRenderingMode(args[0]);
                              break;
                            case _util2.OPS.setLineWidth:
                              this.setLineWidth(args[0]);
                              break;
                            case _util2.OPS.setLineJoin:
                              this.setLineJoin(args[0]);
                              break;
                            case _util2.OPS.setLineCap:
                              this.setLineCap(args[0]);
                              break;
                            case _util2.OPS.setMiterLimit:
                              this.setMiterLimit(args[0]);
                              break;
                            case _util2.OPS.setFillRGBColor:
                              this.setFillRGBColor(args[0], args[1], args[2]);
                              break;
                            case _util2.OPS.setStrokeRGBColor:
                              this.setStrokeRGBColor(args[0], args[1], args[2]);
                              break;
                            case _util2.OPS.setStrokeColorN:
                              this.setStrokeColorN(args);
                              break;
                            case _util2.OPS.setFillColorN:
                              this.setFillColorN(args);
                              break;
                            case _util2.OPS.shadingFill:
                              this.shadingFill(args[0]);
                              break;
                            case _util2.OPS.setDash:
                              this.setDash(args[0], args[1]);
                              break;
                            case _util2.OPS.setRenderingIntent:
                              this.setRenderingIntent(args[0]);
                              break;
                            case _util2.OPS.setFlatness:
                              this.setFlatness(args[0]);
                              break;
                            case _util2.OPS.setGState:
                              this.setGState(args[0]);
                              break;
                            case _util2.OPS.fill:
                              this.fill();
                              break;
                            case _util2.OPS.eoFill:
                              this.eoFill();
                              break;
                            case _util2.OPS.stroke:
                              this.stroke();
                              break;
                            case _util2.OPS.fillStroke:
                              this.fillStroke();
                              break;
                            case _util2.OPS.eoFillStroke:
                              this.eoFillStroke();
                              break;
                            case _util2.OPS.clip:
                              this.clip("nonzero");
                              break;
                            case _util2.OPS.eoClip:
                              this.clip("evenodd");
                              break;
                            case _util2.OPS.paintSolidColorImageMask:
                              this.paintSolidColorImageMask();
                              break;
                            case _util2.OPS.paintImageXObject:
                              this.paintImageXObject(args[0]);
                              break;
                            case _util2.OPS.paintInlineImageXObject:
                              this.paintInlineImageXObject(args[0]);
                              break;
                            case _util2.OPS.paintImageMaskXObject:
                              this.paintImageMaskXObject(args[0]);
                              break;
                            case _util2.OPS.paintFormXObjectBegin:
                              this.paintFormXObjectBegin(args[0], args[1]);
                              break;
                            case _util2.OPS.paintFormXObjectEnd:
                              this.paintFormXObjectEnd();
                              break;
                            case _util2.OPS.closePath:
                              this.closePath();
                              break;
                            case _util2.OPS.closeStroke:
                              this.closeStroke();
                              break;
                            case _util2.OPS.closeFillStroke:
                              this.closeFillStroke();
                              break;
                            case _util2.OPS.closeEOFillStroke:
                              this.closeEOFillStroke();
                              break;
                            case _util2.OPS.nextLine:
                              this.nextLine();
                              break;
                            case _util2.OPS.transform:
                              this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                              break;
                            case _util2.OPS.constructPath:
                              this.constructPath(args[0], args[1]);
                              break;
                            case _util2.OPS.endPath:
                              this.endPath();
                              break;
                            case 92:
                              this.group(opTreeElement.items);
                              break;
                            default:
                              (0, _util2.warn)("Unimplemented operator ".concat(fn));
                              break;
                          }
                        }
                      } catch (err) {
                        _iterator3.e(err);
                      } finally {
                        _iterator3.f();
                      }
                    }
                  }, {
                    key: "setWordSpacing",
                    value: function setWordSpacing(wordSpacing) {
                      this.current.wordSpacing = wordSpacing;
                    }
                  }, {
                    key: "setCharSpacing",
                    value: function setCharSpacing(charSpacing) {
                      this.current.charSpacing = charSpacing;
                    }
                  }, {
                    key: "nextLine",
                    value: function nextLine() {
                      this.moveText(0, this.current.leading);
                    }
                  }, {
                    key: "setTextMatrix",
                    value: function setTextMatrix(a, b, c, d, e, f) {
                      var current = this.current;
                      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                      current.textMatrixScale = Math.hypot(a, b);
                      current.x = current.lineX = 0;
                      current.y = current.lineY = 0;
                      current.xcoords = [];
                      current.ycoords = [];
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      current.txtElement = this.svgFactory.createElement("svg:text");
                      current.txtElement.appendChild(current.tspan);
                    }
                  }, {
                    key: "beginText",
                    value: function beginText() {
                      var current = this.current;
                      current.x = current.lineX = 0;
                      current.y = current.lineY = 0;
                      current.textMatrix = _util2.IDENTITY_MATRIX;
                      current.lineMatrix = _util2.IDENTITY_MATRIX;
                      current.textMatrixScale = 1;
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.txtElement = this.svgFactory.createElement("svg:text");
                      current.txtgrp = this.svgFactory.createElement("svg:g");
                      current.xcoords = [];
                      current.ycoords = [];
                    }
                  }, {
                    key: "moveText",
                    value: function moveText(x, y) {
                      var current = this.current;
                      current.x = current.lineX += x;
                      current.y = current.lineY += y;
                      current.xcoords = [];
                      current.ycoords = [];
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    }
                  }, {
                    key: "showText",
                    value: function showText(glyphs) {
                      var current = this.current;
                      var font = current.font;
                      var fontSize = current.fontSize;
                      if (fontSize === 0) {
                        return;
                      }
                      var fontSizeScale = current.fontSizeScale;
                      var charSpacing = current.charSpacing;
                      var wordSpacing = current.wordSpacing;
                      var fontDirection = current.fontDirection;
                      var textHScale = current.textHScale * fontDirection;
                      var vertical = font.vertical;
                      var spacingDir = vertical ? 1 : -1;
                      var defaultVMetrics = font.defaultVMetrics;
                      var widthAdvanceScale = fontSize * current.fontMatrix[0];
                      var x = 0;
                      var _iterator4 = _createForOfIteratorHelper2(glyphs), _step4;
                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                          var glyph = _step4.value;
                          if (glyph === null) {
                            x += fontDirection * wordSpacing;
                            continue;
                          } else if (typeof glyph === "number") {
                            x += spacingDir * glyph * fontSize / 1e3;
                            continue;
                          }
                          var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                          var character = glyph.fontChar;
                          var scaledX = void 0, scaledY = void 0;
                          var width = glyph.width;
                          if (vertical) {
                            var vx = void 0;
                            var vmetric = glyph.vmetric || defaultVMetrics;
                            vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                            vx = -vx * widthAdvanceScale;
                            var vy = vmetric[2] * widthAdvanceScale;
                            width = vmetric ? -vmetric[0] : width;
                            scaledX = vx / fontSizeScale;
                            scaledY = (x + vy) / fontSizeScale;
                          } else {
                            scaledX = x / fontSizeScale;
                            scaledY = 0;
                          }
                          if (glyph.isInFont || font.missingFile) {
                            current.xcoords.push(current.x + scaledX);
                            if (vertical) {
                              current.ycoords.push(-current.y + scaledY);
                            }
                            current.tspan.textContent += character;
                          } else {
                          }
                          var charWidth = void 0;
                          if (vertical) {
                            charWidth = width * widthAdvanceScale - spacing * fontDirection;
                          } else {
                            charWidth = width * widthAdvanceScale + spacing * fontDirection;
                          }
                          x += charWidth;
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }
                      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                      if (vertical) {
                        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                      } else {
                        current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      }
                      if (vertical) {
                        current.y -= x;
                      } else {
                        current.x += x * textHScale;
                      }
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                      }
                      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                      }
                      var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                          current.tspan.setAttributeNS(null, "fill", current.fillColor);
                        }
                        if (current.fillAlpha < 1) {
                          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                        }
                      } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                        current.tspan.setAttributeNS(null, "fill", "transparent");
                      } else {
                        current.tspan.setAttributeNS(null, "fill", "none");
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        var lineWidthScale = 1 / (current.textMatrixScale || 1);
                        this._setStrokeAttributes(current.tspan, lineWidthScale);
                      }
                      var textMatrix = current.textMatrix;
                      if (current.textRise !== 0) {
                        textMatrix = textMatrix.slice();
                        textMatrix[5] += current.textRise;
                      }
                      current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
                      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                      current.txtElement.appendChild(current.tspan);
                      current.txtgrp.appendChild(current.txtElement);
                      this._ensureTransformGroup().appendChild(current.txtElement);
                    }
                  }, {
                    key: "setLeadingMoveText",
                    value: function setLeadingMoveText(x, y) {
                      this.setLeading(-y);
                      this.moveText(x, y);
                    }
                  }, {
                    key: "addFontStyle",
                    value: function addFontStyle(fontObj) {
                      if (!fontObj.data) {
                        throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                      }
                      if (!this.cssStyle) {
                        this.cssStyle = this.svgFactory.createElement("svg:style");
                        this.cssStyle.setAttributeNS(null, "type", "text/css");
                        this.defs.appendChild(this.cssStyle);
                      }
                      var url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                      this.cssStyle.textContent += '@font-face { font-family: "'.concat(fontObj.loadedName, '";') + " src: url(".concat(url, "); }\n");
                    }
                  }, {
                    key: "setFont",
                    value: function setFont(details) {
                      var current = this.current;
                      var fontObj = this.commonObjs.get(details[0]);
                      var size = details[1];
                      current.font = fontObj;
                      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                        this.addFontStyle(fontObj);
                        this.embeddedFonts[fontObj.loadedName] = fontObj;
                      }
                      current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                      var bold = "normal";
                      if (fontObj.black) {
                        bold = "900";
                      } else if (fontObj.bold) {
                        bold = "bold";
                      }
                      var italic = fontObj.italic ? "italic" : "normal";
                      if (size < 0) {
                        size = -size;
                        current.fontDirection = -1;
                      } else {
                        current.fontDirection = 1;
                      }
                      current.fontSize = size;
                      current.fontFamily = fontObj.loadedName;
                      current.fontWeight = bold;
                      current.fontStyle = italic;
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      current.xcoords = [];
                      current.ycoords = [];
                    }
                  }, {
                    key: "endText",
                    value: function endText() {
                      var _current$txtElement;
                      var current = this.current;
                      if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
                        current.element = current.txtElement;
                        this.clip("nonzero");
                        this.endPath();
                      }
                    }
                  }, {
                    key: "setLineWidth",
                    value: function setLineWidth(width) {
                      if (width > 0) {
                        this.current.lineWidth = width;
                      }
                    }
                  }, {
                    key: "setLineCap",
                    value: function setLineCap(style) {
                      this.current.lineCap = LINE_CAP_STYLES[style];
                    }
                  }, {
                    key: "setLineJoin",
                    value: function setLineJoin(style) {
                      this.current.lineJoin = LINE_JOIN_STYLES[style];
                    }
                  }, {
                    key: "setMiterLimit",
                    value: function setMiterLimit(limit) {
                      this.current.miterLimit = limit;
                    }
                  }, {
                    key: "setStrokeAlpha",
                    value: function setStrokeAlpha(strokeAlpha) {
                      this.current.strokeAlpha = strokeAlpha;
                    }
                  }, {
                    key: "setStrokeRGBColor",
                    value: function setStrokeRGBColor(r, g, b) {
                      this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                    }
                  }, {
                    key: "setFillAlpha",
                    value: function setFillAlpha(fillAlpha) {
                      this.current.fillAlpha = fillAlpha;
                    }
                  }, {
                    key: "setFillRGBColor",
                    value: function setFillRGBColor(r, g, b) {
                      this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                      this.current.tspan = this.svgFactory.createElement("svg:tspan");
                      this.current.xcoords = [];
                      this.current.ycoords = [];
                    }
                  }, {
                    key: "setStrokeColorN",
                    value: function setStrokeColorN(args) {
                      this.current.strokeColor = this._makeColorN_Pattern(args);
                    }
                  }, {
                    key: "setFillColorN",
                    value: function setFillColorN(args) {
                      this.current.fillColor = this._makeColorN_Pattern(args);
                    }
                  }, {
                    key: "shadingFill",
                    value: function shadingFill(args) {
                      var width = this.viewport.width;
                      var height = this.viewport.height;
                      var inv = _util2.Util.inverseTransform(this.transformMatrix);
                      var bl = _util2.Util.applyTransform([0, 0], inv);
                      var br = _util2.Util.applyTransform([0, height], inv);
                      var ul = _util2.Util.applyTransform([width, 0], inv);
                      var ur = _util2.Util.applyTransform([width, height], inv);
                      var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                      var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                      var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                      var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                      var rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", x0);
                      rect.setAttributeNS(null, "y", y0);
                      rect.setAttributeNS(null, "width", x1 - x0);
                      rect.setAttributeNS(null, "height", y1 - y0);
                      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                      if (this.current.fillAlpha < 1) {
                        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                      }
                      this._ensureTransformGroup().appendChild(rect);
                    }
                  }, {
                    key: "_makeColorN_Pattern",
                    value: function _makeColorN_Pattern(args) {
                      if (args[0] === "TilingPattern") {
                        return this._makeTilingPattern(args);
                      }
                      return this._makeShadingPattern(args);
                    }
                  }, {
                    key: "_makeTilingPattern",
                    value: function _makeTilingPattern(args) {
                      var color = args[1];
                      var operatorList = args[2];
                      var matrix = args[3] || _util2.IDENTITY_MATRIX;
                      var _args$ = _slicedToArray2(args[4], 4), x0 = _args$[0], y0 = _args$[1], x1 = _args$[2], y1 = _args$[3];
                      var xstep = args[5];
                      var ystep = args[6];
                      var paintType = args[7];
                      var tilingId = "shading".concat(shadingCount++);
                      var _Util$normalizeRect = _util2.Util.normalizeRect([].concat(_toConsumableArray2(_util2.Util.applyTransform([x0, y0], matrix)), _toConsumableArray2(_util2.Util.applyTransform([x1, y1], matrix)))), _Util$normalizeRect2 = _slicedToArray2(_Util$normalizeRect, 4), tx0 = _Util$normalizeRect2[0], ty0 = _Util$normalizeRect2[1], tx1 = _Util$normalizeRect2[2], ty1 = _Util$normalizeRect2[3];
                      var _Util$singularValueDe = _util2.Util.singularValueDecompose2dScale(matrix), _Util$singularValueDe2 = _slicedToArray2(_Util$singularValueDe, 2), xscale = _Util$singularValueDe2[0], yscale = _Util$singularValueDe2[1];
                      var txstep = xstep * xscale;
                      var tystep = ystep * yscale;
                      var tiling = this.svgFactory.createElement("svg:pattern");
                      tiling.setAttributeNS(null, "id", tilingId);
                      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                      tiling.setAttributeNS(null, "width", txstep);
                      tiling.setAttributeNS(null, "height", tystep);
                      tiling.setAttributeNS(null, "x", "".concat(tx0));
                      tiling.setAttributeNS(null, "y", "".concat(ty0));
                      var svg = this.svg;
                      var transformMatrix = this.transformMatrix;
                      var fillColor = this.current.fillColor;
                      var strokeColor = this.current.strokeColor;
                      var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                      this.svg = bbox;
                      this.transformMatrix = matrix;
                      if (paintType === 2) {
                        var cssColor = _util2.Util.makeHexColor.apply(_util2.Util, _toConsumableArray2(color));
                        this.current.fillColor = cssColor;
                        this.current.strokeColor = cssColor;
                      }
                      this.executeOpTree(this.convertOpList(operatorList));
                      this.svg = svg;
                      this.transformMatrix = transformMatrix;
                      this.current.fillColor = fillColor;
                      this.current.strokeColor = strokeColor;
                      tiling.appendChild(bbox.childNodes[0]);
                      this.defs.appendChild(tiling);
                      return "url(#".concat(tilingId, ")");
                    }
                  }, {
                    key: "_makeShadingPattern",
                    value: function _makeShadingPattern(args) {
                      if (typeof args === "string") {
                        args = this.objs.get(args);
                      }
                      switch (args[0]) {
                        case "RadialAxial":
                          var shadingId = "shading".concat(shadingCount++);
                          var colorStops = args[3];
                          var gradient;
                          switch (args[1]) {
                            case "axial":
                              var point0 = args[4];
                              var point1 = args[5];
                              gradient = this.svgFactory.createElement("svg:linearGradient");
                              gradient.setAttributeNS(null, "id", shadingId);
                              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                              gradient.setAttributeNS(null, "x1", point0[0]);
                              gradient.setAttributeNS(null, "y1", point0[1]);
                              gradient.setAttributeNS(null, "x2", point1[0]);
                              gradient.setAttributeNS(null, "y2", point1[1]);
                              break;
                            case "radial":
                              var focalPoint = args[4];
                              var circlePoint = args[5];
                              var focalRadius = args[6];
                              var circleRadius = args[7];
                              gradient = this.svgFactory.createElement("svg:radialGradient");
                              gradient.setAttributeNS(null, "id", shadingId);
                              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                              gradient.setAttributeNS(null, "cx", circlePoint[0]);
                              gradient.setAttributeNS(null, "cy", circlePoint[1]);
                              gradient.setAttributeNS(null, "r", circleRadius);
                              gradient.setAttributeNS(null, "fx", focalPoint[0]);
                              gradient.setAttributeNS(null, "fy", focalPoint[1]);
                              gradient.setAttributeNS(null, "fr", focalRadius);
                              break;
                            default:
                              throw new Error("Unknown RadialAxial type: ".concat(args[1]));
                          }
                          var _iterator5 = _createForOfIteratorHelper2(colorStops), _step5;
                          try {
                            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                              var colorStop = _step5.value;
                              var stop = this.svgFactory.createElement("svg:stop");
                              stop.setAttributeNS(null, "offset", colorStop[0]);
                              stop.setAttributeNS(null, "stop-color", colorStop[1]);
                              gradient.appendChild(stop);
                            }
                          } catch (err) {
                            _iterator5.e(err);
                          } finally {
                            _iterator5.f();
                          }
                          this.defs.appendChild(gradient);
                          return "url(#".concat(shadingId, ")");
                        case "Mesh":
                          (0, _util2.warn)("Unimplemented pattern Mesh");
                          return null;
                        case "Dummy":
                          return "hotpink";
                        default:
                          throw new Error("Unknown IR type: ".concat(args[0]));
                      }
                    }
                  }, {
                    key: "setDash",
                    value: function setDash(dashArray, dashPhase) {
                      this.current.dashArray = dashArray;
                      this.current.dashPhase = dashPhase;
                    }
                  }, {
                    key: "constructPath",
                    value: function constructPath(ops, args) {
                      var current = this.current;
                      var x = current.x, y = current.y;
                      var d = [];
                      var j = 0;
                      var _iterator6 = _createForOfIteratorHelper2(ops), _step6;
                      try {
                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                          var op = _step6.value;
                          switch (op | 0) {
                            case _util2.OPS.rectangle:
                              x = args[j++];
                              y = args[j++];
                              var width = args[j++];
                              var height = args[j++];
                              var xw = x + width;
                              var yh = y + height;
                              d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                              break;
                            case _util2.OPS.moveTo:
                              x = args[j++];
                              y = args[j++];
                              d.push("M", pf(x), pf(y));
                              break;
                            case _util2.OPS.lineTo:
                              x = args[j++];
                              y = args[j++];
                              d.push("L", pf(x), pf(y));
                              break;
                            case _util2.OPS.curveTo:
                              x = args[j + 4];
                              y = args[j + 5];
                              d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                              j += 6;
                              break;
                            case _util2.OPS.curveTo2:
                              d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                              x = args[j + 2];
                              y = args[j + 3];
                              j += 4;
                              break;
                            case _util2.OPS.curveTo3:
                              x = args[j + 2];
                              y = args[j + 3];
                              d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                              j += 4;
                              break;
                            case _util2.OPS.closePath:
                              d.push("Z");
                              break;
                          }
                        }
                      } catch (err) {
                        _iterator6.e(err);
                      } finally {
                        _iterator6.f();
                      }
                      d = d.join(" ");
                      if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                        d = current.path.getAttributeNS(null, "d") + d;
                      } else {
                        current.path = this.svgFactory.createElement("svg:path");
                        this._ensureTransformGroup().appendChild(current.path);
                      }
                      current.path.setAttributeNS(null, "d", d);
                      current.path.setAttributeNS(null, "fill", "none");
                      current.element = current.path;
                      current.setCurrentPoint(x, y);
                    }
                  }, {
                    key: "endPath",
                    value: function endPath() {
                      var current = this.current;
                      current.path = null;
                      if (!this.pendingClip) {
                        return;
                      }
                      if (!current.element) {
                        this.pendingClip = null;
                        return;
                      }
                      var clipId = "clippath".concat(clipCount++);
                      var clipPath = this.svgFactory.createElement("svg:clipPath");
                      clipPath.setAttributeNS(null, "id", clipId);
                      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      var clipElement = current.element.cloneNode(true);
                      if (this.pendingClip === "evenodd") {
                        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                      } else {
                        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                      }
                      this.pendingClip = null;
                      clipPath.appendChild(clipElement);
                      this.defs.appendChild(clipPath);
                      if (current.activeClipUrl) {
                        current.clipGroup = null;
                        var _iterator7 = _createForOfIteratorHelper2(this.extraStack), _step7;
                        try {
                          for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                            var prev = _step7.value;
                            prev.clipGroup = null;
                          }
                        } catch (err) {
                          _iterator7.e(err);
                        } finally {
                          _iterator7.f();
                        }
                        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                      }
                      current.activeClipUrl = "url(#".concat(clipId, ")");
                      this.tgrp = null;
                    }
                  }, {
                    key: "clip",
                    value: function clip(type) {
                      this.pendingClip = type;
                    }
                  }, {
                    key: "closePath",
                    value: function closePath() {
                      var current = this.current;
                      if (current.path) {
                        var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
                        current.path.setAttributeNS(null, "d", d);
                      }
                    }
                  }, {
                    key: "setLeading",
                    value: function setLeading(leading) {
                      this.current.leading = -leading;
                    }
                  }, {
                    key: "setTextRise",
                    value: function setTextRise(textRise) {
                      this.current.textRise = textRise;
                    }
                  }, {
                    key: "setTextRenderingMode",
                    value: function setTextRenderingMode(textRenderingMode) {
                      this.current.textRenderingMode = textRenderingMode;
                    }
                  }, {
                    key: "setHScale",
                    value: function setHScale(scale) {
                      this.current.textHScale = scale / 100;
                    }
                  }, {
                    key: "setRenderingIntent",
                    value: function setRenderingIntent(intent) {
                    }
                  }, {
                    key: "setFlatness",
                    value: function setFlatness(flatness) {
                    }
                  }, {
                    key: "setGState",
                    value: function setGState(states) {
                      var _iterator8 = _createForOfIteratorHelper2(states), _step8;
                      try {
                        for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                          var _step8$value = _slicedToArray2(_step8.value, 2), key = _step8$value[0], value = _step8$value[1];
                          switch (key) {
                            case "LW":
                              this.setLineWidth(value);
                              break;
                            case "LC":
                              this.setLineCap(value);
                              break;
                            case "LJ":
                              this.setLineJoin(value);
                              break;
                            case "ML":
                              this.setMiterLimit(value);
                              break;
                            case "D":
                              this.setDash(value[0], value[1]);
                              break;
                            case "RI":
                              this.setRenderingIntent(value);
                              break;
                            case "FL":
                              this.setFlatness(value);
                              break;
                            case "Font":
                              this.setFont(value);
                              break;
                            case "CA":
                              this.setStrokeAlpha(value);
                              break;
                            case "ca":
                              this.setFillAlpha(value);
                              break;
                            default:
                              (0, _util2.warn)("Unimplemented graphic state operator ".concat(key));
                              break;
                          }
                        }
                      } catch (err) {
                        _iterator8.e(err);
                      } finally {
                        _iterator8.f();
                      }
                    }
                  }, {
                    key: "fill",
                    value: function fill() {
                      var current = this.current;
                      if (current.element) {
                        current.element.setAttributeNS(null, "fill", current.fillColor);
                        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                        this.endPath();
                      }
                    }
                  }, {
                    key: "stroke",
                    value: function stroke() {
                      var current = this.current;
                      if (current.element) {
                        this._setStrokeAttributes(current.element);
                        current.element.setAttributeNS(null, "fill", "none");
                        this.endPath();
                      }
                    }
                  }, {
                    key: "_setStrokeAttributes",
                    value: function _setStrokeAttributes(element) {
                      var lineWidthScale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                      var current = this.current;
                      var dashArray = current.dashArray;
                      if (lineWidthScale !== 1 && dashArray.length > 0) {
                        dashArray = dashArray.map(function(value) {
                          return lineWidthScale * value;
                        });
                      }
                      element.setAttributeNS(null, "stroke", current.strokeColor);
                      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                    }
                  }, {
                    key: "eoFill",
                    value: function eoFill() {
                      if (this.current.element) {
                        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                      }
                      this.fill();
                    }
                  }, {
                    key: "fillStroke",
                    value: function fillStroke() {
                      this.stroke();
                      this.fill();
                    }
                  }, {
                    key: "eoFillStroke",
                    value: function eoFillStroke() {
                      if (this.current.element) {
                        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                      }
                      this.fillStroke();
                    }
                  }, {
                    key: "closeStroke",
                    value: function closeStroke() {
                      this.closePath();
                      this.stroke();
                    }
                  }, {
                    key: "closeFillStroke",
                    value: function closeFillStroke() {
                      this.closePath();
                      this.fillStroke();
                    }
                  }, {
                    key: "closeEOFillStroke",
                    value: function closeEOFillStroke() {
                      this.closePath();
                      this.eoFillStroke();
                    }
                  }, {
                    key: "paintSolidColorImageMask",
                    value: function paintSolidColorImageMask() {
                      var rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", "0");
                      rect.setAttributeNS(null, "y", "0");
                      rect.setAttributeNS(null, "width", "1px");
                      rect.setAttributeNS(null, "height", "1px");
                      rect.setAttributeNS(null, "fill", this.current.fillColor);
                      this._ensureTransformGroup().appendChild(rect);
                    }
                  }, {
                    key: "paintImageXObject",
                    value: function paintImageXObject(objId) {
                      var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                      if (!imgData) {
                        (0, _util2.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
                        return;
                      }
                      this.paintInlineImageXObject(imgData);
                    }
                  }, {
                    key: "paintInlineImageXObject",
                    value: function paintInlineImageXObject(imgData, mask) {
                      var width = imgData.width;
                      var height = imgData.height;
                      var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                      var cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", "0");
                      cliprect.setAttributeNS(null, "y", "0");
                      cliprect.setAttributeNS(null, "width", pf(width));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      var imgEl = this.svgFactory.createElement("svg:image");
                      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                      imgEl.setAttributeNS(null, "x", "0");
                      imgEl.setAttributeNS(null, "y", pf(-height));
                      imgEl.setAttributeNS(null, "width", pf(width) + "px");
                      imgEl.setAttributeNS(null, "height", pf(height) + "px");
                      imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));
                      if (mask) {
                        mask.appendChild(imgEl);
                      } else {
                        this._ensureTransformGroup().appendChild(imgEl);
                      }
                    }
                  }, {
                    key: "paintImageMaskXObject",
                    value: function paintImageMaskXObject(imgData) {
                      var current = this.current;
                      var width = imgData.width;
                      var height = imgData.height;
                      var fillColor = current.fillColor;
                      current.maskId = "mask".concat(maskCount++);
                      var mask = this.svgFactory.createElement("svg:mask");
                      mask.setAttributeNS(null, "id", current.maskId);
                      var rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", "0");
                      rect.setAttributeNS(null, "y", "0");
                      rect.setAttributeNS(null, "width", pf(width));
                      rect.setAttributeNS(null, "height", pf(height));
                      rect.setAttributeNS(null, "fill", fillColor);
                      rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
                      this.defs.appendChild(mask);
                      this._ensureTransformGroup().appendChild(rect);
                      this.paintInlineImageXObject(imgData, mask);
                    }
                  }, {
                    key: "paintFormXObjectBegin",
                    value: function paintFormXObjectBegin(matrix, bbox) {
                      if (Array.isArray(matrix) && matrix.length === 6) {
                        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                      }
                      if (bbox) {
                        var width = bbox[2] - bbox[0];
                        var height = bbox[3] - bbox[1];
                        var cliprect = this.svgFactory.createElement("svg:rect");
                        cliprect.setAttributeNS(null, "x", bbox[0]);
                        cliprect.setAttributeNS(null, "y", bbox[1]);
                        cliprect.setAttributeNS(null, "width", pf(width));
                        cliprect.setAttributeNS(null, "height", pf(height));
                        this.current.element = cliprect;
                        this.clip("nonzero");
                        this.endPath();
                      }
                    }
                  }, {
                    key: "paintFormXObjectEnd",
                    value: function paintFormXObjectEnd() {
                    }
                  }, {
                    key: "_initialize",
                    value: function _initialize(viewport) {
                      var svg = this.svgFactory.create(viewport.width, viewport.height);
                      var definitions = this.svgFactory.createElement("svg:defs");
                      svg.appendChild(definitions);
                      this.defs = definitions;
                      var rootGroup = this.svgFactory.createElement("svg:g");
                      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                      svg.appendChild(rootGroup);
                      this.svg = rootGroup;
                      return svg;
                    }
                  }, {
                    key: "_ensureClipGroup",
                    value: function _ensureClipGroup() {
                      if (!this.current.clipGroup) {
                        var clipGroup = this.svgFactory.createElement("svg:g");
                        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                        this.svg.appendChild(clipGroup);
                        this.current.clipGroup = clipGroup;
                      }
                      return this.current.clipGroup;
                    }
                  }, {
                    key: "_ensureTransformGroup",
                    value: function _ensureTransformGroup() {
                      if (!this.tgrp) {
                        this.tgrp = this.svgFactory.createElement("svg:g");
                        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                        if (this.current.activeClipUrl) {
                          this._ensureClipGroup().appendChild(this.tgrp);
                        } else {
                          this.svg.appendChild(this.tgrp);
                        }
                      }
                      return this.tgrp;
                    }
                  }]);
                  return SVGGraphics2;
                }();
              }
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, _typeof2(obj);
              }
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNodeStream = void 0;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(179);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              ;
              var fs = require_fs();
              var http = require_http();
              var https = require_https();
              var url = require_url();
              var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
              function parseUrl(sourceUrl) {
                var parsedUrl = url.parse(sourceUrl);
                if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                  return parsedUrl;
                }
                if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                  return url.parse("file:///".concat(sourceUrl));
                }
                if (!parsedUrl.host) {
                  parsedUrl.protocol = "file:";
                }
                return parsedUrl;
              }
              var PDFNodeStream = /* @__PURE__ */ function() {
                function PDFNodeStream2(source) {
                  _classCallCheck2(this, PDFNodeStream2);
                  this.source = source;
                  this.url = parseUrl(source.url);
                  this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                  this.isFsUrl = this.url.protocol === "file:";
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _createClass2(PDFNodeStream2, [{
                  key: "_progressiveDataLength",
                  get: function get2() {
                    var _this$_fullRequestRea, _this$_fullRequestRea2;
                    return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                  }
                }, {
                  key: "getFullReader",
                  value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                    return this._fullRequestReader;
                  }
                }, {
                  key: "getRangeReader",
                  value: function getRangeReader(start, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                    this._rangeRequestReaders.push(rangeReader);
                    return rangeReader;
                  }
                }, {
                  key: "cancelAllRequests",
                  value: function cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    var _iterator = _createForOfIteratorHelper2(this._rangeRequestReaders.slice(0)), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var reader = _step.value;
                        reader.cancel(reason);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  }
                }]);
                return PDFNodeStream2;
              }();
              exports2.PDFNodeStream = PDFNodeStream;
              var BaseFullReader = /* @__PURE__ */ function() {
                function BaseFullReader2(stream) {
                  _classCallCheck2(this, BaseFullReader2);
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  var source = stream.source;
                  this._contentLength = source.length;
                  this._loaded = 0;
                  this._filename = null;
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                }
                _createClass2(BaseFullReader2, [{
                  key: "headersReady",
                  get: function get2() {
                    return this._headersCapability.promise;
                  }
                }, {
                  key: "filename",
                  get: function get2() {
                    return this._filename;
                  }
                }, {
                  key: "contentLength",
                  get: function get2() {
                    return this._contentLength;
                  }
                }, {
                  key: "isRangeSupported",
                  get: function get2() {
                    return this._isRangeSupported;
                  }
                }, {
                  key: "isStreamingSupported",
                  get: function get2() {
                    return this._isStreamingSupported;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee() {
                      var chunk, buffer;
                      return _regenerator2["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _context.next = 2;
                              return this._readCapability.promise;
                            case 2:
                              if (!this._done) {
                                _context.next = 4;
                                break;
                              }
                              return _context.abrupt("return", {
                                value: void 0,
                                done: true
                              });
                            case 4:
                              if (!this._storedError) {
                                _context.next = 6;
                                break;
                              }
                              throw this._storedError;
                            case 6:
                              chunk = this._readableStream.read();
                              if (!(chunk === null)) {
                                _context.next = 10;
                                break;
                              }
                              this._readCapability = (0, _util2.createPromiseCapability)();
                              return _context.abrupt("return", this.read());
                            case 10:
                              this._loaded += chunk.length;
                              if (this.onProgress) {
                                this.onProgress({
                                  loaded: this._loaded,
                                  total: this._contentLength
                                });
                              }
                              buffer = new Uint8Array(chunk).buffer;
                              return _context.abrupt("return", {
                                value: buffer,
                                done: false
                              });
                            case 14:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    if (!this._readableStream) {
                      this._error(reason);
                      return;
                    }
                    this._readableStream.destroy(reason);
                  }
                }, {
                  key: "_error",
                  value: function _error(reason) {
                    this._storedError = reason;
                    this._readCapability.resolve();
                  }
                }, {
                  key: "_setReadableStream",
                  value: function _setReadableStream(readableStream) {
                    var _this = this;
                    this._readableStream = readableStream;
                    readableStream.on("readable", function() {
                      _this._readCapability.resolve();
                    });
                    readableStream.on("end", function() {
                      readableStream.destroy();
                      _this._done = true;
                      _this._readCapability.resolve();
                    });
                    readableStream.on("error", function(reason) {
                      _this._error(reason);
                    });
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this._error(new _util2.AbortException("streaming is disabled"));
                    }
                    if (this._storedError) {
                      this._readableStream.destroy(this._storedError);
                    }
                  }
                }]);
                return BaseFullReader2;
              }();
              var BaseRangeReader = /* @__PURE__ */ function() {
                function BaseRangeReader2(stream) {
                  _classCallCheck2(this, BaseRangeReader2);
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  this._loaded = 0;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  var source = stream.source;
                  this._isStreamingSupported = !source.disableStream;
                }
                _createClass2(BaseRangeReader2, [{
                  key: "isStreamingSupported",
                  get: function get2() {
                    return this._isStreamingSupported;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                      var chunk, buffer;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return this._readCapability.promise;
                            case 2:
                              if (!this._done) {
                                _context2.next = 4;
                                break;
                              }
                              return _context2.abrupt("return", {
                                value: void 0,
                                done: true
                              });
                            case 4:
                              if (!this._storedError) {
                                _context2.next = 6;
                                break;
                              }
                              throw this._storedError;
                            case 6:
                              chunk = this._readableStream.read();
                              if (!(chunk === null)) {
                                _context2.next = 10;
                                break;
                              }
                              this._readCapability = (0, _util2.createPromiseCapability)();
                              return _context2.abrupt("return", this.read());
                            case 10:
                              this._loaded += chunk.length;
                              if (this.onProgress) {
                                this.onProgress({
                                  loaded: this._loaded
                                });
                              }
                              buffer = new Uint8Array(chunk).buffer;
                              return _context2.abrupt("return", {
                                value: buffer,
                                done: false
                              });
                            case 14:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    if (!this._readableStream) {
                      this._error(reason);
                      return;
                    }
                    this._readableStream.destroy(reason);
                  }
                }, {
                  key: "_error",
                  value: function _error(reason) {
                    this._storedError = reason;
                    this._readCapability.resolve();
                  }
                }, {
                  key: "_setReadableStream",
                  value: function _setReadableStream(readableStream) {
                    var _this2 = this;
                    this._readableStream = readableStream;
                    readableStream.on("readable", function() {
                      _this2._readCapability.resolve();
                    });
                    readableStream.on("end", function() {
                      readableStream.destroy();
                      _this2._done = true;
                      _this2._readCapability.resolve();
                    });
                    readableStream.on("error", function(reason) {
                      _this2._error(reason);
                    });
                    if (this._storedError) {
                      this._readableStream.destroy(this._storedError);
                    }
                  }
                }]);
                return BaseRangeReader2;
              }();
              function createRequestOptions(parsedUrl, headers) {
                return {
                  protocol: parsedUrl.protocol,
                  auth: parsedUrl.auth,
                  host: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: "GET",
                  headers
                };
              }
              var PDFNodeStreamFullReader = /* @__PURE__ */ function(_BaseFullReader) {
                _inherits(PDFNodeStreamFullReader2, _BaseFullReader);
                var _super = _createSuper(PDFNodeStreamFullReader2);
                function PDFNodeStreamFullReader2(stream) {
                  var _this3;
                  _classCallCheck2(this, PDFNodeStreamFullReader2);
                  _this3 = _super.call(this, stream);
                  var handleResponse = function handleResponse2(response) {
                    if (response.statusCode === 404) {
                      var error = new _util2.MissingPDFException('Missing PDF "'.concat(_this3._url, '".'));
                      _this3._storedError = error;
                      _this3._headersCapability.reject(error);
                      return;
                    }
                    _this3._headersCapability.resolve();
                    _this3._setReadableStream(response);
                    var getResponseHeader = function getResponseHeader2(name) {
                      return _this3._readableStream.headers[name.toLowerCase()];
                    };
                    var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: stream.isHttp,
                      rangeChunkSize: _this3._rangeChunkSize,
                      disableRange: _this3._disableRange
                    }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                    _this3._isRangeSupported = allowRangeRequests;
                    _this3._contentLength = suggestedLength || _this3._contentLength;
                    _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  };
                  _this3._request = null;
                  if (_this3._url.protocol === "http:") {
                    _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
                  } else {
                    _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
                  }
                  _this3._request.on("error", function(reason) {
                    _this3._storedError = reason;
                    _this3._headersCapability.reject(reason);
                  });
                  _this3._request.end();
                  return _this3;
                }
                return _createClass2(PDFNodeStreamFullReader2);
              }(BaseFullReader);
              var PDFNodeStreamRangeReader = /* @__PURE__ */ function(_BaseRangeReader) {
                _inherits(PDFNodeStreamRangeReader2, _BaseRangeReader);
                var _super2 = _createSuper(PDFNodeStreamRangeReader2);
                function PDFNodeStreamRangeReader2(stream, start, end) {
                  var _this4;
                  _classCallCheck2(this, PDFNodeStreamRangeReader2);
                  _this4 = _super2.call(this, stream);
                  _this4._httpHeaders = {};
                  for (var property in stream.httpHeaders) {
                    var value = stream.httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    _this4._httpHeaders[property] = value;
                  }
                  _this4._httpHeaders.Range = "bytes=".concat(start, "-").concat(end - 1);
                  var handleResponse = function handleResponse2(response) {
                    if (response.statusCode === 404) {
                      var error = new _util2.MissingPDFException('Missing PDF "'.concat(_this4._url, '".'));
                      _this4._storedError = error;
                      return;
                    }
                    _this4._setReadableStream(response);
                  };
                  _this4._request = null;
                  if (_this4._url.protocol === "http:") {
                    _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
                  } else {
                    _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
                  }
                  _this4._request.on("error", function(reason) {
                    _this4._storedError = reason;
                  });
                  _this4._request.end();
                  return _this4;
                }
                return _createClass2(PDFNodeStreamRangeReader2);
              }(BaseRangeReader);
              var PDFNodeStreamFsFullReader = /* @__PURE__ */ function(_BaseFullReader2) {
                _inherits(PDFNodeStreamFsFullReader2, _BaseFullReader2);
                var _super3 = _createSuper(PDFNodeStreamFsFullReader2);
                function PDFNodeStreamFsFullReader2(stream) {
                  var _this5;
                  _classCallCheck2(this, PDFNodeStreamFsFullReader2);
                  _this5 = _super3.call(this, stream);
                  var path = decodeURIComponent(_this5._url.path);
                  if (fileUriRegex.test(_this5._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  fs.lstat(path, function(error, stat) {
                    if (error) {
                      if (error.code === "ENOENT") {
                        error = new _util2.MissingPDFException('Missing PDF "'.concat(path, '".'));
                      }
                      _this5._storedError = error;
                      _this5._headersCapability.reject(error);
                      return;
                    }
                    _this5._contentLength = stat.size;
                    _this5._setReadableStream(fs.createReadStream(path));
                    _this5._headersCapability.resolve();
                  });
                  return _this5;
                }
                return _createClass2(PDFNodeStreamFsFullReader2);
              }(BaseFullReader);
              var PDFNodeStreamFsRangeReader = /* @__PURE__ */ function(_BaseRangeReader2) {
                _inherits(PDFNodeStreamFsRangeReader2, _BaseRangeReader2);
                var _super4 = _createSuper(PDFNodeStreamFsRangeReader2);
                function PDFNodeStreamFsRangeReader2(stream, start, end) {
                  var _this6;
                  _classCallCheck2(this, PDFNodeStreamFsRangeReader2);
                  _this6 = _super4.call(this, stream);
                  var path = decodeURIComponent(_this6._url.path);
                  if (fileUriRegex.test(_this6._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  _this6._setReadableStream(fs.createReadStream(path, {
                    start,
                    end: end - 1
                  }));
                  return _this6;
                }
                return _createClass2(PDFNodeStreamFsRangeReader2);
              }(BaseRangeReader);
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createResponseStatusError = createResponseStatusError;
              exports2.extractFilenameFromHeader = extractFilenameFromHeader;
              exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
              exports2.validateResponseStatus = validateResponseStatus;
              var _util2 = __w_pdfjs_require__2(1);
              var _content_disposition = __w_pdfjs_require__2(180);
              var _display_utils2 = __w_pdfjs_require__2(158);
              function validateRangeRequestCapabilities(_ref) {
                var getResponseHeader = _ref.getResponseHeader, isHttp = _ref.isHttp, rangeChunkSize = _ref.rangeChunkSize, disableRange = _ref.disableRange;
                var returnValues = {
                  allowRangeRequests: false,
                  suggestedLength: void 0
                };
                var length = parseInt(getResponseHeader("Content-Length"), 10);
                if (!Number.isInteger(length)) {
                  return returnValues;
                }
                returnValues.suggestedLength = length;
                if (length <= 2 * rangeChunkSize) {
                  return returnValues;
                }
                if (disableRange || !isHttp) {
                  return returnValues;
                }
                if (getResponseHeader("Accept-Ranges") !== "bytes") {
                  return returnValues;
                }
                var contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                if (contentEncoding !== "identity") {
                  return returnValues;
                }
                returnValues.allowRangeRequests = true;
                return returnValues;
              }
              function extractFilenameFromHeader(getResponseHeader) {
                var contentDisposition = getResponseHeader("Content-Disposition");
                if (contentDisposition) {
                  var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                  if (filename.includes("%")) {
                    try {
                      filename = decodeURIComponent(filename);
                    } catch (ex) {
                    }
                  }
                  if ((0, _display_utils2.isPdfFile)(filename)) {
                    return filename;
                  }
                }
                return null;
              }
              function createResponseStatusError(status, url) {
                if (status === 404 || status === 0 && url.startsWith("file:")) {
                  return new _util2.MissingPDFException('Missing PDF "' + url + '".');
                }
                return new _util2.UnexpectedResponseException("Unexpected server response (".concat(status, ') while retrieving PDF "').concat(url, '".'), status);
              }
              function validateResponseStatus(status) {
                return status === 200 || status === 206;
              }
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
              var _util2 = __w_pdfjs_require__2(1);
              function _slicedToArray2(arr, i) {
                return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
              }
              function _nonIterableRest2() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _iterableToArrayLimit2(arr, i) {
                var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
                if (_i == null)
                  return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _s, _e;
                try {
                  for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"] != null)
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              function _arrayWithHoles2(arr) {
                if (Array.isArray(arr))
                  return arr;
              }
              function getFilenameFromContentDispositionHeader(contentDisposition) {
                var needsEncodingFixup = true;
                var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  var filename = rfc2616unquote(tmp);
                  filename = unescape(filename);
                  filename = rfc5987decode(filename);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                tmp = rfc2231getparam(contentDisposition);
                if (tmp) {
                  var _filename = rfc2047decode(tmp);
                  return fixupEncoding(_filename);
                }
                tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  var _filename2 = rfc2616unquote(tmp);
                  _filename2 = rfc2047decode(_filename2);
                  return fixupEncoding(_filename2);
                }
                function toParamRegExp(attributePattern, flags) {
                  return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                }
                function textdecode(encoding, value) {
                  if (encoding) {
                    if (!/^[\x00-\xFF]+$/.test(value)) {
                      return value;
                    }
                    try {
                      var decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      var buffer = (0, _util2.stringToBytes)(value);
                      value = decoder.decode(buffer);
                      needsEncodingFixup = false;
                    } catch (e) {
                    }
                  }
                  return value;
                }
                function fixupEncoding(value) {
                  if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                    value = textdecode("utf-8", value);
                    if (needsEncodingFixup) {
                      value = textdecode("iso-8859-1", value);
                    }
                  }
                  return value;
                }
                function rfc2231getparam(contentDispositionStr) {
                  var matches = [];
                  var match;
                  var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                  while ((match = iter.exec(contentDispositionStr)) !== null) {
                    var _match = match, _match2 = _slicedToArray2(_match, 4), n = _match2[1], quot = _match2[2], part = _match2[3];
                    n = parseInt(n, 10);
                    if (n in matches) {
                      if (n === 0) {
                        break;
                      }
                      continue;
                    }
                    matches[n] = [quot, part];
                  }
                  var parts = [];
                  for (var _n2 = 0; _n2 < matches.length; ++_n2) {
                    if (!(_n2 in matches)) {
                      break;
                    }
                    var _matches$_n = _slicedToArray2(matches[_n2], 2), _quot = _matches$_n[0], _part = _matches$_n[1];
                    _part = rfc2616unquote(_part);
                    if (_quot) {
                      _part = unescape(_part);
                      if (_n2 === 0) {
                        _part = rfc5987decode(_part);
                      }
                    }
                    parts.push(_part);
                  }
                  return parts.join("");
                }
                function rfc2616unquote(value) {
                  if (value.startsWith('"')) {
                    var parts = value.slice(1).split('\\"');
                    for (var i = 0; i < parts.length; ++i) {
                      var quotindex = parts[i].indexOf('"');
                      if (quotindex !== -1) {
                        parts[i] = parts[i].slice(0, quotindex);
                        parts.length = i + 1;
                      }
                      parts[i] = parts[i].replace(/\\(.)/g, "$1");
                    }
                    value = parts.join('"');
                  }
                  return value;
                }
                function rfc5987decode(extvalue) {
                  var encodingend = extvalue.indexOf("'");
                  if (encodingend === -1) {
                    return extvalue;
                  }
                  var encoding = extvalue.slice(0, encodingend);
                  var langvalue = extvalue.slice(encodingend + 1);
                  var value = langvalue.replace(/^[^']*'/, "");
                  return textdecode(encoding, value);
                }
                function rfc2047decode(value) {
                  if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                    return value;
                  }
                  return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                    if (encoding === "q" || encoding === "Q") {
                      text = text.replace(/_/g, " ");
                      text = text.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                        return String.fromCharCode(parseInt(hex, 16));
                      });
                      return textdecode(charset, text);
                    }
                    try {
                      text = atob(text);
                    } catch (e) {
                    }
                    return textdecode(charset, text);
                  });
                }
                return "";
              }
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNetworkStream = void 0;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(179);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              ;
              var OK_RESPONSE = 200;
              var PARTIAL_CONTENT_RESPONSE = 206;
              function getArrayBuffer(xhr) {
                var data = xhr.response;
                if (typeof data !== "string") {
                  return data;
                }
                var array = (0, _util2.stringToBytes)(data);
                return array.buffer;
              }
              var NetworkManager = /* @__PURE__ */ function() {
                function NetworkManager2(url) {
                  var args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  _classCallCheck2(this, NetworkManager2);
                  this.url = url;
                  this.isHttp = /^https?:/i.test(url);
                  this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                  this.withCredentials = args.withCredentials || false;
                  this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                    return new XMLHttpRequest();
                  };
                  this.currXhrId = 0;
                  this.pendingRequests = /* @__PURE__ */ Object.create(null);
                }
                _createClass2(NetworkManager2, [{
                  key: "requestRange",
                  value: function requestRange(begin, end, listeners) {
                    var args = {
                      begin,
                      end
                    };
                    for (var prop in listeners) {
                      args[prop] = listeners[prop];
                    }
                    return this.request(args);
                  }
                }, {
                  key: "requestFull",
                  value: function requestFull(listeners) {
                    return this.request(listeners);
                  }
                }, {
                  key: "request",
                  value: function request(args) {
                    var xhr = this.getXhr();
                    var xhrId = this.currXhrId++;
                    var pendingRequest = this.pendingRequests[xhrId] = {
                      xhr
                    };
                    xhr.open("GET", this.url);
                    xhr.withCredentials = this.withCredentials;
                    for (var property in this.httpHeaders) {
                      var value = this.httpHeaders[property];
                      if (typeof value === "undefined") {
                        continue;
                      }
                      xhr.setRequestHeader(property, value);
                    }
                    if (this.isHttp && "begin" in args && "end" in args) {
                      xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
                      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                    } else {
                      pendingRequest.expectedStatus = OK_RESPONSE;
                    }
                    xhr.responseType = "arraybuffer";
                    if (args.onError) {
                      xhr.onerror = function(evt) {
                        args.onError(xhr.status);
                      };
                    }
                    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                    xhr.onprogress = this.onProgress.bind(this, xhrId);
                    pendingRequest.onHeadersReceived = args.onHeadersReceived;
                    pendingRequest.onDone = args.onDone;
                    pendingRequest.onError = args.onError;
                    pendingRequest.onProgress = args.onProgress;
                    xhr.send(null);
                    return xhrId;
                  }
                }, {
                  key: "onProgress",
                  value: function onProgress(xhrId, evt) {
                    var _pendingRequest$onPro;
                    var pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                      return;
                    }
                    (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);
                  }
                }, {
                  key: "onStateChange",
                  value: function onStateChange(xhrId, evt) {
                    var pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                      return;
                    }
                    var xhr = pendingRequest.xhr;
                    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                      pendingRequest.onHeadersReceived();
                      delete pendingRequest.onHeadersReceived;
                    }
                    if (xhr.readyState !== 4) {
                      return;
                    }
                    if (!(xhrId in this.pendingRequests)) {
                      return;
                    }
                    delete this.pendingRequests[xhrId];
                    if (xhr.status === 0 && this.isHttp) {
                      var _pendingRequest$onErr;
                      (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);
                      return;
                    }
                    var xhrStatus = xhr.status || OK_RESPONSE;
                    var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                      var _pendingRequest$onErr2;
                      (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);
                      return;
                    }
                    var chunk = getArrayBuffer(xhr);
                    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                      var rangeHeader = xhr.getResponseHeader("Content-Range");
                      var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                      pendingRequest.onDone({
                        begin: parseInt(matches[1], 10),
                        chunk
                      });
                    } else if (chunk) {
                      pendingRequest.onDone({
                        begin: 0,
                        chunk
                      });
                    } else {
                      var _pendingRequest$onErr3;
                      (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);
                    }
                  }
                }, {
                  key: "getRequestXhr",
                  value: function getRequestXhr(xhrId) {
                    return this.pendingRequests[xhrId].xhr;
                  }
                }, {
                  key: "isPendingRequest",
                  value: function isPendingRequest(xhrId) {
                    return xhrId in this.pendingRequests;
                  }
                }, {
                  key: "abortRequest",
                  value: function abortRequest(xhrId) {
                    var xhr = this.pendingRequests[xhrId].xhr;
                    delete this.pendingRequests[xhrId];
                    xhr.abort();
                  }
                }]);
                return NetworkManager2;
              }();
              var PDFNetworkStream = /* @__PURE__ */ function() {
                function PDFNetworkStream2(source) {
                  _classCallCheck2(this, PDFNetworkStream2);
                  this._source = source;
                  this._manager = new NetworkManager(source.url, {
                    httpHeaders: source.httpHeaders,
                    withCredentials: source.withCredentials
                  });
                  this._rangeChunkSize = source.rangeChunkSize;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _createClass2(PDFNetworkStream2, [{
                  key: "_onRangeRequestReaderClosed",
                  value: function _onRangeRequestReaderClosed(reader) {
                    var i = this._rangeRequestReaders.indexOf(reader);
                    if (i >= 0) {
                      this._rangeRequestReaders.splice(i, 1);
                    }
                  }
                }, {
                  key: "getFullReader",
                  value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                    return this._fullRequestReader;
                  }
                }, {
                  key: "getRangeReader",
                  value: function getRangeReader(begin, end) {
                    var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                    this._rangeRequestReaders.push(reader);
                    return reader;
                  }
                }, {
                  key: "cancelAllRequests",
                  value: function cancelAllRequests(reason) {
                    var _this$_fullRequestRea;
                    (_this$_fullRequestRea = this._fullRequestReader) === null || _this$_fullRequestRea === void 0 ? void 0 : _this$_fullRequestRea.cancel(reason);
                    var _iterator = _createForOfIteratorHelper2(this._rangeRequestReaders.slice(0)), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var reader = _step.value;
                        reader.cancel(reason);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  }
                }]);
                return PDFNetworkStream2;
              }();
              exports2.PDFNetworkStream = PDFNetworkStream;
              var PDFNetworkStreamFullRequestReader = /* @__PURE__ */ function() {
                function PDFNetworkStreamFullRequestReader2(manager, source) {
                  _classCallCheck2(this, PDFNetworkStreamFullRequestReader2);
                  this._manager = manager;
                  var args = {
                    onHeadersReceived: this._onHeadersReceived.bind(this),
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = source.url;
                  this._fullRequestId = manager.requestFull(args);
                  this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._contentLength = source.length;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = false;
                  this._isRangeSupported = false;
                  this._cachedChunks = [];
                  this._requests = [];
                  this._done = false;
                  this._storedError = void 0;
                  this._filename = null;
                  this.onProgress = null;
                }
                _createClass2(PDFNetworkStreamFullRequestReader2, [{
                  key: "_onHeadersReceived",
                  value: function _onHeadersReceived() {
                    var fullRequestXhrId = this._fullRequestId;
                    var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                    var getResponseHeader = function getResponseHeader2(name) {
                      return fullRequestXhr.getResponseHeader(name);
                    };
                    var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._manager.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                    if (allowRangeRequests) {
                      this._isRangeSupported = true;
                    }
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (this._isRangeSupported) {
                      this._manager.abortRequest(fullRequestXhrId);
                    }
                    this._headersReceivedCapability.resolve();
                  }
                }, {
                  key: "_onDone",
                  value: function _onDone(data) {
                    if (data) {
                      if (this._requests.length > 0) {
                        var requestCapability = this._requests.shift();
                        requestCapability.resolve({
                          value: data.chunk,
                          done: false
                        });
                      } else {
                        this._cachedChunks.push(data.chunk);
                      }
                    }
                    this._done = true;
                    if (this._cachedChunks.length > 0) {
                      return;
                    }
                    var _iterator2 = _createForOfIteratorHelper2(this._requests), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var _requestCapability = _step2.value;
                        _requestCapability.resolve({
                          value: void 0,
                          done: true
                        });
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    this._requests.length = 0;
                  }
                }, {
                  key: "_onError",
                  value: function _onError(status) {
                    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                    this._headersReceivedCapability.reject(this._storedError);
                    var _iterator3 = _createForOfIteratorHelper2(this._requests), _step3;
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                        var requestCapability = _step3.value;
                        requestCapability.reject(this._storedError);
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                    this._requests.length = 0;
                    this._cachedChunks.length = 0;
                  }
                }, {
                  key: "_onProgress",
                  value: function _onProgress(evt) {
                    var _this$onProgress;
                    (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {
                      loaded: evt.loaded,
                      total: evt.lengthComputable ? evt.total : this._contentLength
                    });
                  }
                }, {
                  key: "filename",
                  get: function get2() {
                    return this._filename;
                  }
                }, {
                  key: "isRangeSupported",
                  get: function get2() {
                    return this._isRangeSupported;
                  }
                }, {
                  key: "isStreamingSupported",
                  get: function get2() {
                    return this._isStreamingSupported;
                  }
                }, {
                  key: "contentLength",
                  get: function get2() {
                    return this._contentLength;
                  }
                }, {
                  key: "headersReady",
                  get: function get2() {
                    return this._headersReceivedCapability.promise;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              if (!this._storedError) {
                                _context.next = 2;
                                break;
                              }
                              throw this._storedError;
                            case 2:
                              if (!(this._cachedChunks.length > 0)) {
                                _context.next = 5;
                                break;
                              }
                              chunk = this._cachedChunks.shift();
                              return _context.abrupt("return", {
                                value: chunk,
                                done: false
                              });
                            case 5:
                              if (!this._done) {
                                _context.next = 7;
                                break;
                              }
                              return _context.abrupt("return", {
                                value: void 0,
                                done: true
                              });
                            case 7:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context.abrupt("return", requestCapability.promise);
                            case 10:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    this._done = true;
                    this._headersReceivedCapability.reject(reason);
                    var _iterator4 = _createForOfIteratorHelper2(this._requests), _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                        var requestCapability = _step4.value;
                        requestCapability.resolve({
                          value: void 0,
                          done: true
                        });
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    this._requests.length = 0;
                    if (this._manager.isPendingRequest(this._fullRequestId)) {
                      this._manager.abortRequest(this._fullRequestId);
                    }
                    this._fullRequestReader = null;
                  }
                }]);
                return PDFNetworkStreamFullRequestReader2;
              }();
              var PDFNetworkStreamRangeRequestReader = /* @__PURE__ */ function() {
                function PDFNetworkStreamRangeRequestReader2(manager, begin, end) {
                  _classCallCheck2(this, PDFNetworkStreamRangeRequestReader2);
                  this._manager = manager;
                  var args = {
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = manager.url;
                  this._requestId = manager.requestRange(begin, end, args);
                  this._requests = [];
                  this._queuedChunk = null;
                  this._done = false;
                  this._storedError = void 0;
                  this.onProgress = null;
                  this.onClosed = null;
                }
                _createClass2(PDFNetworkStreamRangeRequestReader2, [{
                  key: "_close",
                  value: function _close() {
                    var _this$onClosed;
                    (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);
                  }
                }, {
                  key: "_onDone",
                  value: function _onDone(data) {
                    var chunk = data.chunk;
                    if (this._requests.length > 0) {
                      var requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: chunk,
                        done: false
                      });
                    } else {
                      this._queuedChunk = chunk;
                    }
                    this._done = true;
                    var _iterator5 = _createForOfIteratorHelper2(this._requests), _step5;
                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                        var _requestCapability2 = _step5.value;
                        _requestCapability2.resolve({
                          value: void 0,
                          done: true
                        });
                      }
                    } catch (err) {
                      _iterator5.e(err);
                    } finally {
                      _iterator5.f();
                    }
                    this._requests.length = 0;
                    this._close();
                  }
                }, {
                  key: "_onError",
                  value: function _onError(status) {
                    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                    var _iterator6 = _createForOfIteratorHelper2(this._requests), _step6;
                    try {
                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                        var requestCapability = _step6.value;
                        requestCapability.reject(this._storedError);
                      }
                    } catch (err) {
                      _iterator6.e(err);
                    } finally {
                      _iterator6.f();
                    }
                    this._requests.length = 0;
                    this._queuedChunk = null;
                  }
                }, {
                  key: "_onProgress",
                  value: function _onProgress(evt) {
                    if (!this.isStreamingSupported) {
                      var _this$onProgress2;
                      (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {
                        loaded: evt.loaded
                      });
                    }
                  }
                }, {
                  key: "isStreamingSupported",
                  get: function get2() {
                    return false;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!this._storedError) {
                                _context2.next = 2;
                                break;
                              }
                              throw this._storedError;
                            case 2:
                              if (!(this._queuedChunk !== null)) {
                                _context2.next = 6;
                                break;
                              }
                              chunk = this._queuedChunk;
                              this._queuedChunk = null;
                              return _context2.abrupt("return", {
                                value: chunk,
                                done: false
                              });
                            case 6:
                              if (!this._done) {
                                _context2.next = 8;
                                break;
                              }
                              return _context2.abrupt("return", {
                                value: void 0,
                                done: true
                              });
                            case 8:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context2.abrupt("return", requestCapability.promise);
                            case 11:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    this._done = true;
                    var _iterator7 = _createForOfIteratorHelper2(this._requests), _step7;
                    try {
                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                        var requestCapability = _step7.value;
                        requestCapability.resolve({
                          value: void 0,
                          done: true
                        });
                      }
                    } catch (err) {
                      _iterator7.e(err);
                    } finally {
                      _iterator7.f();
                    }
                    this._requests.length = 0;
                    if (this._manager.isPendingRequest(this._requestId)) {
                      this._manager.abortRequest(this._requestId);
                    }
                    this._close();
                  }
                }]);
                return PDFNetworkStreamRangeRequestReader2;
              }();
            },
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFetchStream = void 0;
              var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(156));
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(179);
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  Promise.resolve(value).then(_next, _throw);
                }
              }
              function _asyncToGenerator2(fn) {
                return function() {
                  var self2 = this, args = arguments;
                  return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self2, args);
                    function _next(value) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                      asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                  });
                };
              }
              function _createForOfIteratorHelper2(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    var F = function F2() {
                    };
                    return { s: F, n: function n() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    }, e: function e(_e) {
                      throw _e;
                    }, f: F };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return { s: function s() {
                  it = it.call(o);
                }, n: function n() {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                }, e: function e(_e2) {
                  didErr = true;
                  err = _e2;
                }, f: function f() {
                  try {
                    if (!normalCompletion && it["return"] != null)
                      it["return"]();
                  } finally {
                    if (didErr)
                      throw err;
                  }
                } };
              }
              function _unsupportedIterableToArray2(o, minLen) {
                if (!o)
                  return;
                if (typeof o === "string")
                  return _arrayLikeToArray2(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                  n = o.constructor.name;
                if (n === "Map" || n === "Set")
                  return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                  return _arrayLikeToArray2(o, minLen);
              }
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              }
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties2(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              ;
              function createFetchOptions(headers, withCredentials, abortController) {
                return {
                  method: "GET",
                  headers,
                  signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
                  mode: "cors",
                  credentials: withCredentials ? "include" : "same-origin",
                  redirect: "follow"
                };
              }
              function createHeaders(httpHeaders) {
                var headers = new Headers();
                for (var property in httpHeaders) {
                  var value = httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  headers.append(property, value);
                }
                return headers;
              }
              var PDFFetchStream = /* @__PURE__ */ function() {
                function PDFFetchStream2(source) {
                  _classCallCheck2(this, PDFFetchStream2);
                  this.source = source;
                  this.isHttp = /^https?:/i.test(source.url);
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _createClass2(PDFFetchStream2, [{
                  key: "_progressiveDataLength",
                  get: function get2() {
                    var _this$_fullRequestRea, _this$_fullRequestRea2;
                    return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                  }
                }, {
                  key: "getFullReader",
                  value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                    this._fullRequestReader = new PDFFetchStreamReader(this);
                    return this._fullRequestReader;
                  }
                }, {
                  key: "getRangeReader",
                  value: function getRangeReader(begin, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    var reader = new PDFFetchStreamRangeReader(this, begin, end);
                    this._rangeRequestReaders.push(reader);
                    return reader;
                  }
                }, {
                  key: "cancelAllRequests",
                  value: function cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    var _iterator = _createForOfIteratorHelper2(this._rangeRequestReaders.slice(0)), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var reader = _step.value;
                        reader.cancel(reason);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  }
                }]);
                return PDFFetchStream2;
              }();
              exports2.PDFFetchStream = PDFFetchStream;
              var PDFFetchStreamReader = /* @__PURE__ */ function() {
                function PDFFetchStreamReader2(stream) {
                  var _this = this;
                  _classCallCheck2(this, PDFFetchStreamReader2);
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  this._filename = null;
                  var source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._contentLength = source.length;
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  if (typeof AbortController !== "undefined") {
                    this._abortController = new AbortController();
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._headers = createHeaders(this._stream.httpHeaders);
                  var url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    _this._reader = response.body.getReader();
                    _this._headersCapability.resolve();
                    var getResponseHeader = function getResponseHeader2(name) {
                      return response.headers.get(name);
                    };
                    var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: _this._stream.isHttp,
                      rangeChunkSize: _this._rangeChunkSize,
                      disableRange: _this._disableRange
                    }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                    _this._isRangeSupported = allowRangeRequests;
                    _this._contentLength = suggestedLength || _this._contentLength;
                    _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (!_this._isStreamingSupported && _this._isRangeSupported) {
                      _this.cancel(new _util2.AbortException("Streaming is disabled."));
                    }
                  })["catch"](this._headersCapability.reject);
                  this.onProgress = null;
                }
                _createClass2(PDFFetchStreamReader2, [{
                  key: "headersReady",
                  get: function get2() {
                    return this._headersCapability.promise;
                  }
                }, {
                  key: "filename",
                  get: function get2() {
                    return this._filename;
                  }
                }, {
                  key: "contentLength",
                  get: function get2() {
                    return this._contentLength;
                  }
                }, {
                  key: "isRangeSupported",
                  get: function get2() {
                    return this._isRangeSupported;
                  }
                }, {
                  key: "isStreamingSupported",
                  get: function get2() {
                    return this._isStreamingSupported;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee() {
                      var _yield$this$_reader$r, value, done, buffer;
                      return _regenerator2["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _context.next = 2;
                              return this._headersCapability.promise;
                            case 2:
                              _context.next = 4;
                              return this._reader.read();
                            case 4:
                              _yield$this$_reader$r = _context.sent;
                              value = _yield$this$_reader$r.value;
                              done = _yield$this$_reader$r.done;
                              if (!done) {
                                _context.next = 9;
                                break;
                              }
                              return _context.abrupt("return", {
                                value,
                                done
                              });
                            case 9:
                              this._loaded += value.byteLength;
                              if (this.onProgress) {
                                this.onProgress({
                                  loaded: this._loaded,
                                  total: this._contentLength
                                });
                              }
                              buffer = new Uint8Array(value).buffer;
                              return _context.abrupt("return", {
                                value: buffer,
                                done: false
                              });
                            case 13:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    if (this._reader) {
                      this._reader.cancel(reason);
                    }
                    if (this._abortController) {
                      this._abortController.abort();
                    }
                  }
                }]);
                return PDFFetchStreamReader2;
              }();
              var PDFFetchStreamRangeReader = /* @__PURE__ */ function() {
                function PDFFetchStreamRangeReader2(stream, begin, end) {
                  var _this2 = this;
                  _classCallCheck2(this, PDFFetchStreamRangeReader2);
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  var source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._isStreamingSupported = !source.disableStream;
                  if (typeof AbortController !== "undefined") {
                    this._abortController = new AbortController();
                  }
                  this._headers = createHeaders(this._stream.httpHeaders);
                  this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));
                  var url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    _this2._readCapability.resolve();
                    _this2._reader = response.body.getReader();
                  })["catch"](this._readCapability.reject);
                  this.onProgress = null;
                }
                _createClass2(PDFFetchStreamRangeReader2, [{
                  key: "isStreamingSupported",
                  get: function get2() {
                    return this._isStreamingSupported;
                  }
                }, {
                  key: "read",
                  value: function() {
                    var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                      var _yield$this$_reader$r2, value, done, buffer;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return this._readCapability.promise;
                            case 2:
                              _context2.next = 4;
                              return this._reader.read();
                            case 4:
                              _yield$this$_reader$r2 = _context2.sent;
                              value = _yield$this$_reader$r2.value;
                              done = _yield$this$_reader$r2.done;
                              if (!done) {
                                _context2.next = 9;
                                break;
                              }
                              return _context2.abrupt("return", {
                                value,
                                done
                              });
                            case 9:
                              this._loaded += value.byteLength;
                              if (this.onProgress) {
                                this.onProgress({
                                  loaded: this._loaded
                                });
                              }
                              buffer = new Uint8Array(value).buffer;
                              return _context2.abrupt("return", {
                                value: buffer,
                                done: false
                              });
                            case 13:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }()
                }, {
                  key: "cancel",
                  value: function cancel(reason) {
                    if (this._reader) {
                      this._reader.cancel(reason);
                    }
                    if (this._abortController) {
                      this._abortController.abort();
                    }
                  }
                }]);
                return PDFFetchStreamRangeReader2;
              }();
            }
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              id: moduleId,
              loaded: false,
              exports: {}
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            module2.loaded = true;
            return module2.exports;
          }
          (() => {
            __w_pdfjs_require__.nmd = (module2) => {
              module2.paths = [];
              if (!module2.children)
                module2.children = [];
              return module2;
            };
          })();
          var __webpack_exports__ = {};
          (() => {
            "use strict";
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AnnotationLayer", {
              enumerable: true,
              get: function get2() {
                return _annotation_layer.AnnotationLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationMode", {
              enumerable: true,
              get: function get2() {
                return _util2.AnnotationMode;
              }
            });
            Object.defineProperty(exports2, "CMapCompressionType", {
              enumerable: true,
              get: function get2() {
                return _util2.CMapCompressionType;
              }
            });
            Object.defineProperty(exports2, "GlobalWorkerOptions", {
              enumerable: true,
              get: function get2() {
                return _worker_options2.GlobalWorkerOptions;
              }
            });
            Object.defineProperty(exports2, "InvalidPDFException", {
              enumerable: true,
              get: function get2() {
                return _util2.InvalidPDFException;
              }
            });
            Object.defineProperty(exports2, "LoopbackPort", {
              enumerable: true,
              get: function get2() {
                return _api.LoopbackPort;
              }
            });
            Object.defineProperty(exports2, "MissingPDFException", {
              enumerable: true,
              get: function get2() {
                return _util2.MissingPDFException;
              }
            });
            Object.defineProperty(exports2, "OPS", {
              enumerable: true,
              get: function get2() {
                return _util2.OPS;
              }
            });
            Object.defineProperty(exports2, "PDFDataRangeTransport", {
              enumerable: true,
              get: function get2() {
                return _api.PDFDataRangeTransport;
              }
            });
            Object.defineProperty(exports2, "PDFDateString", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.PDFDateString;
              }
            });
            Object.defineProperty(exports2, "PDFWorker", {
              enumerable: true,
              get: function get2() {
                return _api.PDFWorker;
              }
            });
            Object.defineProperty(exports2, "PasswordResponses", {
              enumerable: true,
              get: function get2() {
                return _util2.PasswordResponses;
              }
            });
            Object.defineProperty(exports2, "PermissionFlag", {
              enumerable: true,
              get: function get2() {
                return _util2.PermissionFlag;
              }
            });
            Object.defineProperty(exports2, "PixelsPerInch", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.PixelsPerInch;
              }
            });
            Object.defineProperty(exports2, "RenderingCancelledException", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.RenderingCancelledException;
              }
            });
            Object.defineProperty(exports2, "SVGGraphics", {
              enumerable: true,
              get: function get2() {
                return _svg.SVGGraphics;
              }
            });
            Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
              enumerable: true,
              get: function get2() {
                return _util2.UNSUPPORTED_FEATURES;
              }
            });
            Object.defineProperty(exports2, "UnexpectedResponseException", {
              enumerable: true,
              get: function get2() {
                return _util2.UnexpectedResponseException;
              }
            });
            Object.defineProperty(exports2, "Util", {
              enumerable: true,
              get: function get2() {
                return _util2.Util;
              }
            });
            Object.defineProperty(exports2, "VerbosityLevel", {
              enumerable: true,
              get: function get2() {
                return _util2.VerbosityLevel;
              }
            });
            Object.defineProperty(exports2, "XfaLayer", {
              enumerable: true,
              get: function get2() {
                return _xfa_layer.XfaLayer;
              }
            });
            Object.defineProperty(exports2, "build", {
              enumerable: true,
              get: function get2() {
                return _api.build;
              }
            });
            Object.defineProperty(exports2, "createPromiseCapability", {
              enumerable: true,
              get: function get2() {
                return _util2.createPromiseCapability;
              }
            });
            Object.defineProperty(exports2, "createValidAbsoluteUrl", {
              enumerable: true,
              get: function get2() {
                return _util2.createValidAbsoluteUrl;
              }
            });
            Object.defineProperty(exports2, "getDocument", {
              enumerable: true,
              get: function get2() {
                return _api.getDocument;
              }
            });
            Object.defineProperty(exports2, "getFilenameFromUrl", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.getFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.getPdfFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getXfaPageViewport", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.getXfaPageViewport;
              }
            });
            Object.defineProperty(exports2, "isPdfFile", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.isPdfFile;
              }
            });
            Object.defineProperty(exports2, "loadScript", {
              enumerable: true,
              get: function get2() {
                return _display_utils2.loadScript;
              }
            });
            Object.defineProperty(exports2, "renderTextLayer", {
              enumerable: true,
              get: function get2() {
                return _text_layer.renderTextLayer;
              }
            });
            Object.defineProperty(exports2, "shadow", {
              enumerable: true,
              get: function get2() {
                return _util2.shadow;
              }
            });
            Object.defineProperty(exports2, "version", {
              enumerable: true,
              get: function get2() {
                return _api.version;
              }
            });
            var _util2 = __w_pdfjs_require__(1);
            var _api = __w_pdfjs_require__(155);
            var _display_utils2 = __w_pdfjs_require__(158);
            var _annotation_layer = __w_pdfjs_require__(173);
            var _worker_options2 = __w_pdfjs_require__(166);
            var _is_node2 = __w_pdfjs_require__(3);
            var _text_layer = __w_pdfjs_require__(176);
            var _svg = __w_pdfjs_require__(177);
            var _xfa_layer = __w_pdfjs_require__(175);
            var pdfjsVersion = "2.14.305";
            var pdfjsBuild = "eaaa8b4ad";
            {
              if (_is_node2.isNodeJS) {
                var _require2 = __w_pdfjs_require__(178), PDFNodeStream = _require2.PDFNodeStream;
                (0, _api.setPDFNetworkStreamFactory)(function(params) {
                  return new PDFNodeStream(params);
                });
              } else {
                var _require22 = __w_pdfjs_require__(181), PDFNetworkStream = _require22.PDFNetworkStream;
                var _require3 = __w_pdfjs_require__(182), PDFFetchStream = _require3.PDFFetchStream;
                (0, _api.setPDFNetworkStreamFactory)(function(params) {
                  if ((0, _display_utils2.isValidFetchUrl)(params.url)) {
                    return new PDFFetchStream(params);
                  }
                  return new PDFNetworkStream(params);
                });
              }
            }
          })();
          return __webpack_exports__;
        })();
      });
    }
  });

  // <stdin>
  var pdfjsLib = __toESM(require_pdf());

  // ns-params:@params
  var pdfjsWorkerUrl = "https://phelipetls.github.io/js/pdf.worker.js";

  // <stdin>
  pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorkerUrl;
  var resumeContainer = document.querySelector("[data-resume]");
  var resumeUrl = resumeContainer.dataset.resume;
  var resumeCanvas = document.querySelector("[data-resume-canvas]");
  var resumeLoading = document.querySelector("[data-resume-loading]");
  var resumeDownloadButton = document.querySelector("[data-resume-download-button]");
  resumeLoading.classList.replace("hidden", "flex");
  resumeDownloadButton.classList.replace("hidden", "flex");
  var pdfWorkerScript = document.createElement("script");
  pdfWorkerScript.src = "/js/pdf.worker.js";
  document.body.append(pdfWorkerScript);
  pdfWorkerScript.onload = function() {
    pdfjsLib.getDocument(resumeUrl).promise.then(function(pdf) {
      pdf.getPage(1).then(function(page) {
        const scale = resumeContainer.clientWidth / page.getViewport({ scale: 1 }).width;
        const viewport = page.getViewport({ scale });
        const outputScale = window.devicePixelRatio || 1;
        const context = resumeCanvas.getContext("2d");
        resumeCanvas.width = Math.floor(viewport.width * outputScale);
        resumeCanvas.height = Math.floor(viewport.height * outputScale);
        resumeCanvas.style.width = Math.floor(viewport.width) + "px";
        resumeCanvas.style.height = Math.floor(viewport.height) + "px";
        const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
        const renderContext = {
          canvasContext: context,
          transform,
          viewport
        };
        const renderTask = page.render(renderContext);
        return renderTask.promise;
      });
    }).catch(function() {
      resumeContainer.classList.add("hidden");
    }).then(function() {
      resumeCanvas.classList.remove("hidden");
      resumeLoading.classList.add("hidden");
    });
  };
})();
/*!
* DOMMatrix v1.0.3 (https://thednp.github.io/dommatrix/)
* Copyright 2022  thednp
* Licensed under MIT (https://github.com/thednp/DOMMatrix/blob/master/LICENSE)
*/
