<!doctype html><html class=h-full lang=pt-br><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Um blog para compartilhar meus interesses em programação, estatística e mais"><meta name=deploy-date content="2022-05-14"><meta name=publish-date content="2019-03-03"><meta name=last-modified-date content="2022-05-11"><meta name=author content><meta name=color-scheme content="dark light"><meta name=keywords content="numpy,linear-algebra"><style>@font-face{font-family:fira sans;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/firasans/v16/va9E4kDNxMZdWfMOD5VfkA.ttf)format('truetype')}@font-face{font-family:merriweather;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/merriweather/v30/u-440qyriQwlOrhSvowK_l5Oew.ttf)format('truetype')}</style><link rel=stylesheet href="/css/main.min.css"><link rel=stylesheet href=/css/dark-syntax-highlight.min.css><title>Três algoritmos para a sequência de Fibonacci | Phelipe Teles</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body)})</script><meta property="og:title" content="Três algoritmos para a sequência de Fibonacci"><meta property="og:description" content="A sequência de fibonacci é uma velha conhecida dos que estudam programação. Por isso, esse post não deve soar tão estimulante para pessoas que trabalham com programação há muito tempo, mas prometo que algo ainda pode ser aproveitado."><meta property="og:type" content="article"><meta property="og:url" content="https://phelipetls.github.io/pt/posts/tres-algoritmos-para-a-sequencia-de-fibonacci/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-03-03T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-11T09:25:50-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Três algoritmos para a sequência de Fibonacci"><meta name=twitter:description content="A sequência de fibonacci é uma velha conhecida dos que estudam programação. Por isso, esse post não deve soar tão estimulante para pessoas que trabalham com programação há muito tempo, mas prometo que algo ainda pode ser aproveitado."><script>!sessionStorage.getItem("_swa")&&document.referrer.indexOf(location.protocol+"//"+location.host)!==0&&fetch("https://counter.dev/track?"+new URLSearchParams({referrer:document.referrer,screen:screen.width+"x"+screen.height,user:"telesphelipe@gmail.com",utcoffset:"-3"})),sessionStorage.setItem("_swa","1")</script><link rel=stylesheet href=https://phelipetls.github.io/css/lite-yt-embed.min.css></head><body data-preload class="text-foreground bg-secondary-background transition transition-colors duration-500 ease-out"><script>function storeTheme(e){e&&localStorage.setItem("__theme",e)}function getStoredTheme(){return localStorage.getItem("__theme")}function setTheme(e){e==="auto"&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),e==="dark"?document.body.classList.add("dark"):document.body.classList.remove("dark")}function dispatchNewThemeEvent(e){const t=new CustomEvent("newTheme",{detail:{theme:e}});document.body.dispatchEvent(t)}window.__setTheme=function(e){setTheme(e),storeTheme(e),dispatchNewThemeEvent(e)};const storedTheme=getStoredTheme()||"auto";window.__setTheme(storedTheme),window.addEventListener("load",function(){document.body.removeAttribute("data-preload"),dispatchNewThemeEvent(storedTheme)})</script><div data-scroll-container><div data-nav-container class="fixed top-0 w-full h-20 bg-secondary-background z-30 transition-transform transition-duration-700 transition-ease-out"><div class="h-full pt-4 pb-4 flex items-center justify-between mx-auto max-w-5xl pr-default-padding"><nav class="h-full py-1 overflow-x-auto flex items-center px-default-padding" aria-label="Navegação principal"><ul class="m-0 list-none flex items-center flex-row flex-nowrap gap-2 h-full"><li class=h-full><a href=https://phelipetls.github.io/pt/ class="h-full
border-0
px-2
flex
relative
items-center
justify-center
rounded
overflow-hidden
after:content-['']
after:absolute
after:-z-10
after:bg-background
after:w-full
after:h-full
after:rounded-full
after:scale-0
hover:after:scale-150
after:transition-transform
after:duration-500">Sobre</a></li><li class=h-full><a href=https://phelipetls.github.io/pt/posts/ class="h-full
border-0
px-2
flex
relative
items-center
justify-center
rounded
active
bg-background
shadow-md
shadow-divider">Posts</a></li><li class=h-full><a href=https://phelipetls.github.io/pt/projects/ class="h-full
border-0
px-2
flex
relative
items-center
justify-center
rounded
overflow-hidden
after:content-['']
after:absolute
after:-z-10
after:bg-background
after:w-full
after:h-full
after:rounded-full
after:scale-0
hover:after:scale-150
after:transition-transform
after:duration-500">Projetos</a></li><li class=h-full><a href=https://phelipetls.github.io/pt/resume/ class="h-full
border-0
px-2
flex
relative
items-center
justify-center
rounded
overflow-hidden
after:content-['']
after:absolute
after:-z-10
after:bg-background
after:w-full
after:h-full
after:rounded-full
after:scale-0
hover:after:scale-150
after:transition-transform
after:duration-500">Currículo</a></li></ul></nav><div class="h-full py-1"><div class="h-full px-2 flex items-center gap-2 bg-background rounded shadow-md shadow-divider"><button data-theme-button class="btn btn-icon" aria-label="Mudar tema" aria-expanded=false aria-controls=theme-menu aria-haspopup=true><svg style="width:var(--icon-size);height:var(--icon-size)" viewBox="0 0 24 24"><title>Ícone do tema</title><defs><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg><svg id="monitor" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-monitor"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg></defs>
<use data-theme-button-svg-icon href=#sun></svg></button></div></div><ul data-theme-menu id=theme-menu class="absolute top-0 left-0 bg-background border border-divider rounded z-50 shadow-md shadow-divider/50 flex flex-col list-none m-0 text-lg" style=visibility:hidden;opacity:0;pointer-events:none;--icon-size:24px role=menu aria-orientation=vertical aria-activedescendant=theme-option-auto aria-label="Opções de tema" tabindex=-1><li class="px-2 py-1 m-0 cursor-pointer flex items-center gap-1" id=theme-option-light data-theme=light role=menuitem tabindex=-1><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>Claro</li><li class="px-2 py-1 m-0 cursor-pointer flex items-center gap-1" id=theme-option-dark data-theme=dark role=menuitem tabindex=-1><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>Escuro</li><li class="px-2 py-1 m-0 cursor-pointer flex items-center gap-1" id=theme-option-auto data-theme=auto role=menuitem tabindex=-1><svg id="monitor" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-monitor"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>Sistema</li></ul></div></div><div class="max-w-5xl mx-auto w-full px-default-padding mt-20 py-4"><main class="bg-background w-full rounded-lg shadow-md shadow-divider py-16 sm:px-16 px-default-padding"><article><header><h1 class="text-4xl mb-4">Três algoritmos para a sequência de Fibonacci</h1><div class="flex flex-col gap-2 mb-4" style=--icon-size:24px><div class="flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-book-open"><path d="M2 3h6a4 4 0 014 4v14a3 3 0 00-3-3H2z"/><path d="M22 3h-6a4 4 0 00-4 4v14a3 3 0 013-3h7z"/></svg><div>11 min.</div></div><div class="flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><time datetime=2019-03-03>3 de Março</time></div></div></header><div class=mb-4><div class="flex flex-wrap gap-2 py-2"><a href=/pt/tags/numpy/ class=tag>numpy</a>
<a href=/pt/tags/linear-algebra/ class=tag>linear-algebra</a>
<a href=/pt/tags class=tag>...</a></div></div><hr class=my-8><section data-blog-post class=max-w-prose><p><img src=./kisspng-fibonacci-number-golden-spiral-golden-ratio-mathem-spiral-5b4a12ee4a0493.6897256215315811663032.png alt=FibSeq class="rounded my-8" style=background-color:#fff></p><p>A sequência de fibonacci é uma velha conhecida dos que estudam programação. Por
isso, esse post não deve soar tão estimulante para pessoas que trabalham com
programação há muito tempo, mas prometo que algo ainda pode ser aproveitado.
Aqui pretendo mostrar três algoritmos para sequência, e todos eles foram
importantes para melhorar meu entendimento de programação.</p><p>O primeiro deles é o mais usual. O segundo é por recursão. Já o terceiro é o que
me motivou a fazer o post, nele faço uso extensivo de álgebra linear, e com isso
é possível aprender muito mais a fundo sobre a natureza desses números, por
exemplo, o que caracteriza o seu crescimento?</p><p>O primeiro eu vi pela primeira vez escrito em C++ num curso de informática que
fiz. O segundo, num curso de
<a href="https://www.youtube.com/watch?v=ytpJdnlu9ug&list=PLUl4u3cNGP63WbdFxL8giv4yhgdMGaZNA">Introdução à Ciência da Computação</a>
do MIT OpenCourseWare. E o terceiro na <a href=https://youtu.be/13r9QY6cmjc>aula 22</a>
do curso de Linear Algebra do MIT OpenCourseWare, com Gilbert Strang, cujas
aulas são masterpieces. O segredo desta maneira está em ver a sequência de
Fibonacci como um sistema de equações lineares dinâmico, que evolui no tempo. E
para entender melhor como isso funciona, precisamos introduzir o conceito de
autovalores/autovetores. Mas antes vejamos os algoritmos mais simples.</p><h2 class="mb-8 mt-8 pt-8" id=a-maneira-comum>A maneira comum
<a class="text-primary border-0 pl-2" href=#a-maneira-comum>#</a></h2><p>Apenas para recordar o que é a sequência de fibonacci: dados os dois primeiros
números da sequência (comumente 0 e 1), o próximo número é a soma dos dois que o
precedem.</p><p>$$
F_0 = 0, F_1 = 1
$$</p><p>$$
F_n = F_{n-1} + F_{n-2}
$$</p><p>Com isso em mente, podemos escrever o algoritmo que muitos já devem conhecer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>std_fib</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>  <span class=c1># tuple assignment</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>fib</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>fib</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fib</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>std_fib</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>13</span><span class=p>)]</span>
</span></span></code></pre></div><pre><code>[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]
</code></pre><p>Acredito que não muito possa ser dito sobre este algoritmo, mas é interessante
tentar escrevê-lo de um jeito mais <em>pythonic</em>.</p><p>Por exemplo, legal pontuar como atribuí os valores às variáveis. O que tá
rolando ali é chamado de tuple assignment. No Python, você pode atribuir o
conteúdo de uma lista, tuple etc. a variáveis numa única linha. Em outra
linguagem talvez precisaríamos de variáveis temporárias para isso.</p><p>Caso alguém nunca tenha visto esse algoritmo, poso explicar brevemente. Primeiro
atribuímos à variável &ldquo;a&rdquo; o valor 0, e à &ldquo;b&rdquo; o valor 1. Depois, no loop,
calculamos o número de fibonacci, que é a soma desses dois. O primeiro, então,
é 1. Em seguida, o que fazemos é atribuir à &ldquo;a&rdquo; o valor de &ldquo;b&rdquo; e à &ldquo;b&rdquo; o valor
do número de fibonacci, de forma que no próximo loop, a soma será 1 + 1, e no
próximo 1 + 2, 2 + 3 etc.</p><p>Para comparação, vamos testar sua performance em termos de eficiência.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>std_fib</span><span class=p>(</span><span class=mi>10000</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>2.46 ms ± 96.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre><h2 class="mb-8 mt-8 pt-8" id=por-recursão>Por recursão
<a class="text-primary border-0 pl-2" href=#por-recurs%c3%a3o>#</a></h2><p>Como não sou estudante de ciência da computação, esse eu conheci recentemente
até e achei maravilhoso. Ele tem a vantagem de ser bem legível, limpo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>rec_fib</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>rec_fib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>rec_fib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>rec_fib</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>13</span><span class=p>)]</span>
</span></span></code></pre></div><pre><code>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
</code></pre><p>E funciona da seguinte forma: Primeiro, temos um caso base (<em>base case</em>), em que
o valor é conhecido.</p><p>Neste caso, definimos que os números 0 e 1 da sequência de fibonacci são,
respectivamente, 0 e 1. Para todos os outros, calculamos de forma recursiva. Por
exemplo, \( F_3 = F_2 + F_1 = F_1 + F_0 + F_1 = 1 + 0 + 1 = 2 \)</p><p>E é uma boa maneira de introduzir o conceito de recursão na computação. Agora
vejamos quão eficiente ele é.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>rec_fib</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>4.81 ms ± 625 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre><p>Para calcular o vigésimo número ele demorou muito mais do que o algoritmo
anterior, que calculou um número muito maior!! Por que será que isso
aconteceu? Uma imagem pode ajudar a ilustrar o porquê disso.</p><figure><img src=./fibo.png><figcaption><h4>Fib</h4></figcaption></figure><p>O que acontece é que a função recursiva acaba requisitando os mesmos números de
fibonacci múltiplas vezes e, para números muito grandes, esse excesso de
chamadas desnecessárias prejudica muito a perfomance do algoritmo. Muito mesmo,
se você chamar a função com 60 como argumento, talvez não tenha paciência para
esperar ela terminar de calcular.</p><p>Existe um jeito bem simples de resolver esse problema, que vem da assim chamada
programação dinâmica, um conjunto de técnicas para otimização de algoritmos. A
técnica que cabe usar aqui é chamada de memoization, e consiste em &ldquo;reciclar&rdquo; os
valores que já calculamos previamente, para não precisar recalculá-los. Isso é
exatamente o que precisamos!</p><p>Agora, como poderíamos fazer isso? Um jeito bem eficiente é usar um hash table,
o que no Python é um set ou um dictionary. A vantagem dessa estrutura de dados é
que o tempo de procura independe de quantos dados armazenados você tem ali:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>ffib</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{</span><span class=mi>0</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>:</span> <span class=mi>1</span><span class=p>}):</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>  <span class=c1># tente retornar um valor no &#39;memorizador&#39;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>  <span class=c1># se não conseguir, calcule o numero</span>
</span></span><span class=line><span class=cl>        <span class=n>fib</span> <span class=o>=</span> <span class=n>ffib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>ffib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fib</span>  <span class=c1># guarde-o</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>ffib</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>178 ns ± 0.385 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>ffib</span><span class=p>(</span><span class=mi>1000</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>183 ns ± 8.12 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre><p>O que é muito mais rápido. É bem impressionante o quanto essa técnica pôde
melhorar o código. Uma coisa a se notar, no entanto, é que se você chamar a
função com 10000, pelo menos com esse código, dá &ldquo;stack overflow&rdquo;&mldr; o que eu
não esperava e honestamente nem sei por que é assim.</p><h2 class="mb-8 mt-8 pt-8" id=por-álgebra-linear>Por Álgebra Linear
<a class="text-primary border-0 pl-2" href=#por-%c3%a1lgebra-linear>#</a></h2><lite-youtube videoid=13r9QY6cmjc class="-mx-default-padding sm:mx-0"></lite-youtube><p>Finalmente, matrizes. Comecemos primeiro com a equação básica, \( F<em>n =
F</em>{n-1} + F_{n-2} \).</p><p>Mas, para termos um sistema de equações lineares, precisamos de mais uma equação
pelo menos. A escolha mais simples é: \( F*{n-1} = F*{n-1} + 0\cdot F_{n-2}
\). O que, em linguagem de matrizes, pode ser escrito como:</p><p>\[ \begin{bmatrix}F_{n} \\ F_{n-1}\end{bmatrix} = \begin{bmatrix}1 & 1\\1 &
0\end{bmatrix} \cdot \begin{bmatrix}F_{n-1} \\ F_{n-2}\end{bmatrix} \]</p><p>Uma denominação mais interessante para essa relação é: \( u*{t+1} = Au_t \). O
papel que desempenha a matriz A é o de transformar o vetor no &ldquo;tempo&rdquo; t para nos
dar o vetor no &ldquo;tempo&rdquo; seguinte. Estamos lidando aqui com um sistema dinâmico,
que evolui no tempo, e queremos saber, por exemplo, qual o \( u*{10000} \).
Como podemos fazer isso?</p><p>Bom, para começar, é conveniente considerarmos um vetor base \( u_0 \), que no
nosso caso pode ser perfeitamente \( \begin{bmatrix} 1 \\ 0 \end{bmatrix}
\). Assim, segue diretamente que \( u_1 = Au_0 \). E, disso, que \( u_2 =
Au_1 = A \cdot A \cdot u_0 = A^2u_0 \). Logo, a fórmula geral é:</p><p>$$
u^k = A^ku_0
$$</p><p>O que sugere de imediato que a resposta reside nas potências da matriz. Mas isso
pode ser bem pesado matematicamente. Felizmente, existe uma maneira muito
conveniente para resolver esses casos, e envolve os autovalores/autovetores
(<em>eigenvalues/eigenvectors</em>) de uma matriz. Mas, afinal, o que são eles?</p><figure><img src=./evectors.gif><figcaption><h4>Eigenvectors</h4></figcaption></figure><p>Simply put, os autovetores são vetores característicos de uma matriz que, após
transformados por ela, não mudam de direção, mas é possível que mudem em
magnitude dependendo do autovalor. Matematicamente,</p><p>$$
Ax =
\lambda x
$$</p><p>Em que \( x \) é um autovetor da matriz \( A \) e \( \lambda \) um
autovalor do autovetor. Note que, por isso, o autovetor pode encolher (se \( 0
&lt; \lambda &lt; 1 \)), ou aumentar (se \( \lambda > 1 \)), ou apontar para a
direção oposta (se \( \lambda &lt; 0 \)) quando transformado.</p><p>Agora, o próximo passo, um grande passo, é notar que nós podemos decompor a
matriz \( A \) em seus autovetores e autovalores. Isto é possível se os
autovetores forem todos linearmente independentes, caso em que uma matriz cheia
de autovetores tem uma inversa, e isso será crucial para nós.</p><p>Daí que, tratando \( S \) como uma matriz de autovetores nas colunas e \(
\Lambda \) como uma matriz de autovalores na diagonal e zeros em todo o resto,
podemos afirmar que</p><p>$$
AS = S\Lambda
$$</p><p>O que não é óbvio, mas que pode ser visto deste modo:</p><p>\[ A \cdot \begin{bmatrix} x_1 & x_2 \\ x_1 & x_2 \end{bmatrix} =
\begin{bmatrix} \lambda_{1} x_1 & \lambda_{2} x_2 \\ \lambda_{1} x_1 &
\lambda_{2} x_2 \end{bmatrix} = \begin{bmatrix} x_1 & x_2 \\ x_1 & x_2
\end{bmatrix} \cdot \begin{bmatrix} \lambda_{1} & 0 \\ 0 & \lambda_{2}
\end{bmatrix} \]</p><p>Caso não tenha ficado claro: cada coluna de \( S \) é um autovetor. Quando
fazemos \( AS \), obtemos uma matriz cujas colunas são os autovetores vezes
seus respectivos autovalores (consequência direta de \( Ax = \lambda x \)).
Essa matriz pode, enfim, ser &ldquo;diagonalizada&rdquo; separando esses seus dois
componentes como mostrado.</p><p>Ok, mas por que isso é útil? Queremos investigar as potências de uma matriz
afinal! Essa decomposição de matriz serve justamente a esse propósito. Vejamos.</p><p>Vamos multiplicar \( AS \) pela direita por \( S^{-1} \). Isso dá: \( A =
S\Lambda S^{-1} \), já que \( SS^{-1} = I \). Agora, \( A^2 = S\Lambda
S^{-1}S\Lambda S^{-1} = S \Lambda^{2}S^{-1} \). E, em geral:</p><p>$$
A^k = S \Lambda^{k}S^{-1}
$$</p><p>E assim vemos o quanto a decomposição pode simplificar a exponenciação de uma
matriz! Agora, retomando lá do início, \( u_k = A^ku_0 \) pode ser reescrito
como \( u_k = S \Lambda^{k}S^{-1}u_0 \).</p><p>Mas perceba que seria mais interessante termos \( u_0 \) em uma nova &ldquo;forma&rdquo;,
mais especificamente, como uma combinação linear dos autovetores, \( Sc = u_0
\), onde c é o vetor de coeficientes que resolve esse sistema de equações, \(
c = S^{-1}u_0 \). E, com isso, nós temos tudo que precisamos porque</p><p>$$
u_k = A^ku_0 = S \Lambda^{k}S^{-1} Sc = S \Lambda^{k}c
$$</p><p>Isso implica que, no nosso caso, para uma matrix 2x2 (só dois autovetores), \(
u<em>k = c_1\lambda</em>{1}^{k}x<em>1 + c_2\lambda</em>{2}^{k}x_2 \), onde os \( x_i \) são
os autovetores, e o restante escalares. O que indica que a evolução do nosso
sistema de equações é totalmente ditada pelos autovalores (não importa quantas
vezes a matriz A transforme os autovetores, a direção deles nunca muda).</p><p>Agora resta calcular tudo com o NumPy.</p><p>O primeiro passo é criar a matriz A. Logo depois, obter os
autovalores/autovetores, nessa ordem, com a função <em>numpy.linalg.eig()</em>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>evalues</span><span class=p>,</span> <span class=n>evectors</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>eig</span><span class=p>(</span><span class=n>A</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>evalues</span><span class=p>,</span> <span class=n>evectors</span><span class=p>,</span> <span class=n>sep</span><span class=o>=</span><span class=s2>&#34;</span><span class=se>\n\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>[ 1.61803399 -0.61803399]

[[ 0.85065081 -0.52573111]
 [ 0.52573111  0.85065081]]
</code></pre><p>Mas, lembrando que queremos os autovalores na matriz diagonal \( \Lambda \).
Também precisamos calcular o vetor c.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>Lambda</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>diag</span><span class=p>(</span><span class=n>evalues</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>solve</span><span class=p>(</span><span class=n>evectors</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>])[:,</span> <span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>])</span>
</span></span></code></pre></div><p>Antes, vamos olhar para a nossa matriz \( \Lambda \), porque ela pode revelar
coisas interessantes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>Lambda</span>
</span></span></code></pre></div><pre><code>array([[ 1.61803399,  0.        ],
       [ 0.        , -0.61803399]])
</code></pre><p>O primeiro número pode parecer familiar para o leitor, afinal é um dos mais
famosos: o número de ouro. E é precisamente ele que descreve como os números de
Fibonacci estão crescendo!! Como sabemos que \( u<em>k = c_1\lambda</em>{1}^{k}x<em>1 +
c_2\lambda</em>{2}^{k}x_2 \), substituindo temos:</p><p>$$
u_k = c_1\cdot(1.618)^{k}\cdot x_1 + c_2\cdot(-0.618)^{k}\cdot
x_2
$$</p><p>E fica evidente que, para um k muito grande, o número de ouro é o que governa o
crescimento dos números, com o outro termo tentendo a 0 com k aumentando
arbitrariamente. Fica claro também que esses números crescem exponencialmente.</p><p>Agora, vamos criar uma função para calcular \( u_k \). Nela usaremos a matriz
\( S \) (evectors), o vetor c e a matriz \( \Lambda \).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>FIB</span><span class=p>(</span><span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>evectors</span> <span class=o>@</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>matrix_power</span><span class=p>(</span><span class=n>Lambda</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span> <span class=o>@</span> <span class=n>c</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>15</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>FIB</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;</span><span class=se>\t</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>[1.]    [2.]    [3.]    [5.]    [8.]    [13.]   [21.]   [34.]   [55.]   [89.]   [144.]  [233.]  [377.]  [610.]
</code></pre><p>Tudo o que fiz foi calcular \( u_k \) com a fórmula e extrair do vetor
resultante a primeira linha (\( F_k \)).</p><p>E quanto à sua eficiência?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>FIB</span><span class=p>(</span><span class=mi>10000</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>32.8 µs ± 1.46 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre><p>Não surpreende ser tão rápido, estamos usando o NumPy afinal.</p><p>Mas a beleza dessa abordagem está menos em sua eficiência e mais no que a
álgebra linear pode nos revelar. A partir dela pudemos entender muito melhor
sobre esses números, o que governa o seu crescimento. Mas, além disso, problemas
com sistemas dinâmicos como esse estão em todos os lugares, e lidar com eles
requer inevitavelmente conhecer os autovetores/autovalores de uma matriz e como
podemos usá-los.</p><p>A sequência de Fibonacci é um bom exemplo para introduzir esses conceitos da
álgebra linear, cujo conhecimento é exigido por muitos outros problemas mais
práticos/complexos, como Cadeias de Markov, e o leitor pode achar interessante
também que o algoritmo do Google tem como fundamento os autovetores de uma
matriz de Markov. Enfim, trata-se de um tópico fascinante por si só.</p><p>Antes de terminar o post, fica a minha recomendação para um melhor entendimento
de tudo isso: a série de vídeos
<a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">&ldquo;Essence of Linear Algebra&rdquo;</a>
do 3Blue1Brown e este <a href=http://setosa.io/ev/eigenvectors-and-eigenvalues/>site</a>
que conta com ótimas visualizações do que acabamos de fazer aqui.</p></section></article><hr class=my-8><div data-theme-copy-code-tooltip role=tooltip class="absolute pointer-events-none border border-divider bg-secondary-background rounded-md px-2" style=opacity:0>Copiado<div data-theme-copy-code-tooltip-arrow class="absolute bg-secondary-background border-r border-b border-divider w-[8px] h-[8px] rotate-45"></div></div><nav class="flex justify-between flex-wrap sm:flex-nowrap gap-2" aria-label="Navegação entre posts"><a class="flex basis-1/2 grow items-center gap-2 border-0" href=/pt/posts/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy/><span class=text-primary><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg></span>Puzzle do cavalo no tabuleiro infinito com NumPy</a>
<a class="flex basis-1/2 grow items-center self-end text-right h-full justify-end gap-2 border-0" href=/pt/posts/metodo-de-newton/>Método de Newton
<span class=text-primary><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span></a></nav></main></div><footer class="mx-auto w-full max-w-5xl flex flex-col sm:flex-row sm:justify-between gap-4 px-default-padding py-4"><div class="flex flex-wrap justify-center sm:order-last sm:justify-end"><nav aria-label=Links><div class="flex gap-4"><a class="border-0
transform hover:scale-110 hover:text-primary transition transition-transform transition-colors" href=mailto:phelipe_teles@hotmail.com aria-label=E-mail><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a class="border-0
transform hover:scale-110 hover:text-primary transition transition-transform transition-colors" href=https://linkedin.com/in/phelipeteles aria-label=LinkedIn><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a class="border-0
transform hover:scale-110 hover:text-primary transition transition-transform transition-colors" href=https://github.com/phelipetls aria-label=GitHub><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a class="border-0
transform hover:scale-110 hover:text-primary transition transition-transform transition-colors" href=https://phelipetls.github.io/pt/posts/index.xml aria-label="Blog RSS Feed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss inline"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></nav></div><p class="flex-1 text-center sm:text-left">Este conteúdo está sob a licença
<a rel=license href=http://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0</a>.</p></footer></div><script type=module src=https://phelipetls.github.io/js/bundle.min.js></script>
<script src=https://phelipetls.github.io/js/lite-yt-embed.min.js></script></body></html>